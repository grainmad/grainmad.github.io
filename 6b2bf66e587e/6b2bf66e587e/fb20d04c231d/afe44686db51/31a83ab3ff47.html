<hr>
<p>title: “虚树”<br>date: 2024-06-03 10:42:02<br>updated: 2024-06-05 06:38:41<br>tag: [notion, Algorithm, 树与图, 树上问题]<br>categories: Algorithm<br>mathjax: true<br>comments: true<br>description: </p>
<hr>
<h1 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h1><p>给出一个$n$个点的树，$q$次询问，第i次选择$k_i$个点，问关于这$k_i$个的点的问题。$\sum k_i &lt; n$</p>
<p>暴力$O(nq)$，每次建立$k_i$个点的虚树，建立与处理都是$O(k_i)$，总复杂度$O(\sum k_i)$</p>
<p>构成虚树的点是关键点，关键点=查询的k个点+查询点的两两之间的公共祖先+根节点</p>
<p>如果两两之间的公共祖先都不同那么是不是就有$k^2$个祖先节点？好像最坏的情况是满二叉树的k个叶子，这样关键点也不过2k。</p>
<p>{% asset_img ‘Untitled.png’ %}</p>
<p>```cpp<br>const int N = 200005, M = N * 2;<br>int h[N], to[M], ne[M], tot;<br>void add(int x, int y) {  // 连边<br>    to[++tot] = y;<br>    ne[tot] = h[x];<br>    h[x] = tot;<br>}</p>
<p>// 遍历x所连的点<br>vector<int> radiate(int x) {<br>    vector<int> rt;<br>    for (int i = h[x]; i; i = ne[i])<br>        rt.push_back(to[i]);<br>    return rt;<br>}</p>
<p>void clearTree() {<br>    // for (int i = 1; i &lt;= n; i++) {<br>    //     h[i] = 0;<br>    // }<br>    function&lt;void(int, int)&gt; cls = [&amp;](int x, int fa) {<br>        for (int i = h[x]; i; i = ne[i]) {<br>            int y = to[i];<br>            if (y == fa)<br>                continue;<br>            cls(y, x);<br>        }<br>        h[x] = 0;<br>    };<br>    cls(1, 0);  // 含1连通块清空<br>    tot = 0;<br>}</p>
<p>int dep[N], fa[N][20];<br>int dfn[N], cnt;  // dfs序<br>int s[N], top;    // 栈</p>
<p>// 初始的树是双向边, dfs(1, 0),  dep, fa, dfn<br>void dfs(int x, int f) {  // 树上倍增<br>    dfn[x] = ++cnt;<br>    dep[x] = dep[f] + 1;<br>    fa[x][0] = f;<br>    for (int i = 1; i &lt;= 19; i++)<br>        fa[x][i] = fa[fa[x][i - 1]][i - 1];</p>
<pre><code>for (int i = h[x]; i; i = ne[i]) {
    int y = to[i];
    if (y == f)
        continue;
    dfs(y, x);
}
</code></pre>
<p>}<br>int lca(int x, int y) {  // 求lca<br>    if (dep[x] &lt; dep[y])<br>        swap(x, y);<br>    for (int i = 19; ~i; i–)<br>        if (dep[fa[x][i]] &gt;= dep[y])<br>            x = fa[x][i];<br>    if (x == y)<br>        return y;</p>
<pre><code>for (int i = 19; ~i; i--)
    if (fa[x][i] != fa[y][i])
        x = fa[x][i], y = fa[y][i];
return fa[x][0];
</code></pre>
<p>}<br>int cmp(int a, int b) {<br>    return dfn[a] &lt; dfn[b];<br>}</p>
<p>// 构建的虚树是单向边<br>void build(vector<int>&amp; a) {  // 建虚树<br>    int k = a.size();<br>    sort(a.begin(), a.end(), cmp);  // 按dfs序排序<br>    tot = 0;         // 清空前一颗树，注意各树节点x h[x]=0<br>    s[top = 1] = 1;  // 根节点入栈<br>    if (k &amp;&amp; a[0] != 1)<br>        s[++top] = a[0];<br>    for (int i = 1; i &lt; k; i++) {  // 枚举查询点<br>        int l = lca(s[top], a[i]);<br>        // 对当前链连边,top出栈<br>        while (top &gt; 1 &amp;&amp; dep[s[top - 1]] &gt;= dep[l])<br>            add(s[top - 1], s[top]), top–;<br>        // 对lca和top连边,top出栈,lca入栈<br>        if (l != s[top])<br>            add(l, s[top]), s[top] = l;<br>        // 查询点入栈<br>        s[++top] = a[i];<br>    }<br>    while (top)  // 对最后一条链连边,top出栈<br>        add(s[top - 1], s[top]), top–;<br>}</p>
<p>void printVtree(int x, int fa) {<br>    cout &lt;&lt; x &lt;&lt; “:”;<br>    for (int i = h[x]; i; i = ne[i]) {<br>        if (to[i] == fa)<br>            continue;<br>        cout &lt;&lt; to[i] &lt;&lt; “ “;<br>    }<br>    cout &lt;&lt; endl;<br>    for (int i = h[x]; i; i = ne[i]) {<br>        int y = to[i];<br>        if (y == fa)<br>            continue;<br>        printVtree(y, x);<br>    }<br>}</p>
<p>```<!--more--></p>
<p><a href="https://codeforces.com/contest/1923/problem/E">https://codeforces.com/contest/1923/problem/E</a></p>
<p>给你一棵树，它由 $n$ 个顶点组成，编号从 1 到 n 。每个顶点都有某种颜色，用 1 到 n 之间的整数表示。</p>
<p>如果符合以下条件，那么这棵树的一条简单路径就叫做美丽路径：</p>
<ul>
<li>至少由 2 个顶点组成；</li>
<li>路径的第一个顶点和最后一个顶点的颜色相同；</li>
<li>路径上没有其他顶点的颜色与第一个顶点相同。</li>
</ul>
<p>计算这棵树的美丽简单路径的数量。请注意，路径是不定向的(即从 x 到 y 的路径与从 y 到 x 的路径相同)。</p>
