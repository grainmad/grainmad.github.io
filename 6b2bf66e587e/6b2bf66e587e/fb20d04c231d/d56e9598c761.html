<hr>
<p>title: “tarjan 桥与割点”<br>date: 2024-06-03 10:42:02<br>updated: 2024-06-05 07:32:22<br>tag: [notion, Algorithm, 树与图]<br>categories: Algorithm<br>mathjax: true<br>comments: true<br>description: “<ul style='text-align: left;'><li>tarjan 桥与割点</li></ul>“</p>
<hr>
<h1 id="tarjan-桥与割点"><a href="#tarjan-桥与割点" class="headerlink" title="tarjan 桥与割点"></a>tarjan 桥与割点</h1><p>DFN(u)为节点u 搜索的次序编号(时间戳);</p>
<p>LOW(u)为u 或 u的子树能够追溯到的最早的栈中节点的次序号;</p>
<p>由定义可以得出，当 DFN(u)=LOW(u)时，以u为根的搜索子树上所有节点是一个强连通分量。</p>
<hr>
<p>桥</p>
<pre><code class="cpp">// lc 1192
class Solution {
public:
    #define N 100005
    vector&lt;int&gt; g[N];
    vector&lt;vector&lt;int&gt;&gt; ans;
    int dfn[N], low[N], id=0;
    void targan(int u, int fa) {
        dfn[u] = low[u] = ++id;
        for (int i:g[u]) {
            if (i == fa) continue;
            if (dfn[i]) {
                low[u] = min(low[u], dfn[i]);
            } else {
                targan(i, u);
                low[u] = min(low[u], low[i]);
                if (low[i]&gt;dfn[u]) ans.emplace_back(vector&lt;int&gt;{u, i});
            }
        }
    }
    vector&lt;vector&lt;int&gt;&gt; criticalConnections(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) {
        for (auto&amp; i:connections) {
            g[i[0]].push_back(i[1]);
            g[i[1]].push_back(i[0]);
        }
        targan(0, -1);
        return ans;
    }
};
</code></pre>
<p>在dfs树中，如果v节点的父节点时u，且low[v]&gt;dfn[u]，说明v子树中没有其他路径通往u及祖先，所以(u,v)是桥，移除后会让连通分量增加。</p>
<hr>
<p>割点</p>
<pre><code class="cpp">// p3388 logu
#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 100010;
int dfn[N], low[N], idx;
vector&lt;int&gt; g[N];
set&lt;int&gt; st;
int n, m;
void tarjan(int u, int fa) {
    dfn[u] = low[u] = ++idx;
    int child = 0;
    for (auto v : g[u]) {
        if (fa == v) continue;
        if (!dfn[v]) {
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] &gt;= dfn[u] &amp;&amp; fa != -1) st.insert(u);
            if (fa == -1) child++;
        }
        low[u] = min(low[u], dfn[v]);
    }
    if (child &gt;= 2 &amp;&amp; fa == -1) st.insert(u);
}

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; m; i++) {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y);
        g[y].push_back(x);
    }
    for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i, -1);

    cout &lt;&lt; st.size() &lt;&lt; endl;
    for (auto x : st) cout &lt;&lt; x &lt;&lt; &quot; &quot;;
}
</code></pre>
<p>求根节点单独处理，通过子树个数超过2判断。</p>
