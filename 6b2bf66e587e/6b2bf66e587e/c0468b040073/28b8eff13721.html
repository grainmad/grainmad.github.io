<hr>
<p>title: “树状数组”<br>date: 2024-06-03 10:42:02<br>updated: 2024-06-05 06:38:41<br>tag: [notion, Algorithm, 区间操作]<br>categories: Algorithm<br>mathjax: true<br>comments: true<br>description: </p>
<hr>
<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>```cpp<br>ll BIT[N];<br>// ll xBIT[N];</p>
<p>void bit_add(int x, ll val) {<br>    for (int i=x; i&lt;N; i+=i&amp;-i) {<br>        BIT[i] += val;<br>        // xBIT[i] += x<em>val;<br>        // 区间查询时 BIT[i] += val; xBIT[i] += x</em>val;<br>    }<br>}</p>
<p>ll bit_ps(int x) {<br>    ll rt = 0;<br>    for (int i=x; i&gt;0; i-=i&amp;-i) {<br>        rt += BIT[i];<br>        // rt += x*BIT[i]-xBIT[i];<br>        // 区间查询时 rt += (x+1)*BIT[i]-xBIT[i];<br>    }<br>    return rt;<br>}</p>
<p>//BIT 维护a<br>//单点修改：bit_add(x, val); 下标x增加val<br>//区间和：  bit_ps(y)-bit_ps(x-1); a[x…y]的区间和</p>
<p>// BIT 维护a的差分<br>//区间修改：bit_add(x, val); bit_add(y+1, -val) a[x…y]各增加val<br>//单点值： bit_ps(x);</p>
<p>// BIT 维护差分，间接维护a的前缀<br>//区间修改：bit_add(x, val), bit_add(y+1, -val); a[x…y]各增加val<br>//区间和：  bit_ps(y)-bit_ps(x-1); a[x…y]的区间和</p>
<p>/*<br>差分数组间接维护前缀数组原理<br>a 原数组，d 差分数组，p 前缀数组<br>a[0] = d[0] = p[0] = 0</p>
<p>d[i] = a[i] - a[i-1]<br>a[i] = p[i] - p[i-1]</p>
<p>Σd[i] = a[n], i ∈[1,n]<br>Σa[i] = p[n], i ∈[1,n]<br>ΣΣd[j] = p[n], j ∈[1,i], i ∈[1,n]<br>p[n] = (n+1)Σd[i]-Σd[i]*i</p>
<p>*/</p>
<p>```<!--more--></p>
<h1 id="区间操作"><a href="#区间操作" class="headerlink" title="区间操作"></a>区间操作</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>定义数组长度为n的<code>a</code>, 数组的存储索引从1到n，<strong>代码中<code>a[0]=0</code></strong><br>修改a的某个元素时间复杂度是O(1), 求区间和是O(n)。<br>求区间和可以求前缀和再做差。</p>
<h2 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h2><p>定义差分数组<code>d[i] = a[i]-a[i-1]</code><br>那么：<br><code>d[1] = a[1]</code></p>
<p><code>d[2] = a[2]-a[1]</code></p>
<p><code>d[3] = a[3]-a[2]</code></p>
<p><code>...</code></p>
<p><code>d[i] = a[i]-a[i-1]</code></p>
<p><code>...</code></p>
<p><code>d[n] = a[n]-a[n-1]</code></p>
<p><code>d[1]+d[2]+d[3]+...+d[i]+...+d[n] = a[n]</code><br>即$a[n] = \sum \limits_{i=1}^{n}d[i]$<br>求d的前缀和就是a的一个元素。<br>单点修改d[r+1]-=val, d[l] +=val, 就可做到区间[l,r]每个元素增长val。<br>区间修改O(1), 单点查询O(n)</p>
<h2 id="前缀数组"><a href="#前缀数组" class="headerlink" title="前缀数组"></a>前缀数组</h2><p>区间查询O(1)</p>
<p>$p[n] = \sum \limits_{i=1}^{n}a[i]， p[0] = 0$</p>
<h2 id="树状数组-1"><a href="#树状数组-1" class="headerlink" title="树状数组"></a>树状数组</h2><p>树状数组的功能，O(logn) 的时间复杂度让<code>a[i]</code>增加val，O(logn) 的时间复杂度求<code>a[1...i]</code>。<code>1&lt;=i&lt;=n</code></p>
<p>如果用树状数组维护差分数组。那么区间修改O(logn), 单点查询O(logn)</p>
<p>如果要查询区间任然可以维护差分数组，不过要用差分数组来表示a的前缀数组。<br><code>p[n]-p[n-1] = a[n], a[n] = d[n]-d[n-1]</code><br>$p[n] = \sum \limits_{i=1}^{n}a[i]$<br>$a[n] = \sum \limits_{i=1}^{n}d[i]$<br>$p[n] = \sum \limits_{i=1}^{n} \sum \limits_{j=1}^{i}d[j] = \sum \limits_{i=1}^{n}(n+1-i)\times d[i] = (n+1)\sum \limits_{i=1}^{n} d[i] + \sum \limits_{i=1}^{n}i\times d[i]$</p>
