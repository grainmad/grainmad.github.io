<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1061C Multiplicity</title>
    <url>/2023/06/06/1061C/</url>
    <content><![CDATA[<h1 id="Multiplicity"><a href="#Multiplicity" class="headerlink" title="Multiplicity"></a>Multiplicity</h1><p>Created by LXC on Tue May 30 09:23:32 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1061/C">https://codeforces.com/problemset/problem/1061/C</a></p>
<p>ranting: 1700</p>
<p>tag: data structures, dp, implementation, math, number theory</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>给出长度为n的数组a，现在从中选出一个子序列b，如果$b_i \bmod i = 0$则称b为好数组。</p>
<p>请问能够选出多少个好数组。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>动态规划。</p>
<p>考虑每个前缀形成的好数组长度。<br>定义$f_{i,j}$为前i个数形成了长度为j的好数组的个数。<br>那么对于第i个数$a_i$：</p>
<ul>
<li>若$a_i$不是是j的倍数，那么不能作为长度为j的好数组的最后一个数，长度为j的好数组只能由前i-1个数构造，所以有$f_{i,j} = f_{i-1,j}$</li>
<li>若$a_i$是j的倍数，那么既可以选择也可以不选择$a_i$作为长度为j的好数组的最后一个数，所以有$f_{i,j} = f_{i-1, j} + f_{i-1,j-1}$。</li>
</ul>
<p>显然这样的空间复杂度是$O(n\sqrt n)$，本题时间给足3s，但是空间只有256m。<br>我们需要考虑空间优化。由于状态转移只涉及$f_{i-1,?}$和$f_{i,?}$所以可以用滚动数组减少一维空间。</p>
<p>对于状态转移$f_{i,?}$只需考虑从$f_{i-1,j}$转移来，其中$j$为$a_i$的因子，共$O(\sqrt a_i)$个。所以总时间复杂度$O(n\sqrt {\max \limits_{i=1}^{n} a_i})$，由于使用了滚动数组，我们需要由大到小的枚举因子。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, j;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j * j &lt; x; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % j == <span class="number">0</span>)</span><br><span class="line">                f[x / j] += f[x / j - <span class="number">1</span>], f[x / j] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j * j &gt; x)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % j == <span class="number">0</span>)</span><br><span class="line">                f[j] += f[j - <span class="number">1</span>], f[j] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans += f[i];</span><br><span class="line">        ans %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>data structures</tag>
        <tag>dp</tag>
        <tag>implementation</tag>
        <tag>math</tag>
        <tag>number theory</tag>
      </tags>
  </entry>
  <entry>
    <title>1082E Increasing Frequency</title>
    <url>/2023/06/06/1082E/</url>
    <content><![CDATA[<h1 id="Increasing-Frequency"><a href="#Increasing-Frequency" class="headerlink" title="Increasing Frequency"></a>Increasing Frequency</h1><p>Created by LXC on Wed May 31 19:16:05 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1082/E">https://codeforces.com/problemset/problem/1082/E</a></p>
<p>ranting: 2000</p>
<p>tag: binary search, dp, greedy</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>给出n个数的数组$a_1, a_2, \cdots, a_n$，每个数范围在1到5e5内</p>
<p>给出正数c。</p>
<p>现在可以选取一段区间使其区间的每个数都增加k。k可以是任意整数。</p>
<p>现在问求最多有多少个数可以变成c。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>定义$f_{l,r,d}$为区间<code>[l,r]</code>内的数都增加c-d后，这个区间内的c个数。</p>
<p>我们要求的答案是$\max \limits_{1&lt; l\le r &lt; n, d \in a} f_{1,l-1, c} + f_{l,r,d}+f_{r+1, n, c}$。</p>
<p>等价于$\max \limits_{1&lt; l\le r &lt; n, d \in a} f_{1,n, c} + f_{l,r,d}-f_{l, r, c}$。</p>
<p>将问题转化，对于每个d，我们生成一个新的数组s，遍历数组a，当遇到d则将1加入到新数组s中，将a数组中以d作为分割点所有子段中的c的个数cnt统计下来，并将-cnt加入到s中。</p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c = 2 d = 3</span><br><span class="line">a = [1, 2, 3, 4, 2, 3, 1, 2, 2, 3, 4, 2]</span><br><span class="line">s = [-1, 1, -1, 1, -2, 1]</span><br></pre></td></tr></table></figure>
<p>我们只需求s的最大子段和便可以得到d的贡献。求出所有的<br>的贡献时间复杂度是$O(n)$</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max_seg</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cur = <span class="built_in">max</span>(cur + s[i], <span class="number">0</span>);</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] + (a[i] == c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        g[a[i]].<span class="built_in">push_back</span>(-(p[i] - p[pre[a[i]]]));</span><br><span class="line">        g[a[i]].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        pre[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, sz = *<span class="built_in">max_element</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>); i &lt;= sz; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == c)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// for (int j : g[i]) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; j &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max_seg</span>(g[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; p[n] + ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>dp</tag>
        <tag>binary search</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>1120A Diana and Liana</title>
    <url>/2023/05/28/1120A/</url>
    <content><![CDATA[<h1 id="Diana-and-Liana"><a href="#Diana-and-Liana" class="headerlink" title="Diana and Liana"></a>Diana and Liana</h1><p>Created by LXC on Sun May 21 23:20:53 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1120/A">https://codeforces.com/problemset/problem/1120/A</a></p>
<p>ranting: 1900</p>
<p>tag: greedy, implementation, two pointers</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个长度为m的序列a，以及一个长度为s的序列b。<br>如果删除一些数，使得剩余的数按顺序k个一组，能够产生至少n组（不足k个的舍去）。并且其中至少有一组包含了序列b中的所有元素。</p>
<p>请构造出删除的下标序列。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们可以用滑动窗口，维护窗口<code>[l,r]</code>其恰好包含b中所有序列，且<code>[l+1,r],[l,r-1]</code>都没有完全包含b中所有序列。</p>
<p>这时窗口大小为<code>r-l+1</code></p>
<p>若<code>r-l+1 &lt; k</code>，则窗口内元素无需删除，我们只需删除前<code>r%k</code>个（注意<code>r&lt;k</code>则无需删除），以便当前窗口能恰好分到一组中。</p>
<p>若<code>r-l+1 &gt;= k</code>，则窗口内元素需要删除<code>r-l+1-k</code>，使其变为长度为k的区间，然后删除<code>[1,l-1]</code>区间中前<code>(l-1)%k</code>个。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], mx[N], mp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, k, n, s;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; k &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s; i++) &#123;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line">        mx[b]++;</span><br><span class="line">        st.<span class="built_in">insert</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = st.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">1</span>, l = <span class="number">0</span>; r &lt;= m; r++) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="keyword">if</span> (++mp[a[r]] == mx[a[r]])</span><br><span class="line">            cur++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur &lt; d)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur == d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[a[l + <span class="number">1</span>]]-- == mx[a[l + <span class="number">1</span>]])</span><br><span class="line">                cur--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="comment">// 包含了模板的区间为[l,r]。</span></span><br><span class="line">        <span class="comment">// r-l+1 如果不足k个，r&lt;=k不用删，否则删除r%k个</span></span><br><span class="line">        <span class="comment">// r-l+1</span></span><br><span class="line">        <span class="comment">// 如果大于k个，需要删除r-l+1-k个以达到当前区间为k个，前方需要删除(l-1)%k个</span></span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt;= k) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r % k &lt;= m - k * n) &#123;</span><br><span class="line">                cout &lt;&lt; r % k &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r % k; i++) &#123;</span><br><span class="line">                    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> c = r - l - k + <span class="number">1</span> + (l - <span class="number">1</span>) % k;</span><br><span class="line">            <span class="keyword">if</span> (c &lt;= m - k * n) &#123;</span><br><span class="line">                cout &lt;&lt; c &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (l - <span class="number">1</span>) % k; i++) &#123;</span><br><span class="line">                    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l, cnt = <span class="number">0</span>; cnt &lt; r - l - k + <span class="number">1</span> &amp;&amp; i &lt;= r; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (--mx[a[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                        cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>implementation</tag>
        <tag>greedy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>1156C Match Points</title>
    <url>/2023/05/17/1156C/</url>
    <content><![CDATA[<h1 id="Match-Points"><a href="#Match-Points" class="headerlink" title="Match Points"></a>Match Points</h1><p>Created by LXC on Sat May 13 13:22:48 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1156/C">https://codeforces.com/problemset/problem/1156/C</a></p>
<p>ranting: 2000</p>
<p>tag: binary search, greedy, sortings, ternary search, two pointers</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个长度为n的数组a和整数z，求最大匹配的数对。</p>
<p>匹配的数对是指：<br>数组中的两个元素的差的绝对值大于等于z。<br>并且这两个数没有和其他数匹配。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先将数组排序。</p>
<p>二分答案。</p>
<p>如果答案是k，那么最小的k个数和最大的k个数匹配，如果匹配的任意两个数都是大于等于z的，那么不断增大k直到找到最后一个满足匹配的k。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, z;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; z;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[n - x + i] - a[i] &lt; z)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">        <span class="type">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(m)) &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; r - <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>binary search</tag>
        <tag>greedy</tag>
        <tag>two pointers</tag>
        <tag>sortings</tag>
        <tag>ternary search</tag>
      </tags>
  </entry>
  <entry>
    <title>1195D2 Submarine in the Rybinsk Sea (hard edition)</title>
    <url>/2023/05/17/1195D2/</url>
    <content><![CDATA[<h1 id="Submarine-in-the-Rybinsk-Sea-hard-edition"><a href="#Submarine-in-the-Rybinsk-Sea-hard-edition" class="headerlink" title="Submarine in the Rybinsk Sea (hard edition)"></a>Submarine in the Rybinsk Sea (hard edition)</h1><p>Created by LXC on Tue May 16 08:33:58 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1195/D2">https://codeforces.com/problemset/problem/1195/D2</a></p>
<p>ranting: 1800</p>
<p>tag: combinatorics, math, number theory</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>设$x = \overline{x_px_{p-1}\cdots x_{0}},y = \overline{y_qy_{q-1}\cdots y_{0}}$</p>
<p>当$p&gt;q$时，函数$f(x,y) = x_p\cdots x_qy_qx_{q-1}y_{q-1}\cdots x_0y_0$</p>
<p>当$p&lt;=q$时，函数$f(x,y) = x_q\cdots x_py_px_{p-1}y_{p-1}\cdots x_0y_0$</p>
<p>现在给出一个长度为$n$的数组$a$，$a_i\le 1e^9, n\le 100000$</p>
<p>求$\sum \limits_{x=1}^{n} \sum \limits_{j=1}^{n} f(a_i, a_j)$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑每个数拆位后的贡献。</p>
<p>数组中的某个p位十进制数$a_k=\overline{t_pt_{p-1}\cdots t_{0}}$作为$f(x,y)$的$y$，贡献的答案与x的长度有关。</p>
<p>当x长度为1，则为答案贡献数值$\overline{t_pt_{p-1}\cdots t_1 0 t_{0}}$。</p>
<p>当x长度为2，则为答案贡献数值$\overline{t_pt_{p-1}\cdots t_2 0 t_1 0 t_{0}}$。</p>
<p>当x长度为i，则为答案贡献数值$\overline{t_pt_{p-1}\cdots t_i 0 \cdots 0 t_{0}}$。</p>
<p>实际上x的长度不超过10，我们可以预处理出数组中所有长度出现的次数。记为$c_i$，长度为i的元素出现的次数。</p>
<p>这样所有长度为i的x，与$a_k$作为y值的贡献就是$\overline{t_pt_{p-1}\cdots t_i 0 \cdots 0 t_{0}}\times c_i$</p>
<p>同理我们也可以求出$a_k$作为x的贡献值。</p>
<p>这样时间复杂度就是$O(np)$,p是数值最大位数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (string&amp; i : a) &#123;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        <span class="built_in">reverse</span>(i.<span class="built_in">begin</span>(), i.<span class="built_in">end</span>());</span><br><span class="line">        c[i.<span class="built_in">size</span>()]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt; 12; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; c[i] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (string i : a) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot;: &quot;;</span></span><br><span class="line">        <span class="type">int</span> sz = i.<span class="built_in">size</span>();</span><br><span class="line">        string low1, low2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            low1.<span class="built_in">push_back</span>(j &lt; sz ? i[j] : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            low1.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            string t1 = low1 + i.<span class="built_in">substr</span>(<span class="built_in">min</span>(j + <span class="number">1</span>, sz));</span><br><span class="line">            <span class="built_in">reverse</span>(t1.<span class="built_in">begin</span>(), t1.<span class="built_in">end</span>());</span><br><span class="line">            ll num1 = <span class="built_in">stoull</span>(t1);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; j + 1 &lt;&lt; &quot;-- &quot; &lt;&lt; num1 &lt;&lt; &quot;, &quot;;</span></span><br><span class="line">            ans += num1 % MOD * c[j + <span class="number">1</span>] % MOD;</span><br><span class="line">            ans %= MOD;</span><br><span class="line"></span><br><span class="line">            low2.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            low2.<span class="built_in">push_back</span>(j &lt; sz ? i[j] : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            string t2 = low2 + i.<span class="built_in">substr</span>(<span class="built_in">min</span>(j + <span class="number">1</span>, sz));</span><br><span class="line">            <span class="built_in">reverse</span>(t2.<span class="built_in">begin</span>(), t2.<span class="built_in">end</span>());</span><br><span class="line">            ll num2 = <span class="built_in">stoull</span>(t2);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; j + 1 &lt;&lt; &quot;-- &quot; &lt;&lt; num2 &lt;&lt; &quot;, &quot;;</span></span><br><span class="line">            ans += num2 % MOD * c[j + <span class="number">1</span>] % MOD;</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; fixed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Execution time: &quot;</span></span><br><span class="line">         &lt;&lt; (end_time - start_time) * (<span class="type">int</span>)<span class="number">1e3</span> / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
        <tag>number theory</tag>
        <tag>combinatorics</tag>
      </tags>
  </entry>
  <entry>
    <title>1237C2 Balanced Removals (Harder)</title>
    <url>/2023/05/20/1237C2/</url>
    <content><![CDATA[<h1 id="Balanced-Removals-Harder"><a href="#Balanced-Removals-Harder" class="headerlink" title="Balanced Removals (Harder)"></a>Balanced Removals (Harder)</h1><p>Created by LXC on Fri May 19 15:13:38 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1237/C2">https://codeforces.com/problemset/problem/1237/C2</a></p>
<p>ranting: 1900</p>
<p>tag: binary search, constructive algorithms, divide and conquer, greedy, implementation, sortings</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出n个三维平面上的点，n&lt;50000，n为偶数。</p>
<p>每次可以移除两个点，但是这两个点组成的对角线空间（包括空间边界）内不能存在其他点</p>
<p>请构造出移除的序列。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果n=1000，可以考虑$O(n^2)$做法。<br>每次任选一个点，然后再移除离这个点欧几里得距离最近的点。<br>这样做的正确性在于，如果存在其他点在对角线空间则会选取更近的点。</p>
<p>但是$O(n^2)$在本题会超时</p>
<p>我们采取降维分治。</p>
<p>对于同一x值的所有点进行合并，如果是偶数那么所有点会合并完毕，如果是奇数那么会残留一个点。需要合并。</p>
<p>同理对于二维平面上的点也可以由处理一维后合并组成。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D 3</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(D));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp; self, vector&lt;<span class="type">int</span>&gt; idx, <span class="type">int</span> d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d == D) &#123;</span><br><span class="line">            <span class="keyword">return</span> idx[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : idx) &#123;</span><br><span class="line">            mp[a[i][d]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : mp) &#123;</span><br><span class="line">            <span class="type">int</span> rt = <span class="built_in">self</span>(self, i.second, d + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (rt != <span class="number">-1</span>) &#123;</span><br><span class="line">                p.<span class="built_in">push_back</span>(rt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; p.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            cout &lt;&lt; p[i - <span class="number">1</span>] + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p[i] + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">size</span>() % <span class="number">2</span> ? p.<span class="built_in">back</span>() : <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">idx</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">iota</span>(idx.<span class="built_in">begin</span>(), idx.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(dfs, idx, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>implementation</tag>
        <tag>binary search</tag>
        <tag>greedy</tag>
        <tag>sortings</tag>
        <tag>constructive algorithms</tag>
        <tag>divide and conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>1268A Long Beautiful Integer</title>
    <url>/2023/05/17/1268A/</url>
    <content><![CDATA[<h1 id="Long-Beautiful-Integer"><a href="#Long-Beautiful-Integer" class="headerlink" title="Long Beautiful Integer"></a>Long Beautiful Integer</h1><p>Created by LXC on Wed May 17 09:11:45 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1268/A">https://codeforces.com/problemset/problem/1268/A</a></p>
<p>ranting: 1700</p>
<p>tag: constructive algorithms, greedy, implementation, strings</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个很大的整数a，a用数组表示，无前导0。再给出k。</p>
<p>求一个最小的b使得b&gt;=a</p>
<p>b是一个漂亮整数，满足$b_i = b_{i-k}$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>b显然每k个位会循环一次。</p>
<p>所以确定了前k位就确定了后面的位数。</p>
<p>我们先让b的前k位变为a的前k位。比较b是否能大于等于a。</p>
<p>如果不能，则将前k位看作为一个数，让其加1。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    <span class="keyword">auto</span> t = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        t[i] = s[i % k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= s) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; t;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j += k)</span><br><span class="line">                    t[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j += k)</span><br><span class="line">                    t[j] = s[i] + <span class="number">1</span>;</span><br><span class="line">                cout &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; t;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; fixed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Execution time: &quot;</span></span><br><span class="line">         &lt;&lt; (end_time - start_time) * (<span class="type">int</span>)<span class="number">1e3</span> / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>implementation</tag>
        <tag>greedy</tag>
        <tag>constructive algorithms</tag>
        <tag>strings</tag>
      </tags>
  </entry>
  <entry>
    <title>1292B Aroma&#39;s Search</title>
    <url>/2023/05/17/1292B/</url>
    <content><![CDATA[<h1 id="Aroma’s-Search"><a href="#Aroma’s-Search" class="headerlink" title="Aroma’s Search"></a>Aroma’s Search</h1><p>Created by LXC on Sat May  6 10:16:40 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1292/B">https://codeforces.com/problemset/problem/1292/B</a></p>
<p>ranting: 1700</p>
<p>tag: brute force, constructive algorithms, geometry, greedy, implementation</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一个无限的二维平面上，有无限个数据节点。<br>这些节点的分布为：</p>
<ol>
<li>第一个节点在位置$(x_0,y_0)$</li>
<li>其余节点$(x_i, y_i) = (a_x*x_{i-1}+b_x, a_y * y_{i-1}+b_y)$</li>
</ol>
<p>你初始位置在(xs, ys)，然后每秒钟可以向上/下/左/右移动一单位距离。<br>请问t秒钟能最多到达多少数据节点。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然第i个数据节点的位置的x和y都是指数增长的。</p>
<p>所以我们考虑x坐标以及y坐标分别不超过xs+t和ys+t的所有数据节点，这些节点的个数是log数量级的</p>
<p>然后对于访问数据节点i到数据节点j这个区间的所有数据节点，所需要的时间是节点i和节点j曼哈顿距离。</p>
<p>我们可以暴力枚举，(xs,ys)到任意区间的一端所需的时间+访问该区间的所有节点的时间，在不超过t的情况下，维护最大的节点数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll x0, y0, ax, ay, bx, by, xs, ys, t;</span><br><span class="line">    cin &gt;&gt; x0 &gt;&gt; y0 &gt;&gt; ax &gt;&gt; ay &gt;&gt; bx &gt;&gt; by &gt;&gt; xs &gt;&gt; ys &gt;&gt; t;</span><br><span class="line">    vector&lt;pair&lt;ll,ll&gt;&gt; p;</span><br><span class="line">    ll cx = x0, cy = y0;</span><br><span class="line">    <span class="keyword">while</span> (cx&lt;=xs+t &amp;&amp; cy&lt;=ys+t) &#123;</span><br><span class="line">        p.<span class="built_in">emplace_back</span>(cx, cy);</span><br><span class="line">        cx = cx*ax+bx;</span><br><span class="line">        cy = cy*ay+by;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;p.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        ll px = xs, py = ys, d = <span class="number">0</span>, tans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i; j&lt;p.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            ll x = p[j].first, y = p[j].second;</span><br><span class="line">            d += <span class="built_in">abs</span>(px-x)+<span class="built_in">abs</span>(py-y);</span><br><span class="line">            <span class="keyword">if</span> (d&lt;=t) tans++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            px = x, py = y;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, tans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;p.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        ll px = xs, py = ys, d = <span class="number">0</span>, tans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            ll x = p[j].first, y = p[j].second;</span><br><span class="line">            d += <span class="built_in">abs</span>(px-x)+<span class="built_in">abs</span>(py-y);</span><br><span class="line">            <span class="keyword">if</span> (d&lt;=t) tans++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            px = x, py = y;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, tans);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>implementation</tag>
        <tag>greedy</tag>
        <tag>constructive algorithms</tag>
        <tag>brute force</tag>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title>132C Logo Turtle</title>
    <url>/2023/06/20/132C/</url>
    <content><![CDATA[<h1 id="Logo-Turtle"><a href="#Logo-Turtle" class="headerlink" title="Logo Turtle"></a>Logo Turtle</h1><p>Created by LXC on Sat Jun 17 09:40:36 2023</p>
<p><a href="https://codeforces.com/problemset/problem/132/C">https://codeforces.com/problemset/problem/132/C</a></p>
<p>ranting: 1800</p>
<p>tag: dp</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>给出一个长度最多为100的串，其只有T和F两种字符组成。其中T代表反转方向，F代表在此方向上前进一步。</p>
<p>你可以操作n次，每次操作可以让其中一个T变为F或F变为T，可以多次操作同一个位置。</p>
<p>现在问操作n次后，里起点的最大距离是多少。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p><del>不断在测试用例中找规律，又被折磨了一下午</del></p>
<p>虽然通过了，但是这个方法的正确性也有待商榷。</p>
<p>首先进行分类讨论：</p>
<p>对于n大于等于串的长度len，考虑贪心。那么我们可以先让所有T变为F，接下来在最后一个位置上操作剩余次数即可，那么剩余的次数如果是奇数那么答案就是距离len-1，否则距离就是len。</p>
<p>那么对于长度不大于n的话，我们考虑用dp。</p>
<p>在已有的串后面新增一个T，代表哨兵。在加入一个T后设T的总数为tsz</p>
<p>那么串可以表示为$a_1T_1a_2T_2\cdots a_{tsz}T_{tsz}$</p>
<p>其中$a_i$代表第i个T与第i-1个T之间F的个数。</p>
<p>现在定义状态$f_{i,j}$为在前i个T中移除j个T（第i个T不移除，所以$j&lt;i$）所能达到的最大值。由于要计算距离起点的最大距离，所以对于最终的终点可能会落在反方向上，于是定义状态$g_{i,j}$为在前i个T中移除j个T（第i个T不移除）所能达到的最小值。</p>
<p>对于$f_{i,j}$如果移除了从第i-k个到第i-1个T共计k个T，那么状态转移可以表示为$f_{i,j} = \max \limits_{0\le k \le j} f_{i-k-1,j-k}\pm (\sum \limits_{c=i-k}^ia_c+k)$。这里注意$\pm$，当i-k-1为奇数时为加号。</p>
<p>对于状态的边界。前i个中删除i个不符合定义，但是将其设置为0可以便于编码，减少分类讨论情况，即$f_{i,i} = 0$；前i个中一个也不删除就是$a_{1}-a_{2}+a_{3}-\cdots a_{i}$，即$f_{i,0} = \sum \limits_{c=1}^i(-1)^{c+1}a_c$</p>
<p>同理可以求出$g_{i,j}$。</p>
<p>那么答案就是$max(f_{tsz, n}, -g_{tsz,n})$吗？</p>
<p>并不是，因为我们同一个T可以变化多次。对于相同的位置两次变化可以视为没有变化。所以$f_{tsz, n-2}, f_{tsz, n-4}, \cdots$，这些与n相差2的倍数的操作次数，也有可能是答案。</p>
<p>那么对$f_{tsz, n-1}, f_{tsz, n-3}, \cdots$，这些与n相差不是2的倍数的操作次数，又怎么说呢？</p>
<p>通过打表发现，$f_{tsz, n-1}$这种状态值有时候会比$f_{tsz,n}$大。</p>
<p>那么对于$f_{tsz, n-1}$再操作一步值会怎样变化？首先变大是不可能的，因为根据状态转移如果变大与$f_{tsz, n-1} &gt; f_{tsz, n}$矛盾。所以只会变小。</p>
<p>变小会小多少呢？答案是1，因为操作一步无非是让移动变成了转向，会减少一步；或让转向变移动，这次移动根据上一条结论不会增加1步，而是减少一步。</p>
<p>所以答案为<br>$\max\limits_{i=1}^{2i \le n} (f_{tsz, n-2i}, -g_{tsz, n-2i}, f_{tsz, n-2i+1}, -g_{tsz, n-2i+1})$</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> sz = <span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27;T&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= sz) &#123;</span><br><span class="line">        cout &lt;&lt; s.<span class="built_in">size</span>() - (n - sz) % <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="built_in">push_back</span>(<span class="string">&#x27;T&#x27;</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">            a.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.<span class="built_in">back</span>()++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(a.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; p.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (auto i : p) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="type">int</span> tsz = sz + <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(a.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(a.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tsz; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] += p[i] - p[i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] -= p[i] - p[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tsz; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j; k++) &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span> - k][j - k] + ((i - <span class="number">1</span> - j) % <span class="number">2</span> ? <span class="number">-1</span> : <span class="number">1</span>) * (p[i] - p[i - k - <span class="number">1</span>] + k));</span><br><span class="line">                g[i][j] = <span class="built_in">min</span>(g[i][j], g[i - <span class="number">1</span> - k][j - k] + ((i - <span class="number">1</span> - j) % <span class="number">2</span> ? <span class="number">-1</span> : <span class="number">1</span>) * (p[i] - p[i - k - <span class="number">1</span>] + k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= tsz; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt;= n; j++) &#123;</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; f[i][j] &lt;&lt; &quot; &quot; &lt;&lt; g[i][j] &lt;&lt;</span></span><br><span class="line">    <span class="comment">//         &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= tsz; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; f[i][n] &lt;&lt; &quot; &quot; &lt;&lt; g[i][n] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; s &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; i -= <span class="number">2</span>) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(&#123;ans, f[tsz][i], -g[tsz][i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= <span class="number">2</span>) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(&#123;ans, f[tsz][i] - <span class="number">1</span>, -g[tsz][i] + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>1335E2 Three Blocks Palindrome (hard version)</title>
    <url>/2023/06/16/1335E2/</url>
    <content><![CDATA[<h1 id="Three-Blocks-Palindrome-hard-version"><a href="#Three-Blocks-Palindrome-hard-version" class="headerlink" title="Three Blocks Palindrome (hard version)"></a>Three Blocks Palindrome (hard version)</h1><p>Created by LXC on Fri Jun 16 11:36:36 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1335/E2">https://codeforces.com/problemset/problem/1335/E2</a></p>
<p>ranting: 1800</p>
<p>tag: brute force, data structures, dp, two pointers</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>定义<strong>三段式回文数组</strong>：回文数组中最多两种元素，不妨设这两种元素为a和b，形如$[\underbrace{a, a, \dots, a}<em>{x}, \underbrace{b, b, \dots, b}</em>{y}, \underbrace{a, a, \dots, a}_{x}]$为三段式回文串，其中x和y大于等于0。</p>
<p>有一个长度为n的数组，数组中的值在1到200。求最长子序列使其为三段式回文数组。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>枚举1到200内的数x，然后用相向双指针l和r。当l和r都指向x时，我们统计开区间<code>(l,r)</code>内出现最多的数mx。当前两个指针所经过的x的个数+mx就是一种三段式回文串的长度，维护其最大值即是答案。</p>
<p>也就是说只需要200次双指针，每次双指针时间复杂度$O(n)$。</p>
<p>关键在于统计区间的众数。如果已知区间<code>[l,r]</code>内的众数，我们只需哈希表记录每个数出现的频次，以及频次的频次。就可以实现$O(1)$求出相邻区间<code>[l+1,r],[l,r-1],[l-1,r],[l,r+1]</code>内的众数。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">201</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cnt[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">        <span class="type">int</span> mx = *<span class="built_in">max_element</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;mx &quot; &lt;&lt; mx &lt;&lt; endl;</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; c = cnt, <span class="built_in">h</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200</span>; i++)</span><br><span class="line">            h[c[i]]++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">-1</span>, r = n, stp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">                <span class="type">int</span> v = c[a[l]]--;</span><br><span class="line">                h[v]--;</span><br><span class="line">                <span class="keyword">if</span> (v)</span><br><span class="line">                    h[v - <span class="number">1</span>]++;</span><br><span class="line">                <span class="keyword">if</span> (mx == v &amp;&amp; h[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (v &gt;= <span class="number">0</span> &amp;&amp; h[v] == <span class="number">0</span>)</span><br><span class="line">                        v--;</span><br><span class="line">                    mx = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; a[l] != i);</span><br><span class="line">            <span class="keyword">if</span> (l == r)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">                <span class="type">int</span> v = c[a[r]]--;</span><br><span class="line">                h[v]--;</span><br><span class="line">                <span class="keyword">if</span> (v)</span><br><span class="line">                    h[v - <span class="number">1</span>]++;</span><br><span class="line">                <span class="keyword">if</span> (mx == v &amp;&amp; h[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (v &gt;= <span class="number">0</span> &amp;&amp; h[v] == <span class="number">0</span>)</span><br><span class="line">                        v--;</span><br><span class="line">                    mx = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; a[r] != i);</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, stp * <span class="number">2</span> + mx);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;ans &quot; &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">                stp++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>data structures</tag>
        <tag>dp</tag>
        <tag>two pointers</tag>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>1340B Nastya and Scoreboard</title>
    <url>/2023/06/06/1340B/</url>
    <content><![CDATA[<h1 id="Nastya-and-Scoreboard"><a href="#Nastya-and-Scoreboard" class="headerlink" title="Nastya and Scoreboard"></a>Nastya and Scoreboard</h1><p>Created by LXC on Tue Jun  6 00:42:06 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1340/B">https://codeforces.com/problemset/problem/1340/B</a></p>
<p>ranting: 1700</p>
<p>tag: bitmasks, dp, graphs, greedy</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>给出n个7极管的发光情况（用7位二进制表示）。</p>
<p>现在恰好额外点亮k个灭了的管，问能组成的最大数是多少。如果不能组成合法的数字则输出-1</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>动态规划。类似01背包</p>
<p>我们先预处理出每个管i能变成的数字u以及需要代价v。</p>
<p>定义$f_{i,j}$为从第i到第n-1个7极管在恰好点亮j个灭了的管后，在能够组成的最大字典序的情况下第i个数的值。</p>
<p>可以初始化$f_{n,0} \ne INF$,其余均为$INF$<br>状态转移$f_{i,j} = \max \limits_{f_{i+1, j-v_i} \ne INF} u_i$，第i个管变为数字$u_i$需要的代价是$v_i$</p>
<p>答案的序列就是$f_{0,k}, f_{1, k-f_{0,k}}, f_{2, k-f_{1,k-f_{0,k}}},\cdots$</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitcnt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x = x &amp; (x - <span class="number">1</span>))</span><br><span class="line">        rt++;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">to_dec</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            rt |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">a</span>(n);  <span class="comment">// 可变数字，需要点亮数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">to_dec</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x ^ d[j]) == d[j] - x) &#123;  <span class="comment">// d[j] 包含 x</span></span><br><span class="line">                a[i].<span class="built_in">emplace_back</span>(j, <span class="built_in">bitcnt</span>(d[j] - x));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (auto&amp; [i, j] : a[i]) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; &quot;[&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;]&quot;</span></span><br><span class="line">        <span class="comment">//          &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[i][j]</span></span><br><span class="line">    <span class="comment">// 后i个数在恰好用了j次点亮后的能形成最大字典序，且第i个数是dp[i][j]</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>, INF));</span><br><span class="line">    dp[n][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [u, v] : a[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - v &gt;= <span class="number">0</span> &amp;&amp; dp[i + <span class="number">1</span>][j - v] != INF)</span><br><span class="line">                    dp[i][j] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt;= k; j++) &#123;</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; dp[i][j] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = k;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; dp[i][j] != INF) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(dp[i][j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [u, v] : a[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u == dp[i][j]) &#123;</span><br><span class="line">                j -= v;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : ans) &#123;</span><br><span class="line">        cout &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; num = &#123;<span class="string">&quot;1110111&quot;</span>, <span class="string">&quot;0010010&quot;</span>, <span class="string">&quot;1011101&quot;</span>, <span class="string">&quot;1011011&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;0111010&quot;</span>, <span class="string">&quot;1101011&quot;</span>, <span class="string">&quot;1101111&quot;</span>, <span class="string">&quot;1010010&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;1111111&quot;</span>, <span class="string">&quot;1111011&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        d[i] = <span class="built_in">to_dec</span>(num[i]);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>dp</tag>
        <tag>greedy</tag>
        <tag>bitmasks</tag>
        <tag>graphs</tag>
      </tags>
  </entry>
  <entry>
    <title>1355C Count Triangles</title>
    <url>/2023/05/20/1355C/</url>
    <content><![CDATA[<h1 id="Count-Triangles"><a href="#Count-Triangles" class="headerlink" title="Count Triangles"></a>Count Triangles</h1><p>Created by LXC on Thu May 18 00:00:39 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1355/C">https://codeforces.com/problemset/problem/1355/C</a></p>
<p>ranting: 1800</p>
<p>tag: binary search, implementation, math, two pointers</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出由小到的大的四个数A,B,C,D。其中$A\le B \le C \le D \le 5e^5$</p>
<p>需要选出三个数x,y,z。满足$A\le x\le B \le x\le C \le z \le D$</p>
<p>使得xyz形成三角形。</p>
<p>问有多少种选法。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于$x&lt;y&lt;z$，我们要使得xyz能组成三角形，必须满足$x+y&gt;z$</p>
<p>可以考虑每个$x+y$能组成的数出现的个数。不妨设$k = x+y$出现的次数t次。<br>那么分三种情况：</p>
<ul>
<li>$t&lt;C$，则没有z可以满足这个k&gt;z</li>
<li>$C\le t\le D$，则可以选择$k-C$个小于k的z，那么贡献答案$t*(k-C)$</li>
<li>$t &gt; D$，则可以选择$D-C+1$个小于k的z，那么贡献答案$t*(D-C+1)$</li>
</ul>
<p>我们可以对每一个数$x$，让其在区间$[x+B, x+C]$内的数都增加1，这个可以用差分数组在$O(B-A)$内实现，差分数组再求一次前缀和则可以得到每个$x+y$出现的个数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll dif[<span class="number">2</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, b, c, d;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span> (ll i = a; i &lt;= b; i++) &#123;</span><br><span class="line">        dif[i + b]++;</span><br><span class="line">        dif[i + c + <span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = a + b; i &lt;= b + c + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dif[i] += dif[i - <span class="number">1</span>];</span><br><span class="line">        ans += <span class="built_in">min</span>(<span class="built_in">max</span>(i - c, <span class="number">0LL</span>), d - c + <span class="number">1</span>) * dif[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>implementation</tag>
        <tag>math</tag>
        <tag>binary search</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>1366D Two Divisors</title>
    <url>/2023/05/17/1366D/</url>
    <content><![CDATA[<h1 id="Two-Divisors"><a href="#Two-Divisors" class="headerlink" title="Two Divisors"></a>Two Divisors</h1><p>Created by LXC on Thu May 11 10:54:58 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1366/D">https://codeforces.com/problemset/problem/1366/D</a></p>
<p>ranting: 2000</p>
<p>tag: constructive algorithms, math, number theory</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出n个数，求每个数x能否找到两个都大于1的因子d1和d2，使得gcd(d1+d2, x) = 1<br>如果不能则输出-1,-1.</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果x的质因子分解后不同质因子的个数只有1个。<br>那么没有答案</p>
<p>否则设不同质因子分别为$p_1, p_2, \cdots, p_k$，我们将其分为两个集合$p_1,p_2,\cdots, p_i$和$p_{i+1}, p_{i+2}, \cdots, p_k$。</p>
<p>我们发现$x$中的每个因子$p_i$只能整除$\prod \limits_{j=1}^{i} p_j $和$ \prod \limits_{j=i+1}^{k} p_j$其中一个，所以$\prod \limits_{j=1}^{i} p_j + \prod \limits_{j=i+1}^{k} p_j$和$x$的最大公因数为1.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10000005</span></span><br><span class="line"><span class="comment">// #define N 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="type">int</span> lpf[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lpf[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lpf[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            lpf[i] = i;</span><br><span class="line">            p.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; p[j] * i &lt; N; j++) &#123;</span><br><span class="line">            lpf[p[j] * i] = p[j];</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i : p) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt; N; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; lpf[i] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">b</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; fac;</span><br><span class="line">        <span class="keyword">while</span> (lpf[x] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fac.<span class="built_in">empty</span>() || fac.<span class="built_in">back</span>() != lpf[x])</span><br><span class="line">                fac.<span class="built_in">push_back</span>(lpf[x]);</span><br><span class="line">            x /= lpf[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mult = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : fac) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; j &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            mult *= j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="keyword">if</span> (fac.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            a[i] = fac[<span class="number">0</span>];</span><br><span class="line">            b[i] = mult / fac[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TLE O(n sqrt(n))</span></span><br><span class="line"><span class="comment">void sol() &#123;</span></span><br><span class="line"><span class="comment">    int n;</span></span><br><span class="line"><span class="comment">    cin &gt;&gt; n;</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; a(n, -1), b(n, -1);</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">        int x;</span></span><br><span class="line"><span class="comment">        cin &gt;&gt; x;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; fac;</span></span><br><span class="line"><span class="comment">        for (int j = 2; j * j &lt;= x; j++) &#123;</span></span><br><span class="line"><span class="comment">            if (x % j)</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            fac.push_back(j);</span></span><br><span class="line"><span class="comment">            while (x % j == 0)</span></span><br><span class="line"><span class="comment">                x /= j;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (x != 1) &#123;</span></span><br><span class="line"><span class="comment">            fac.push_back(x);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int mult = 1;</span></span><br><span class="line"><span class="comment">        for (int j : fac) &#123;</span></span><br><span class="line"><span class="comment">            // cout &lt;&lt; j &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">            mult *= j;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">        if (fac.size() &gt; 1) &#123;</span></span><br><span class="line"><span class="comment">            a[i] = fac[0];</span></span><br><span class="line"><span class="comment">            b[i] = mult / fac[0];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span>();</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
        <tag>number theory</tag>
        <tag>constructive algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>1392D Omkar and Bed Wars</title>
    <url>/2023/05/17/1392D/</url>
    <content><![CDATA[<h1 id="Omkar-and-Bed-Wars"><a href="#Omkar-and-Bed-Wars" class="headerlink" title="Omkar and Bed Wars"></a>Omkar and Bed Wars</h1><p>Created by LXC on Fri May  5 13:38:57 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1392/D">https://codeforces.com/problemset/problem/1392/D</a></p>
<p>ranting: 1700</p>
<p>tag: dp, greedy</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出n个人排列成环</p>
<p>每个人可以攻击相邻左边或者右边的人。</p>
<p>攻击的游戏规则是如果一个人只被一个人攻击那么，就需要反击。<br>否则任意攻击相邻的人之一。</p>
<p>现在给出这n个人的攻击方向（左或者右），你可以说服任何人改变攻击方向，问最少需要说服多少人使得攻击满足游戏规则。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果用动态规划状态复杂。</p>
<p>考虑贪心。我们需要找出一些性质。</p>
<p>观察后发现不能有连续三个人的攻击方向一致</p>
<p>因此统计每个攻击方向一致的连续段$s_i$，答案便为$\sum \lfloor \frac{s_i}{3} \rfloor$</p>
<p>注意如果所有人的攻击方向一致，那么答案特殊情况$\lceil \frac{n}{3} \rceil$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> cr = <span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cr == <span class="number">0</span> || cr == n) &#123;</span><br><span class="line">        cout &lt;&lt; (n + <span class="number">2</span>) / <span class="number">3</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (s.<span class="built_in">size</span>() &amp;&amp; s.<span class="built_in">back</span>() == s[<span class="number">0</span>])</span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">        s = <span class="built_in">string</span>(n - s.<span class="built_in">size</span>(), s[<span class="number">0</span>]) + s;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[p]) &#123;</span><br><span class="line">                ans += (i - p) / <span class="number">3</span>;</span><br><span class="line">                p = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (n - p) / <span class="number">3</span>;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>dp</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>1395C Boboniu and Bit Operations</title>
    <url>/2023/05/17/1395C/</url>
    <content><![CDATA[<h1 id="Boboniu-and-Bit-Operations"><a href="#Boboniu-and-Bit-Operations" class="headerlink" title="Boboniu and Bit Operations"></a>Boboniu and Bit Operations</h1><p>Created by LXC on Tue May  2 01:22:09 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1395/C">https://codeforces.com/problemset/problem/1395/C</a></p>
<p>ranting: 1600</p>
<p>tag: bitmasks, brute force, dp, greedy</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出长度为n的数组a，长度为m的数组b。（$n,m&lt;=200, 0&lt;=a_i,b_i&lt;2^9$）</p>
<p>现在对于每个$a_i$，需要从b中寻找一个数$b_j$，使得$c_i = a_i&amp;b_j$</p>
<p>我们需要求出最小的$c_1 | c_2 | \cdots | c_n$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>数据范围很小直接dp</p>
<p>设$f_{i,j}$ 为前i组数中（共有n组数，每组数中有m个数，每组数中必须且只能选一个）选出的数的<strong>或和</strong>能否是j（$j&lt;2^9$），$f_{i,j}=0/1$代表否/是。</p>
<p>显然$f_{1,a_1&amp;b_i} = 1, i \in [1,m]$</p>
<p>对于$f_{i,j}=1$，则有$f_{i+1, j|a_{i+1}&amp;b_k}, k \in [1,m]$</p>
<p>时间复杂度$O(nms)$，n为a的大小，m为b的大小，s为数组数值范围。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 605</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        f[<span class="number">1</span>][a[<span class="number">1</span>] &amp; b[j]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; k++) &#123;</span><br><span class="line">                    f[i + <span class="number">1</span>][j | a[i + <span class="number">1</span>] &amp; b[k]] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[n][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>dp</tag>
        <tag>greedy</tag>
        <tag>brute force</tag>
        <tag>bitmasks</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #684 (Div. 2)</title>
    <url>/2023/05/17/1440/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-684-Div-2"><a href="#Codeforces-Round-684-Div-2" class="headerlink" title="Codeforces Round #684 (Div. 2)"></a>Codeforces Round #684 (Div. 2)</h1><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>bug: 一个bug，当时程序非正常退出，应该是数组越界。像打印些东西来定位到bug。但是死活不输出。<br>到后面突然想起cout没有endl。这样在输出的内容会留在缓冲区。非正常退出没有将缓冲区的内容输出。<br>endl用于将缓冲区内容输出。</p>
<p>bug：在解决四个方块都是1的情况时，调用三个方块是1和一个方块是1的方法。 错误。 三个方块是1需要先找到0的位置。四个方块是1没有0</p>
<p>对于解决2 * 2的方块只需要最多4步。<br>那么如果n 和 m都是偶数，最多只需要n * m / 4 * 4 = m * n 步</p>
<ul>
<li>如果n 是奇数 m 是 偶数 处理最后一行只需要 m/2次操作 总共需要 <code>(n-1)*m+m/2 = m*n - m/2 &lt;= m*n</code></li>
<li>如果n 是偶数 m 是 奇数 处理最后一列只需要 n/2次操作 总共需要 <code>n*(m-1)+n/2 = m*n - n/2 &lt;= m*n</code></li>
<li>如果n 是奇数 m 是 奇数 处理最后一列只需要 ceil(n/2)次操作, 处理最后一行只需要 floor(m/2)次操作 总共需要 <code>(n-1)*(m-1)+ceil(n/2)+floor(m/2) = m*n - floor(n/2) - ceil(m/2) + 1 &lt;= m*n</code></li>
</ul>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1451E1 Bitwise Queries (Easy Version)</title>
    <url>/2023/06/20/1451E1/</url>
    <content><![CDATA[<h1 id="Bitwise-Queries-Easy-Version"><a href="#Bitwise-Queries-Easy-Version" class="headerlink" title="Bitwise Queries (Easy Version)"></a>Bitwise Queries (Easy Version)</h1><p>Created by LXC on Sun Jun 18 00:13:47 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1451/E1">https://codeforces.com/problemset/problem/1451/E1</a></p>
<p>ranting: 2000</p>
<p>tag: bitmasks, constructive algorithms, interactive, math</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>有一个个未知的数组大小为n。n为2的幂次。</p>
<p>数组中的值为0到n-1。</p>
<p>现在最多询问n+2次，求原来的排列。</p>
<p>每次询问可以询问任意两个数的：与值、或值、异或值。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>关键在于求出一个未知的值，当求一个出未知的值后，剩余的n-1个可以通过异或的性质得出。</p>
<p>所以有n-1次异或操作。</p>
<p>剩余的三次操作必须要得出一个未知数。</p>
<p>关键公式$a + b = a^b + 2*(a&amp;b)$。</p>
<p><del>绞劲脑汁都没有想到的一点</del></p>
<p>当有了这个公式后，任选三个不同数，询问两两之间的与值，则可以求出两两之间的和。三个未知数三个方程，显然可以求出其中一个。</p>
<p>那么n+1次操作怎么做呢？</p>
<p>这里就需要分类讨论了，当未知排列每个数都不同时，在n-1次异或中，就必定存在一个异或和为n-1。实际上它们的与值就是0。就可以少算一步。</p>
<p>对于如果未知排列存在相同的数，假设我们将第2到n个数都和第1个数求异或值。<br>如果第2个到第n个数中存在有一个数等于第1个数，那么异或值存在0。<br>如果第2个到第n个数中存在相等的数，那么异或值存在相等。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector&lt;int&gt; a = &#123;1, 2, 0, 3&#125;;</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// vector&lt;int&gt; a = &#123;1, 2, 3, 3&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getxor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;XOR &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// return a[x - 1] ^ a[y - 1];</span></span><br><span class="line">    <span class="type">int</span> rt;</span><br><span class="line">    cin &gt;&gt; rt;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getand</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;AND &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// return a[x - 1] &amp; a[y - 1];</span></span><br><span class="line">    <span class="type">int</span> rt;</span><br><span class="line">    cin &gt;&gt; rt;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> xora1[(<span class="number">1</span> &lt;&lt; <span class="number">16</span>) + <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> cnt[(<span class="number">1</span> &lt;&lt; <span class="number">16</span>) + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> z = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        xora1[i] = <span class="built_in">getxor</span>(<span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">if</span> (xora1[i] == <span class="number">0</span>)</span><br><span class="line">            z = i;</span><br><span class="line">        cnt[xora1[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            p = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (z != <span class="number">-1</span>) &#123;  <span class="comment">// 存在0，a1 与 az 相等</span></span><br><span class="line">        ans[<span class="number">1</span>] = <span class="built_in">getand</span>(<span class="number">1</span>, z);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="number">-1</span>) &#123;  <span class="comment">// a2...an中有相等</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xora1[i] == p)</span><br><span class="line">                x.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">getand</span>(x[<span class="number">0</span>], x[<span class="number">1</span>]);</span><br><span class="line">        ans[<span class="number">1</span>] = r ^ xora1[x[<span class="number">0</span>]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 不存在重复的数</span></span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xora1[i] == n - <span class="number">1</span>)</span><br><span class="line">                x = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> y = (x == <span class="number">2</span> ? <span class="number">3</span> : <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> a1x = xora1[x];</span><br><span class="line">        <span class="type">int</span> a1y = xora1[y] + <span class="number">2</span> * <span class="built_in">getand</span>(<span class="number">1</span>, y);</span><br><span class="line">        <span class="type">int</span> ayx = (xora1[y] ^ xora1[x]) + <span class="number">2</span> * <span class="built_in">getand</span>(y, x);</span><br><span class="line">        ans[<span class="number">1</span>] = (a1x - ayx + a1y) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans[i] = ans[<span class="number">1</span>] ^ xora1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
        <tag>constructive algorithms</tag>
        <tag>bitmasks</tag>
        <tag>interactive</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #687 (Div. 2, based on Technocup 2021 Elimination Round 2)</title>
    <url>/2023/05/17/1457/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-687-Div-2-based-on-Technocup-2021-Elimination-Round-2"><a href="#Codeforces-Round-687-Div-2-based-on-Technocup-2021-Elimination-Round-2" class="headerlink" title="Codeforces Round #687 (Div. 2, based on Technocup 2021 Elimination Round 2)"></a>Codeforces Round #687 (Div. 2, based on Technocup 2021 Elimination Round 2)</h1><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>求矩阵中到达目标点的最远曼哈顿距离。就是四个角顶点到目标的距离取最大值。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>将所有元素染成同一种色。 每次最多选择连续k个元素。 问最少多少次可以染色完成。<br>首先确定一种颜色，在数组中遇到这种颜色就跳过，若不是这种颜色就以当前为起点连续k个染色。<br>关键在于选哪种颜色作为最终颜色。<br>实际上，颜色的总种类数不超过一百。<br>所以枚举每种颜色作为最终颜色。 看维护最小的操作次数。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>犯了个错误。那就是删除板子是可以删到只剩k个的。<br>正解应该是：<br>求间隔为k的后缀1的个数cnt，后缀0或1的个数need。<br>在<code>[p, n]</code>之间的元素i，维护最小的<code>(i-p)*x+need[i]-cnt[i]</code></p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>生成每个数的二进制最高位位置的数组。<br>如果有连续三个二进制高位相同，那么后两个异或必定消除了高位。那么后两个的异或和小于第一个。这样就破坏了非降序。所需要的次数是1.</p>
<p>如果没有连续三个高位相同。由于每个数的取值范围在1到1e9，32位的二进制高位能取值的就0到30左右。 然后数组是非降序的。只能连续2个相同。所以数组的大小就在60左右。<br>接下来就枚举两个相邻的区间，前一个区间的异或和大于后一个区间的异或和那么就破坏了非降序。 统计并维护最小操作次数。</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1470B Strange Definition</title>
    <url>/2023/05/17/1470B/</url>
    <content><![CDATA[<h1 id="Strange-Definition"><a href="#Strange-Definition" class="headerlink" title="Strange Definition"></a>Strange Definition</h1><p>Created by LXC on Wed May 17 09:09:21 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1470/B">https://codeforces.com/problemset/problem/1470/B</a></p>
<p>ranting: 1900</p>
<p>tag: bitmasks, graphs, hashing, math, number theory</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义两个数x和y相邻，则满足lcm(x,y)/gcd(x,y)是一个平方数。</p>
<p>现在给出一个数组a</p>
<p>定义$d_i$为$a_i$的相邻的个数。而所有$d_i$中的最大值是数组的美丽值。</p>
<p>每一秒钟，每个元素$a_i$会变为所有与$a_i$相邻的数（包含自身）的乘积。</p>
<p>现在有q次查询，每次查询都要求第i秒时的美丽值。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据唯一分解定理，每个正整数都可以分解为质数的乘积。设$p_i$是第$i$个质数。<br>设$x = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_n^{\alpha_n}, y = p_1^{\beta_1}p_2^{\beta_2}\cdots p_n^{\beta_n},$</p>
<p>$lcm(x,y) = p_1^{max(\alpha_1, \beta_1)}p_2^{max(\alpha_2, \beta_2)}\cdots p_n^{max(\alpha_n, \beta_n)}$</p>
<p>$gcd(x,y) = p_1^{min(\alpha_1, \beta_1)}p_2^{min(\alpha_2, \beta_2)}\cdots p_n^{min(\alpha_n, \beta_n)}$</p>
<p>$lcm(x,y)/gcd(x,y) = p_1^{max(\alpha_1, \beta_1)-min(\alpha_1, \beta_1)}p_2^{max(\alpha_2, \beta_2)-min(\alpha_2, \beta_2)}\cdots p_n^{max(\alpha_n, \beta_n)-min(\alpha_n, \beta_n)} = p_1^{|\alpha_1-\beta_1|}p_2^{|\alpha_2-\beta_2|}\cdots p_n^{|\alpha_n-\beta_n|}$</p>
<p>如果$lcm(x,y)/gcd(x,y)$是平方数，则说明x和y对应质因子指数奇偶性相同。即$\alpha_i \equiv \beta_i \pmod 2$</p>
<p>那么我们可以对a数组进行处理，得到数组b。</p>
<p>对于每个$a_i$分解质因数。当同一个质因数出现偶数次则不计入，若$a_i = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_n^{\alpha_n}$则$b_i = p_1^{\alpha_1\mod 2}p_2^{\alpha_2\mod 2}\cdots p_n^{\alpha_n\mod 2}$。</p>
<p>在0秒的时候，b数组中每个数出现的次数其实就是这个数的相邻的个数。所以b中最大的重复值个数就是0秒时的答案。</p>
<p>那么在非0秒时，b中重复个数为非1的奇数，它们各自相邻的个数不会变化。所以统计重复个数为非1的奇数的最大值mx。对于出现次数为偶数可以全部变为1。所有偶数和1的个数之和与mx的最大值就是答案。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define LOCAL</span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="type">int</span> lpf[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lpf[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lpf[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            lpf[i] = i;</span><br><span class="line">            p.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; p[j] * i &lt; N; j++) &#123;</span><br><span class="line">            lpf[p[j] * i] = p[j];</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i : p) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt; N; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; lpf[i] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> fac = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lpf[x] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fac % lpf[x])</span><br><span class="line">                fac *= lpf[x];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fac /= lpf[x];</span><br><span class="line">            x /= lpf[x];</span><br><span class="line">        &#125;</span><br><span class="line">        mp[fac]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans0 = <span class="number">0</span>, ans1 = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : mp) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot;--&quot; &lt;&lt; j &lt;&lt; &quot;, &quot;;</span></span><br><span class="line">        ans0 = <span class="built_in">max</span>(ans0, j);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> || j % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            ans1 += j;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mx = <span class="built_in">max</span>(mx, j);</span><br><span class="line">    &#125;</span><br><span class="line">    ans1 = <span class="built_in">max</span>(ans1, mx);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll w;</span><br><span class="line">        cin &gt;&gt; w;</span><br><span class="line">        cout &lt;&lt; (w ? ans1 : ans0) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; fixed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Execution time: &quot;</span></span><br><span class="line">         &lt;&lt; (end_time - start_time) * (<span class="type">int</span>)<span class="number">1e3</span> / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
        <tag>number theory</tag>
        <tag>bitmasks</tag>
        <tag>graphs</tag>
        <tag>hashing</tag>
      </tags>
  </entry>
  <entry>
    <title>1475G Strange Beauty</title>
    <url>/2023/05/28/1475G/</url>
    <content><![CDATA[<h1 id="Strange-Beauty"><a href="#Strange-Beauty" class="headerlink" title="Strange Beauty"></a>Strange Beauty</h1><p>Created by LXC on Thu May 25 00:38:03 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1475/G">https://codeforces.com/problemset/problem/1475/G</a></p>
<p>ranting: 1900</p>
<p>tag: dp, math, number theory, sortings</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>给出n个数的数组，求删除最少的数，使得任意两个数能够形成倍数关系。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>数据范围在1到n，可以考虑值域作为状态的参数。</p>
<p>$f_{x}$为不超过x的数中，能形成任意两个数都成倍数的最大个数。</p>
<p>$f_{x} = cnt_x + \sum \limits_{x \bmod i = 0} f_{i}$，其中$cnt_x$为x出现的次数。</p>
<p>预处理出1到n每个数的所有因子，时间复杂度O(nlogn)</p>
<p>找出最大状态值，便得到了最小需要删除的个数，$n-\max \limits_{i=1}^n f_i$</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">c</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i, c[i]++;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    a.<span class="built_in">erase</span>(<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="type">int</span> ans = f[<span class="number">1</span>] = c[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : g[i])</span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i], c[i] + f[j]), ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n - ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt; N; j += i) &#123;</span><br><span class="line">            g[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>dp</tag>
        <tag>math</tag>
        <tag>number theory</tag>
        <tag>sortings</tag>
      </tags>
  </entry>
  <entry>
    <title>149D Coloring Brackets</title>
    <url>/2023/05/28/149D/</url>
    <content><![CDATA[<h1 id="Coloring-Brackets"><a href="#Coloring-Brackets" class="headerlink" title="Coloring Brackets"></a>Coloring Brackets</h1><p>Created by LXC on Wed May 24 15:36:27 2023</p>
<p><a href="https://codeforces.com/problemset/problem/149/D">https://codeforces.com/problemset/problem/149/D</a></p>
<p>ranting: 1900</p>
<p>tag: dp</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>给出一个合法括号序列（每个左括号都有对应的右括号）<br>现在你需要给这个括号序列涂上颜色。</p>
<p>涂色的规则:</p>
<ul>
<li>一对对应的括号只能涂其中一个括号</li>
<li>任意相邻的两个有颜色的括号颜色不能相同</li>
<li>涂的颜色只有两种，红色或蓝色</li>
</ul>
<p>求合法涂色的方案数。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>区间dp</p>
<p>任意两个端点形成的区间<code>[l,r]</code>能有多少种涂色方案?</p>
<p>需要考虑这个区间<code>[l,r]</code>的两个端点是否是一对对应的括号。<br>如果是则考虑子问题<code>[l+1, r-1]</code>；如果不是则考虑子问题<code>[l, ne[l]]</code>和<code>[ne[l]+1, r]</code>，这里<code>ne[l]</code>代表<code>l</code>对应的右端点。</p>
<p>对于区间端点是成对的括号，这一对括号涂色的方案就只有4种，<code>(0,1),(0,2),(1,0),(2,0)</code>，其中0代表不涂色，1代表涂红色，2代表涂蓝色。</p>
<p>如果不是成对的括号涂色的方案9种情况都有可能，我们需要递归到子问题进行判断。</p>
<p>我们定义$f_{l,r,cl,cr}$为区间l到r，其中l涂色为cl，r涂色为cr的合法方案数。</p>
<p>对于$f_{l,r,cl,cr}$：</p>
<ul>
<li>l和r是一对对应括号<ul>
<li>cl和cr是同一种颜色则$f_{l,r,cl,cr} = 0$</li>
<li>cl和cr非同一种颜色则$f_{l,r,cl,cr} = \sum \limits_{x,y\in {1,2,3},cl和x不同色,y和cr不同色} f_{l,r,x,y}$，且满足cl和x不同色，cy和y不同色。</li>
</ul>
</li>
<li>l和r不是一对对应括号，则拆分出第一对括号的状态$f_{l,ne_l, cl, x}$和$f_{ne_l+1,r, y, cr}$，$f_{l,r,cl,cr} = \sum \limits_{x,y\in {1,2,3},x和y不同色} f_{l,ne_l,cl,x}\times f_{ne_l+1, r, y, cr}$，为了满足相邻涂色的括号颜色不同，x和y除了都是0之外不能相等。</li>
</ul>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 705</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll f[N][N][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dir = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ne</span><span class="params">(n, <span class="number">-1</span>)</span>, st</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            ne[st.<span class="built_in">back</span>()] = i;</span><br><span class="line">            st.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            st.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i : ne) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    function&lt;ll(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> cl, <span class="type">int</span> cr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[l][r][cl][cr] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> f[l][r][cl][cr];</span><br><span class="line">        &#125;</span><br><span class="line">        ll rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ne[l] == r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cl == cr || cl &amp;&amp; cr) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; cl &lt;&lt; &quot; &quot; &lt;&lt; cr &lt;&lt; &quot; \n&quot;;</span></span><br><span class="line">                <span class="keyword">return</span> f[l][r][cl][cr] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; cl &lt;&lt; &quot; &quot; &lt;&lt; cr &lt;&lt; &quot; 1\n&quot;;</span></span><br><span class="line">                <span class="keyword">return</span> f[l][r][cl][cr] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == cl &amp;&amp; x)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (y == cr &amp;&amp; y)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; cl &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; cr &lt;&lt; endl;</span></span><br><span class="line">                    rt += <span class="built_in">dfs</span>(l + <span class="number">1</span>, r - <span class="number">1</span>, x, y);</span><br><span class="line">                    rt %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == y &amp;&amp; x)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    rt += <span class="built_in">dfs</span>(l, ne[l], cl, x) * <span class="built_in">dfs</span>(ne[l] + <span class="number">1</span>, r, y, cr) % MOD;</span><br><span class="line">                    rt %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; cl &lt;&lt; &quot; &quot; &lt;&lt; cr &lt;&lt; &quot; &quot; &lt;&lt; rt &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="keyword">return</span> f[l][r][cl][cr] = rt;</span><br><span class="line">    &#125;;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++) &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(<span class="number">0</span>, n - <span class="number">1</span>, x, y);</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>1558C Bottom-Tier Reversals</title>
    <url>/2023/06/06/1558C/</url>
    <content><![CDATA[<h1 id="Bottom-Tier-Reversals"><a href="#Bottom-Tier-Reversals" class="headerlink" title="Bottom-Tier Reversals"></a>Bottom-Tier Reversals</h1><p>Created by LXC on Mon Jun  5 00:02:16 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1558/C">https://codeforces.com/problemset/problem/1558/C</a></p>
<p>ranting: 2000</p>
<p>tag: constructive algorithms, greedy</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>有一个长度为n的排列，n为奇数。现在每次只能将一个奇数前缀反转前缀。问能否在5n/2次反转前缀操作内将排列变为有序。</p>
<p>不能则输出-1</p>
<p>能则输出操作序列。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>由于每次只能操纵前缀。所以先从后缀开始构造。</p>
<p>我们需要找到一个原操作，可以在确定上界的步数内将固定数量的后缀排好序。然后将继续解决规模减小的子问题。</p>
<p>这个原操作不出意外应该是五步内排好2个后缀。</p>
<p>假设当前需要排好的两个后缀是p-1和p。它们在排列中的位置分别是s和e。</p>
<p>那么如果s和e的不相邻.我们可以在两步内让它们相邻：先反转前缀e，使得p在第一位，然后反转前缀s-1，使得p在p-1前面且相邻，即e+1=s。</p>
<p>对于e+1 = s，我们只需反转前缀s+1，便可让p-1在p前面且相邻，即s+1=e.</p>
<p>对于s+1 = e，我们只需反转前缀s，便可让p排在第一位，p-1排在第二位。</p>
<p>最后反转前缀p，既可以排好两个位置p-1和p。</p>
<p>这个过程中最多只需要反转5次。</p>
<p>每次给两个位置p-1和p排序前需要知道它们的位置，所需时间复杂度$O(n)$</p>
<p>总时间复杂度$O(n^2)$</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] % <span class="number">2</span> == i % <span class="number">2</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">auto</span> se = [&amp;](<span class="type">int</span> x) -&gt; pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">find</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x - <span class="number">1</span>) - a.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> e = <span class="built_in">find</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x) - a.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> &#123;s + <span class="number">1</span>, e + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> rvs = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + x);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> p = n;</span><br><span class="line">    <span class="built_in">se</span>(p);</span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [s, e] = <span class="built_in">se</span>(p);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; e &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">        <span class="keyword">if</span> (s == p - <span class="number">1</span> &amp;&amp; e == p) &#123;</span><br><span class="line">            p -= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">2</span> &amp;&amp; e == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">rvs</span>(p);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s + <span class="number">1</span> == e) &#123;</span><br><span class="line">            <span class="built_in">rvs</span>(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e + <span class="number">1</span> == s) &#123;</span><br><span class="line">            <span class="built_in">rvs</span>(s + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">rvs</span>(s - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">rvs</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : ans) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>greedy</tag>
        <tag>constructive algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>1562D1 Two Hundred Twenty One (easy version)</title>
    <url>/2023/05/17/1562D1/</url>
    <content><![CDATA[<h1 id="Two-Hundred-Twenty-One-easy-version"><a href="#Two-Hundred-Twenty-One-easy-version" class="headerlink" title="Two Hundred Twenty One (easy version)"></a>Two Hundred Twenty One (easy version)</h1><p>Created by LXC on Fri May 12 13:03:52 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1562/D1">https://codeforces.com/problemset/problem/1562/D1</a></p>
<p>ranting: 1700</p>
<p>tag: data structures, dp, math</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出n个数的数组a，每个元素非-1即1。</p>
<p>设 $f(a) = a_1 - a_2 + a_3 - a_4 + …$</p>
<p>现有q个查询，每次查询子数组<code>a[l,r]</code>中删除最少数量的元素，使得剩余数字组成的数组b其$f(b) = 0$。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑每个$a_i$被删除后剩余的数组成的数组$b_i$，其$f(b_i)$</p>
<p>观察到$|f(b_i)-f(b_{i+1})| = 2 或 1$</p>
<p>当n是奇数时所有$f(b_i)$是偶数。$b_1 = -f(a) \pm 1$而$b_n = f(a) \pm 1$，因此$b_1$和$b_n$不同符号，或者为0，而相邻$f(b_i)$相差为0或2。所以必定存在$f(b_i) = 0, i \in [1,n]$，所以答案只需删除一个。</p>
<p>当n为偶数时，可以删掉一个变为奇数。所以答案是删除两个。</p>
<p>特殊情况$f(a) = 0$就不需要删除。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">            p[i] = p[i - <span class="number">1</span>] + (s[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[i] = p[i - <span class="number">1</span>] - (s[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (p[y] - p[x - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; ((y - x + <span class="number">1</span>) % <span class="number">2</span> ? <span class="number">1</span> : <span class="number">2</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>data structures</tag>
        <tag>dp</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>1593D2 Half of Same</title>
    <url>/2023/05/20/1593D2/</url>
    <content><![CDATA[<h1 id="Half-of-Same"><a href="#Half-of-Same" class="headerlink" title="Half of Same"></a>Half of Same</h1><p>Created by LXC on Fri May 19 00:02:17 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1593/D2">https://codeforces.com/problemset/problem/1593/D2</a></p>
<p>ranting: 1900</p>
<p>tag: brute force, math, number theory</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出n个数的数组a（$n\le40,-10^6\le a_i\le 10^6$）。</p>
<p>求一个大于0的整数k使得，让a中每个数增加或减少若干次k后，至少有一半的元素相等。如果这个k可以是无穷大，则输出-1</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然如果本身就有至少一半的元素相等，则输出-1.</p>
<p>否则如果能使得$a_i$和$a_j$相等，<br>则有$a_i = t_1k+b, a_j = t_2k+b$，$a_i-a_j$是k的倍数。</p>
<p>我们可以花$O(n^2\sqrt C)$时间求出任意两个数的差值绝对值的因子,$C = max(a_i)-min(a_i)$。</p>
<p>我们由大到小枚举这些因子。对于每个因子p，我们尝试将所有其他元素变为$a_i$，看由多少个差值是p的倍数。如果大于一半的元素那么p就是答案</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ti[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, (<span class="type">int</span>)<span class="built_in">count</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mx &gt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sz = <span class="built_in">max</span>(*<span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()),</span><br><span class="line">                 <span class="built_in">abs</span>(*<span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>())));</span><br><span class="line">    set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y : a) &#123;</span><br><span class="line">            <span class="type">int</span> dif = <span class="built_in">abs</span>(y - x);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= dif; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dif % i == <span class="number">0</span>)</span><br><span class="line">                    st.<span class="built_in">insert</span>(i), st.<span class="built_in">insert</span>(dif / i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : st) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : a) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y : a) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(y - x) % i == <span class="number">0</span>)</span><br><span class="line">                    cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
        <tag>number theory</tag>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>160C Find Pair</title>
    <url>/2023/06/15/160C/</url>
    <content><![CDATA[<h1 id="Find-Pair"><a href="#Find-Pair" class="headerlink" title="Find Pair"></a>Find Pair</h1><p>Created by LXC on Thu Jun 15 11:01:08 2023</p>
<p><a href="https://codeforces.com/problemset/problem/160/C">https://codeforces.com/problemset/problem/160/C</a></p>
<p>ranting: 1700</p>
<p>tag: implementation, math, sortings</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>给出n个数，求这n个数的任意两个的组合的数对中第k小的一对。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>n个数的索引从0到n-1，我们将k-=1.</p>
<p>n个数完全不同则可以用<code>(a[k/n],a[k%n])</code>作为答案。</p>
<p>但是n个数会有重复，可以确定的是数对的第一个数是<code>a[k/n]</code>，我们找出第一个数比<code>a[k/n]</code>小的数对的个数，在用k减去它，得到以<code>a[k/n]</code>作为第一个数的数对个数m。<code>a[k/n]</code>在n个数中出现了c次，那么答案就是<code>(a[k/n], a[m/c])</code></p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    k--;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    map&lt;ll, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i, mp[i]++;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    ll s = k / n, e = s;</span><br><span class="line">    <span class="keyword">while</span> (s != <span class="number">-1</span> &amp;&amp; a[s] == a[e])</span><br><span class="line">        s--;</span><br><span class="line">    ll m = k - (s + <span class="number">1</span>) * n;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; mp[a[e]] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    cout &lt;&lt; a[k / n] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[m / mp[a[e]]] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>implementation</tag>
        <tag>math</tag>
        <tag>sortings</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello 2022 (1621)</title>
    <url>/2023/05/17/1621/</url>
    <content><![CDATA[<h1 id="Hello-2022-1621"><a href="#Hello-2022-1621" class="headerlink" title="Hello 2022 (1621)"></a>Hello 2022 (1621)</h1><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>设左上角方块编号为1，右上角方块编号为2，左下角方块编号为3， 右下角方块编号为4.<br>在左上角方块充满了人，需要全部移动到右下角方块中，移动是整行或整列轮转。中间有障碍(不会随着轮转而移动)，轮转后人不能碰到障碍。<br>所以需要先去除障碍。去除每个障碍的费用都给出了。</p>
<p>很明显4号方块的障碍全部要清除。<br>然后我认为人应该从2号或3号方块中选出一条代价最小的路径。然后不知怎么做。<br>事实上如果真存在这样一条路径，要把所有人从左上角移动到右下角这些人一定会经过3号或4号的四个角中某一个。</p>
<blockquote>
<p>可以试想在2号方块的左边界存在路径的入口，这个入口不在2号方块的左上角或左下角，而是在左边界的中部，<br>对于1号方块右边界的人需要上下移动才能进入入口，而上下移动，就会有人进入3号方块的右下角或右上角。<br>那么现在确定一定会经过3号或4号的某个角。但由于可以轮转移动，这四个角其实就打通了1号到4号的路径。<br>所以答案就是八个角中值最小的＋4号方块中所有障碍。</p>
</blockquote>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #766 (Div. 2)</title>
    <url>/2023/05/17/1627/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-766-Div-2"><a href="#Codeforces-Round-766-Div-2" class="headerlink" title="Codeforces Round #766 (Div. 2)"></a>Codeforces Round #766 (Div. 2)</h1><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>给出一个数组，任选两个数a,b, 若gcd(a,b)不在数组中则删除a,b将gcd(a,b)加入数组。<br>问这样操作的次数最多是多少。</p>
<p>gcd(a, b) &lt;= min(a, b)<br>所以可以枚举比数组中最大的数小的数。 如果当前枚举的数是x，看x否是由数组中的数求gcd得到。如果能那么操作的次数+1.<br>如果x是由数组中数求gcd得到，那么x的倍数将会在数组中出现，但是在数组中的x倍数求gcd不一定是x。比如2的倍数 4，8.<br>所以数组中x的倍数的gcd等于x，操作次数才+1<br>由于gcd(0, a) = a, 若数组中刚好有x，x将会算入操作数。<br>所以最后的操作数要减去数组元素个数n。</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #767 (Div. 2)</title>
    <url>/2023/05/17/1629/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-767-Div-2"><a href="#Codeforces-Round-767-Div-2" class="headerlink" title="Codeforces Round #767 (Div. 2)"></a>Codeforces Round #767 (Div. 2)</h1><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>由于每个字符串长度最多为3<br>显然只需要找出一对能组成回文串就行。如果有超过2个串连接成的回文串。只需要首尾两个就行。 例如：abc 与 cba ba， ab与ba。<br>如果本身是个回文串那也是可以的。</p>
<p>解决这个问题只需要遍历时维护hash表即可，对于当前串x：<br>先判断x是否为回文串。<br>若x不为回文串，x的每个字符都不同。<br>在将x反转成y，hash表中找y是否存在，如果y的长度是3，还要找y的前俩个字符组成的子串。 对于一个字符的子串不用找，因为它本身就是回文串。</p>
<p>另外如果当前x长度为3，在其后有长度为2的串能与x组成回文串。这种情况也要考虑。 可以在输入时将反转的x入栈中，然后在弹出时重新执行以上算法。</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1637A - Sorting Parts</title>
    <url>/2023/05/17/1637/</url>
    <content><![CDATA[<h1 id="1637A-Sorting-Parts"><a href="#1637A-Sorting-Parts" class="headerlink" title="1637A - Sorting Parts"></a>1637A - Sorting Parts</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组，将数组截断分别排序再拼接，问是否是能不升序，是则输出YES，否则NO</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>判断数组是否是升序的，是则经操作后任然是升序，输出NO，否则输出YES</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10004</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="type">int</span> mx = num[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num[i] &lt; mx) &#123;</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mx = <span class="built_in">max</span>(mx, num[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; (flag?<span class="string">&quot;NO&quot;</span>:<span class="string">&quot;YES&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-MEX-and-Array"><a href="#B-MEX-and-Array" class="headerlink" title="B. MEX and Array"></a>B. MEX and Array</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>可以将一个数组分割成若干个连续的子数组，数组的cost值为拆分的子数组个数+每个子数组的mex值。<br>一个数组的mex值是该数组中最小的未出现的非负数。<br>求最大的数组的所有子数组的cost值之和。</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>数组拆分的子数组大小不会影响cost值，可以拆分为长度为1的子数组<br>求每个子数组的cost是数组的区间和。<br>可求得前缀和，再枚举不同长度的子数组，每个cost只需O(1)可求得</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		<span class="keyword">if</span> (a[i] == <span class="number">0</span>) a[i] = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> a[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		a[i] += a[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j+i&lt;=n; j++) &#123;</span><br><span class="line">			ans += a[j+i]-a[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="C-Andrew-and-Stones"><a href="#C-Andrew-and-Stones" class="headerlink" title="C. Andrew and Stones"></a>C. Andrew and Stones</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给一个数组，每次可以从数组中选三个元素，让中间的元素-2，两边的元素分别+1<br>问是否能让数组所有数都移动到首尾部，如果能输出最少操作次数，不能则输出-1</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>如果有解，对于当前数$a_i, 0&lt;i&lt;n$:<br>若为奇数，必定需要被移入1个，然后对答案的贡献是$\frac{a_i+1}{2}$<br>若为偶数，必定对答案的贡献为$\frac{a_i}{2}$<br>如果无解，对于非首尾元素：奇数元素只有一个，或者全部为1</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">allone</span>() || n==<span class="number">3</span> &amp;&amp; a[<span class="number">1</span>]%<span class="number">2</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">		ans += a[i]/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[i]%<span class="number">2</span>) ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1644E Expand the Path</title>
    <url>/2023/06/13/1644E/</url>
    <content><![CDATA[<h1 id="Expand-the-Path"><a href="#Expand-the-Path" class="headerlink" title="Expand the Path"></a>Expand the Path</h1><p>Created by LXC on Mon Jun 12 14:33:31 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1644/E">https://codeforces.com/problemset/problem/1644/E</a></p>
<p>ranting: 1900</p>
<p>tag: brute force, combinatorics, data structures, implementation, math</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>有一个 n * n 的网格，现在你在网格中(1,1)位置。<br>给你一个只包含<code>D</code>和<code>R</code>字符串，代表着移动的序列。<code>D</code>则向下移动，即(x,y)位置变为(x+1,y)；<code>R</code>则向右移动，即(x,y)位置变为(x,y+1)；</p>
<p>现在你可以执行任意次操作，每次操作让移动序列中某个单次移动变为连续两次移动，比如<code>D</code>变为<code>DD</code>。并且移动完后不会越界。</p>
<p>问在所有通过操作后的合法序列中，能够经过的点有哪些。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>在第一次转向之前如果走了k步，会有k*(n-1)格无法到达，显然当序列中只有一种字符那么就只有n格能到达。</p>
<p>其余的格子几乎都能到达。</p>
<p>设在第一次转向前如果到达的位置是(x1,y1)，最后结束的位置是(x2,y2)。</p>
<p>那么再以对角线(x1,y1)(x2,y2)的矩形中只有(x2-x1+y2-y1+1)个格子是能到达的</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27;R&#x27;</span>) || !<span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27;D&#x27;</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x1 = <span class="number">1</span>, y1 = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == s[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            y1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x1++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x2 = x1, y2 = y1, j = i;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[j] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            y2++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x2++;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (x1 + y1 - <span class="number">2</span>) + ((n - x1 + <span class="number">1</span>) * (n - y1 + <span class="number">1</span>) -</span><br><span class="line">                             ((y2 - y1 + <span class="number">1</span>) * (x2 - x1 + <span class="number">1</span>) - (j - i + <span class="number">1</span>)))</span><br><span class="line">         &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>data structures</tag>
        <tag>implementation</tag>
        <tag>math</tag>
        <tag>combinatorics</tag>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>A</title>
    <url>/2023/05/17/1646/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>有一个长度为n+1的数组，数组的值范围在0到n-1，或者是n^2。已知n，和s，s是n+1个数组的和。 求有多少个数的值是n^2</p>
<p>有<code>s/(n*n)</code>个<br>可以认为<code>s = k*n^2+u</code>, u是数组中小于n^2的数，每个数的取值最大为n-1，n+1个数最大和为<code>(n-1)*(n+1)=n^2-1</code>,所以<code>u&lt;=n^2-1</code><br><code>s/(n^2) = (k*n^2+u)/(n^2)=k</code></p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>将数组中的一些数染为红色，一些数染为蓝色，要求染色为红色的个数要小于蓝色的个数，红色的数值和大于蓝色的数值和。问是否存在这样的染色。</p>
<p>升序排序，用双指针l，r，染成红色的是r的后缀和，染成蓝色的是l的前缀和。前缀的个数要保持大于后缀，l指针每次后移动1，r指针每次前移动1.<br>在l=r之前存在后缀大于前缀则是YES</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>将一个数n拆分成互不相同的powerful的数之和，拆分的个数要尽可能的少，问最少能拆分多少个。 n的范围在10^6内<br>powerful数是2的幂次或者是某个数的阶乘。</p>
<p>通过打表可知小于10^6的阶乘数只有14个。<br>任何数都可以是互不相同的2的幂次之和。</p>
<p>2^14可以通过枚举阶乘数的组合，令c为当前枚举组合中阶乘数的个数，s为当前组合中阶乘数之和，若s&lt;=n，n-s的二进制1的个数+c就是当前枚举所分解powerful数的个数。<br>在每次枚举中维护最小值便是答案。</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>A</title>
    <url>/2023/05/17/1649/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>给出一个0和1的数组，第一个数和最后一个数都是1，你有一次跳跃机会，可以从i跳到i+x位置，花费x个硬币，求从第一个开始移动到最后一个不能碰到0最少花多少硬币。</p>
<p>双指针模拟，求出左边连续1的个数，求出右边连续1的个数。中间剩下的是跳跃的距离-1。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>n个人在练习传球。 给出最后每个人传出球的次数。问最少需要多少个球。</p>
<p>n个人中选出传球数最大值mx，总传球数为sm。 若剩余的传球总数数sm-mx小于mx。说明即使每个人都向传球数最多的人传球也需要多个球。需要的球数为 <code>2*mx-sm</code>， 当sm-mx大于mx时，每个人都可以向这个最多传球数的人传球。 将他的传球数耗尽。然后剩余的人中再选出传球数最多的人重复此操作。<br>只需要1个球就能传完。</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1650</title>
    <url>/2023/05/17/1650/</url>
    <content><![CDATA[<p>Codeforces Round #776 (Div. 3)<br>1650</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>给出一个奇数长度的字符串s，和一个字符c， 每次删除s的两个相邻的字符，问最后得到的字符是否等于c</p>
<p>如果s中存在字符c的左边字符是偶数个，右边字符是偶数个即可。<br>那么c出现的位置应该在s中奇数位置。c出现的次数可能不止一次。只需判断所有下标为偶数是否存在c。若存在则是YES</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>给出三个整数 l, r, a。<br>问在求最大的x/a+x%a, x 范围在l到r的闭区间。x/a为向下取整。</p>
<p>第一个比r小的a的倍数<code>t = r/a*a</code>,<br>若t&gt;l, 则可以在l到r中取到(t-1)/a+(t-1)%a 即<code>r/a*a-1+a-1</code>。<br>否则<code>r/a+r%a</code><br>但是忽略了一点。即便t&gt;l当a=2时。r/a+r%a可能更大。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>首先应该想到选取2n个最小权值的点。<br>然后按照坐标排序。然后双指针成对输出。输出的不是坐标值，而是坐标值对应在输入时的位置。所以需要把坐标映射到输入的位置。</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>逆向思维<br>在轮转前n个时把第n个的位置归位。再轮转前n-1个，把第n-1个归位。<br>n的大小不过几千。模拟完全足够。<br>这里有种省空间的方法。将所有值都减一。让值的范围变为0到n-1<br>用一个数组mp记录当前每个值的当前下标。下标在一轮轮转后，若需要归位的是i，i的当前下标<code>mp[i]</code>,下标应为i。轮转的数是0到i共i+1个。所以0到i的数应该向左偏移(mp[i]-i+i+1)%(i+1)。 然后将偏移数存入栈中。全部轮转归位后。出栈输出。<br>这里思路都有了，但是debug的时间过长。 一开始没有考虑所有值-1。 后面没有入栈出栈输出。 还一直在找别的地方的bug。</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #778 (Div. 1 + Div. 2, based on Technocup 2022 Final Round)</title>
    <url>/2023/05/17/1654/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-778-Div-1-Div-2-based-on-Technocup-2022-Final-Round"><a href="#Codeforces-Round-778-Div-1-Div-2-based-on-Technocup-2022-Final-Round" class="headerlink" title="Codeforces Round #778 (Div. 1 + Div. 2, based on Technocup 2022 Final Round)"></a>Codeforces Round #778 (Div. 1 + Div. 2, based on Technocup 2022 Final Round)</h1>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 125 (Rated for Div. 2)</title>
    <url>/2023/05/17/1657/</url>
    <content><![CDATA[<h1 id="Educational-Codeforces-Round-125-Rated-for-Div-2"><a href="#Educational-Codeforces-Round-125-Rated-for-Div-2" class="headerlink" title="Educational Codeforces Round 125 (Rated for Div. 2)"></a>Educational Codeforces Round 125 (Rated for Div. 2)</h1><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>起始时，你在下标(0,0)处，每一步你可以走到一个下标为(x,y),前提是走完后的位置与没走之前的位置的直线距离是整数。<br>给出x, y 。 问走到点(x, y)最小步数。</p>
<p>如果x=0且y=0，则答案是0.<br>如果x=0或y=0，则答案是1.<br>否则为2。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>给出四个整数 n, B, x, y. 构造一个n个数的序列a。使得序列和最大。<br>构造序列的规则如下：</p>
<ul>
<li>$a_i = a_{i-1} + x$</li>
<li>$a_i = a_{i-1} - y$</li>
<li>$a_i \le B$</li>
</ul>
<p>贪心构造即可。只要$a_{i-1}+x \le B$, 那么当前$a_i = a_{i-1}+x$, 否则$a_i = a_{i-1}-y$</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>给出一个括号字符串，每次操作可以删除一个‘好’前缀，直到没有好前缀为止。问最后操作的次数和剩余的字符个数。<br>好前缀：</p>
<ol>
<li>规则的括号：每个左括号都有对应的右括号。</li>
<li>长度至少为2的回文串。<br>实际上只要是<code>()</code>,<code>((</code>, <code>))</code> 都可以删除，一旦遇到<code>)(</code>，必须要在后面找到一个<code>)</code>形成回文串，否则就不能删除了。</li>
</ol>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #782 (Div. 2)</title>
    <url>/2023/05/17/1659/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-782-Div-2"><a href="#Codeforces-Round-782-Div-2" class="headerlink" title="Codeforces Round #782 (Div. 2)"></a>Codeforces Round #782 (Div. 2)</h1><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>红队和蓝队在打比赛，红队的胜场比蓝队多。<br>给出比赛场数n，红队胜利场数r，蓝队胜利场数b<br>请构造红蓝对决的n场比赛结果，要求红队连胜尽可能少</p>
<p>可以将红队胜场分成b+1份，然后用b场蓝队胜利分隔它们。<br>红队连胜尽量平均，可分为a%(b+1)组连胜a/(b+1)+1场，b+1-a%(b+1)组连胜a/(b+1)场。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>给出一个01串，每次操作可以选取一个位置i，除了i以外其他位置都取反。问在k次操作后最大字典序的01串是多少</p>
<p>通过观察发现<br>当k为奇数时，每次应当反转从左到右原串1出现的位置，因为0在奇数次取反后会变为1，从左到右的顺序是为了字典序最大。设原串的1出现的次数是cnt1，那么在k&gt;cnt1时，cnt1为奇数那么答案为全1，为偶数则除最后一个全1. 在k&lt; cnt1时，在第k个1的位置及之前都是1，后面的数由于奇数次取反，所以整体取反。<br>当k为偶数时，同理，每次选0的位置。 </p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>给出一个n个城的位置，这些位置是升序排序的。 每次的操作有两种：<br>征服：每次可以征服离你最近的一座未征服的城市。 需要花费a* |c1-c2|<br>迁都：每次可以迁移到任意一座你已经征服的城市。 需要花费b* |c1-c2|<br>c1是你当前的位置，初始为0，c2是目标城市位置<br>问征服所有城市的最小花费</p>
<p>实际上，当我们迁都到i城市的时候，中间无论是怎样组合的操作。到i城市花费总是pos[i]* (a+b)<br>这样可以枚举每个城市作为根据点去征服其他城市的花费。然后维护总花费最小即可，注意到当i作为根据地征服后面的城市花费若为cost，那么i-1城市征服之后的城市花费是(n-i)* (pos[i]-pos[i-1]) + cost, 这样我们可以从后向前枚举，并维护后缀和。时间复杂度O(n)</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>给出一个长度为n的01串s，若s1为给s前1个数排序后的串，s2为给s前2个数排序后的串，si为给s前i个数排序后的串<br>数组c中元素分别记录s1,s2,…,sn每个位上的和。<br>初始给出c，构造出s</p>
<p>s中每个1在si中都做出了相同贡献。那么c中元素总和/n便是s中1的个数。设1的个数为k。<br>若s的最后一个值为1则c的最后一个值必定为n，否则不为n<br>无论s最后一个数是否为0，我么可以让当前c的后k个数都减少1。 然后舍弃c最后一个元素<br>在舍弃之前c最后一个数是1，则k应当减少1.<br>这个区间减少可以用线段树维护，也可以维护一个差分数组并维护一个后缀和。</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #780 (Div. 3)</title>
    <url>/2023/05/17/1660/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-780-Div-3"><a href="#Codeforces-Round-780-Div-3" class="headerlink" title="Codeforces Round #780 (Div. 3)"></a>Codeforces Round #780 (Div. 3)</h1><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>给出a个面值为1的硬币和b个面值为2的硬币。问最小不能表示的大于0的面值。</p>
<p>如果a=0，那么为1<br>如果b=0，那么为a+1<br>否则，<code>b*2+a+1</code><br>试想如果有一个面值为1的硬币，那么面值<code>b*2</code>以内都可表示。面值<code>b*2+a</code>及以内也能表示。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>分别给出n种糖果的数量，每次吃数量最多的种类中的一个，而且每次吃的种类和上次不一样。问能否吃完。</p>
<p>如果最多的种类和次多的种类相差超过1，那么不可能吃完。 否则能吃完。<br>交替吃最多和次多种类，这样可以降低到与第三多持平，然后在这三中中交替吃。以此类推可以吃完。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>给出一个字符串，让你通过删除字符这种操作来让字符串变成‘偶数串’。<br>偶数串是长度为偶数，且奇数下标i，有$a_i = a_{i+1}$. 下标从1开始。</p>
<p>设<code>dp[i]</code>为前i个字符的子串变为偶数串需要删除的最小字符数。<br>然后用hash表记录字符a在字符串中最近出现的下标j,<br>若当前位置的下标为i，dp[i]可以由删除j+1到i-1的字符+dp[j-1]贡献；也可由删除当前字符+dp[i-1]贡献。<br><code>j = hash[s[i]]</code><br><code>dp[i] = min(dp[i-1]+1, dp[j-1]+i-j-1)</code></p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>给出n个数每个数的绝对值不超过2，通过删除一些前缀和后缀使得乘积最大。如果最后删得只剩空串，那么乘积视为1.</p>
<p>模拟。<br>以0作为分割点，将串分割，然后逐个处理这些子串。 得到子串的最大乘积，并维护所有子串的最大值。</p>
<p>遍历子串并统计负数数量。 如果负数个数是偶数，那么子串的最大乘积就是所有数的乘积；（这里需要注意一点：n的数量级是1e5。如果全部是2，那么无法用基本数据类型表示。可以记录<code>|a[i]| = 2</code>的数量。）<br>如果负数的个数是奇数，那么需要比较第一个负数之后的乘积，和最后一个负数之前的乘积谁更大。<br>当我们维护最大乘积时，也需要记录对应的左右端点，最后以便计算需要删除多少前后缀。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>给出一个<code>n*n</code>的01矩阵。每次可以轮转移动一行或一列。<br>通过任意次轮转操作后，可以使用任意次的反转操作：0变1，1变0，<br>最后要变成单位矩阵(主对角线全1其他全0)，问最少需要多少次反转操作？</p>
<p>暴力<br>由于可轮转，所以可认为矩阵有n条主对角线。 枚举这n条主对角线并统计0和1的个数，对于0我们需要反转，而对于非对角线上的1也需要反转，这样就求出每条对角线需要反转的次数了，然后维护最小即可。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>给出一个只由<code>+</code>和<code>-</code>组成的字符串。 如果加号和减号的个数相同那么称之为平衡，另外还有一种操作：两个相邻的减号可以替换成一个加号，问这个字符串有多少平衡的子串？</p>
<p>区间dp超时了。<br>直接暴力却行。<br>用双重for可以枚举每个子串，当枚举以l为左端点的串时记录加号个数a，减号个数b，’相邻的’减号个数c。<br>然后就是判断当前子串是否平衡。<br>如果我们选择用k个相邻的减号去换成加号使得加号和减号相同，就有<code>a-2*k=b+k, 0&lt;=k&lt;=c</code>。<br>变形有<code>a-b = 3*k</code>，也就是说a-b是3的倍数，且倍数不超过c就平衡。当然应该a&gt;=b。<br>然后统计合法的串的个数输出即可。</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1660F1 Promising String (easy version)</title>
    <url>/2023/05/17/1660F1/</url>
    <content><![CDATA[<h1 id="Promising-String-easy-version"><a href="#Promising-String-easy-version" class="headerlink" title="Promising String (easy version)"></a>Promising String (easy version)</h1><p>Created by LXC on Mon May  1 13:17:21 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1660/F1">https://codeforces.com/problemset/problem/1660/F1</a></p>
<p>ranting: 1700</p>
<p>tag: brute force, implementation, math, strings</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个只由<code>+</code>和<code>-</code>组成的字符串。 如果加号和减号的个数相同那么称之为平衡。</p>
<p>一次操作可以将两个相邻的减号可以替换成一个加号，问这个字符串有多少子串在经过任意次操作后可以变为平衡？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>双重for循环</p>
<p>维护区间内加号的个数a，减号的个数b。以及可以替换为加号的最多减号对数c。</p>
<p>如果经过k次操作加号和减号的个数都相同了，那么就有a+k=b-2k，即k=(b-a)/3</p>
<p>如果b-a&gt;=0 且 b-a是3的倍数则可以通过操作变为相等，但是操作的次数不能操作c，k&lt;=c。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                a++, c += t / <span class="number">2</span>, t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                b++, t++;</span><br><span class="line">            <span class="keyword">if</span> (b &gt;= a &amp;&amp; (b - a) % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; (b - a) / <span class="number">3</span> &lt;= c + t / <span class="number">2</span>)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>implementation</tag>
        <tag>math</tag>
        <tag>strings</tag>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 126 (Rated for Div. 2)</title>
    <url>/2023/05/17/1661/</url>
    <content><![CDATA[<h1 id="Educational-Codeforces-Round-126-Rated-for-Div-2"><a href="#Educational-Codeforces-Round-126-Rated-for-Div-2" class="headerlink" title="Educational Codeforces Round 126 (Rated for Div. 2)"></a>Educational Codeforces Round 126 (Rated for Div. 2)</h1><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>给出两个数组a和b<br>可以交换$a_i$与$b_i$，问$\sum \limits_{i=1}^{n-1} (|a_i-a_{i+1}|+|b_i-b){i+1}|)$的最小值是多少<br>遍历0到n-2，对于当前遍历的下标i, 若$|a_{i}-a_{i+1}|+|b_{i}-b_{i+1}|&gt;|a_{i}-b_{i+1}|+|b_{i}-a_{i+1}|$ 则交换$a_{i+1}$与$b_{i+1}$</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #784 (Div. 4)</title>
    <url>/2023/05/17/1669/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-784-Div-4"><a href="#Codeforces-Round-784-Div-4" class="headerlink" title="Codeforces Round #784 (Div. 4)"></a>Codeforces Round #784 (Div. 4)</h1><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>使用前缀和映射下标，计算后缀和与某个前缀和相等时前缀和后缀个数的最大值<br>这里前缀和过大不要用hash映射，用平衡树。</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #788 (Div. 2)</title>
    <url>/2023/05/17/1670/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-788-Div-2"><a href="#Codeforces-Round-788-Div-2" class="headerlink" title="Codeforces Round #788 (Div. 2)"></a>Codeforces Round #788 (Div. 2)</h1><p>一波回到解放前，掉了一百多分。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>选择两个符号不同的两个数交换符号，问是否能得到一个升序序列。</p>
<p>看错题了，以为是交换两个数，卡了很久，后面发觉其实很简单。 直接将符号全部移到左端。看是否升序即可。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>给出一个字符串s，和一些特殊字符，每次删除这些特殊字符左边的字符。 问最后只剩下一个特殊字符需要多少次操作。</p>
<p>我用队列做的，最后超时了，其实这也是个思维题，可以直接得出结论的。最后的答案是跟特殊字符之间的距离有关。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>给出排列a，b，求c排列，c排列的第i个数是a或b的第i个数。且已经给出部分c的排列。</p>
<p>先分别将a和b都求出值映射的下标 ma[a[i]] = i, mb[b[i]] = i.<br>已知的部分c排列，还有对应的未给出但是已经确定的值，它们在给出数形成的闭环上，可以通过深搜得到闭环。 这一步补齐了所有c中已知的数。<br>然后对于未知的排列，主要是看能求出多少个闭环。一个闭环对应两种可能，累乘即可。 求闭环可以通过并查集来做。</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #786 (Div. 3)</title>
    <url>/2023/05/17/1674/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-786-Div-3"><a href="#Codeforces-Round-786-Div-3" class="headerlink" title="Codeforces Round #786 (Div. 3)"></a>Codeforces Round #786 (Div. 3)</h1><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>给出两个整数 x 和 y, 选择两个整数a，b使得，x* b^a = y</p>
<p>若y/x 除不尽则无法找出。<br>若能除尽，构造特殊答案让b=y/x, a = 1即可</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>问在所有两个不同小写字母组成的字符串中，字符串s按字典序排第几。</p>
<p>先看首字符a1贡献at1，(a1-‘a’) * 25, 再看尾字符a2贡献at2，若a1&lt; a2, 则贡献为(a2-‘a’)-1;若a1 &gt; a2, 则贡献为(a2-‘a’);<br>答案为at1+at2+1</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>给出一个字符串s只包含小写字母a，另外给出字符串t。每次可以替换s中的某个a为t。问最后有多少中替换可能，无限则为-1.</p>
<p>看t中是否包含a。<br>若t中包含a： t的长度为1的话，只有一种可能； t的长度不为1，则每次替换s后长度变长，所以是无限种。<br>若t中不包含a：s中的每个可选择替换或不替换，总共有2^len种。len为s的长度。</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>给出一个非空数组a，空数组b，空数组c。<br>首先，每次可以将a中的最后一个字符放到b的最中间(若b的个数为奇数则可以放到中间的任意两侧)，直到a数组为空为止。<br>然后，每次可以将b中的中间字符(b为偶数则中间任意两个之一都可选)放到c的尾部，直到b为空为止。</p>
<p>问是否能让c非降序排序。</p>
<p>若n为偶数，将n个数两两连续的分成一组，最后可以分成n/2组。只要保证连续的两组之间前一组最大值小于等于后一组最小值即可。<br>若n为奇数，则在第一个数前插入0，按偶数处理。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>给出一个数组a，代表n座城池的耐久度，每次可以投掷石头，对目标造成2点伤害，此外周边两个会受到1点伤害。问攻破两座城最少要投掷多少石头？</p>
<p>对于间隔超过2座城i和j，对i投掷和对j投掷是独立的。所以一个待选答案是$min(\lfloor \frac{a[i]}{2} \rfloor , \lfloor \frac{a[j]}{2} \rfloor)$。<br>对于间隔为1座城的i和j，无论对i还是对j投掷都会稳定输出2点伤害，没有浪费。所以待选答案是$\lfloor \frac{(a[i]+a[j]+1)}{2} \rfloor$， 对于总耐久度不是2的倍数需要再投一次。<br>对于相邻的i和j，设a[i]与b[i]中最大值为x，最小值为y。<br>我们为了尽可能少投掷，就应当让伤害打满，不要浪费。 先对x投，看是否x和y最后会相等，对耐久度相等的轮流投掷x或y，这样就尽可能少的浪费伤害，进而投掷的次数也就是最少。<br>设对x投了k次后x和y相等。<br>那么有x-k* 2 = y - k<br>可知k = x-y.<br>此时x和y都变成了2* y - x.<br>若2* y - x &lt;= 0，从现实意义上想，初始时较小的耐久度不到较大的耐久度一半大。那么一直投掷较大的，待它被摧毁时较小的也跟着毁了。所以待选答案为$\lfloor \frac{x}{2} \rfloor$<br>若2* y - x &gt; 0, 则考虑轮流投掷，由于总耐久度为2 * (2 * y - x), 每次稳定打出三点伤害，摧毁需要2* (2* y-x)/3次，总共x-y + (4* y - 2 * x)/3 = (x+y)/3次。<br>需要向上取整。 $\lfloor \frac{x+y}{3} \rfloor$</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>模拟电脑桌面图标从左到右，从上到下排好，需要多少步。 有q次查询，每次每次都会添加或删除一个图标，然后问排好后需要多少步。</p>
<p>我们将屏幕看作二维数组，从上到下的一列作为二维数组中的一维数组。 然后将二维数组化为一维数组。<br>假设当前有x个图标，我们只需要知道前x个数中有多少个是空白就是要移动多少步了。 因为最后移动完成后前x个都是图标，而在移动前，前x个中已存在的图标是不用移动的。<br>每次查询时可以维护当前屏幕上有多少个图标，然后求前缀和即可，但是求q次前缀和可能复杂度过高，可以用树状数组优化。<br>也可以再维护一个变量作为前x个数中的图标个数。<br>具体的做法小复杂。注意增加或减少的位置。</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #787 (Div. 3)</title>
    <url>/2023/05/17/1675/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-787-Div-3"><a href="#Codeforces-Round-787-Div-3" class="headerlink" title="Codeforces Round #787 (Div. 3)"></a>Codeforces Round #787 (Div. 3)</h1><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>已知一个字符串s，对s操作k次，求字典序最后能得到最小字典序字符串<br>每次操作可以选则s中的一个字符a，使所有与a相同的字符都变成a-1.</p>
<p>如果我们选择一个字符cur，对其操作k次，那么所有小于cur的字符o都会变成min(o, cur-k).<br>若s中最大值的字符序为mx，且k&gt;=mx, 那么我们只需要对最大字典序的字符操作mx次就可以使得所有字符都变为’a’<br>否则，遍历字符串找到第一个字典序大于k的字符si，那么si之前的所有字符字典序都小于k，若其中最大的字典序是m，对这个字典序是m的字符操作m次那么，si之前的所有字符都会变成’a’, si之后字典序小于等于m的字符也会变成’a’.这个时候剩余的k-m次操作只有对si操作才能使得字典序最小。<br>所以si及之后小于等于si的字符la，将变为la = min(la, si-(k-m))</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #805 (Div. 3)</title>
    <url>/2023/05/17/1702/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-805-Div-3"><a href="#Codeforces-Round-805-Div-3" class="headerlink" title="Codeforces Round #805 (Div. 3)"></a>Codeforces Round #805 (Div. 3)</h1><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>给出n个多米诺骨牌，每个骨牌上有两个数字，数字的取值范围[1,n]。<br>问能否将多米诺骨牌分成两堆使得每一堆内数字都不同。</p>
<p>牌上的某个数字不会超过2. 且共有n种数字。<br>将一个牌看成一条边，那么所有牌会形成一个图，图中每个连通分量都是环，若为YES，环不能由奇数条边组成。</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>E</title>
    <url>/2023/05/17/1722/</url>
    <content><![CDATA[<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>给出n个矩形，q次询问每次询问满足长度在(hs,hb)，宽度在(ws, wb)的矩形的总面积。</p>
<p>没注意到每个测试用例有六秒时间，宽高最大1000。<br>用二维数组<code>st[x][y]</code>代表长度小于等于x，宽度小于等于y的矩形总面积。<br>只需要每个子用例需要10^6次操作预处理st。每个用例有100个子用例，所以总操作数10^8，看似超时，但是没注意时间限制为6s。</p>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>构造出n个数的非负不重复数组。使得 奇数下标的值异或和 等于 奇数下标的值异或和。</p>
<p>实际上如果构造出n个数的异或和等于0，任意取其中部分数的异或和为x，剩余数的异或和为y，则有x^y=0,所以x=y。因此可以构造出n个数异或和等于0，可以构造n-3个小于n的数，取其异或和为x，注意到n最多200000. 而2^20大于200000. 最后的三个数分别包含 2^20,2^21,2^20+2^21.可以使得最后三个数的高位异或和为0. 且最后三个数互不相同。最后三个数的低位可以是x，0，0.则使得前n-3个数与后3个数异或和相等。也就使得n个数异或和为0.<br><u>整体异或和等于0 &lt;=&gt; 一部分与另一部分异或和相等</u></p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1725C Circular Mirror</title>
    <url>/2023/05/17/1725C/</url>
    <content><![CDATA[<h1 id="Circular-Mirror"><a href="#Circular-Mirror" class="headerlink" title="Circular Mirror"></a>Circular Mirror</h1><p>Created by LXC on Mon May 15 00:17:58 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1725/C">https://codeforces.com/problemset/problem/1725/C</a></p>
<p>ranting: 2000</p>
<p>tag: binary search, combinatorics, geometry, math, two pointers</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一个圆上有n个点，现在给出相邻两个点之间的弧长。</p>
<p>然后你需要将n个点涂色，你有m种颜色可以涂。要保证形成的直角三角形的三个点不能是同一种颜色。</p>
<p>然后求涂色的可行方案数，模998244353</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据圆周角定理，圆上的三个点形成了直角三角形，那么肯定有两个点可以成为圆的直径。</p>
<p>如果直径上的点是同一种颜色，那么这种颜色就不能再用了。</p>
<p>我们先统计有多少条直径，假设有k条，那么就有n-2k个非直径上的点。</p>
<p>设当直径上的两个点颜色相同的直径条数为x条时，涂色方案数为$f_x$。</p>
<p>我们可以从k条中无顺序选出x条，共计$C_k^x$。</p>
<p>然后对这x条直径可以从m种颜色种有顺序选取x种，共计$A_m^x$</p>
<p>最后剩余m-x种颜色，剩余k-x条直径，对于剩余的直径，两个点颜色必须不相同，所以每条直径可以选的颜色有$C_{m-x}^2=(m-x)*(m-x-1)$，那么对于k-x条直径共计$(C_{m-x}^2)^{k-x}$</p>
<p>最后对于非直径上的点能用的颜色也是m-x种，所以共计$(m-x)^{n-2k}$</p>
<p>根据乘法原理，$f_x = C_{k}^{x}A_{m}^{x}(C_{m-x}^{2})^{k-x}(m-x)^{n-2k}$</p>
<p>根据加法原理，所有涂色方案数为$\sum \limits_{x=0}^{min(k,m)}f_x$</p>
<p>可以先预处理所有阶乘和阶乘逆元，计算组合数。<br>以及使用快速幂计算幂次。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 300005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll rt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            rt = rt * x % MOD;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll fac[N], inv[N];</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[n] % <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">fpow</span>(m, n) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[N - <span class="number">1</span>] = <span class="built_in">fpow</span>(fac[N - <span class="number">1</span>], MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll k = <span class="number">0</span>;</span><br><span class="line">    map&lt;ll, <span class="type">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">count</span>(a[i] - a[n] / <span class="number">2</span>)) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll x = <span class="number">0</span>; x &lt;= <span class="built_in">min</span>(m, k); x++) &#123;</span><br><span class="line">        ll r = <span class="number">1</span>;</span><br><span class="line">        r = r * fac[k] % MOD;</span><br><span class="line">        r = r * inv[k - x] % MOD;</span><br><span class="line">        r = r * inv[x] % MOD;</span><br><span class="line">        r = r * fac[m] % MOD;</span><br><span class="line">        r = r * inv[m - x] % MOD;</span><br><span class="line">        r = r * <span class="built_in">fpow</span>((m - x) * (m - x - <span class="number">1</span>) % MOD, k - x) % MOD;</span><br><span class="line">        r = r * <span class="built_in">fpow</span>(m - x, n - <span class="number">2</span> * k) % MOD;</span><br><span class="line">        ans += r;</span><br><span class="line">        ans %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
        <tag>binary search</tag>
        <tag>two pointers</tag>
        <tag>combinatorics</tag>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title>A</title>
    <url>/2023/05/17/1729/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>题目很长。 给出三个数a,b,c. 你在一楼，有两台电梯，一台在a楼，选择这台会直接从a楼到1楼;一台在b楼,选择这台会从b到c再到1楼。<br>问那台最快能到1楼 </p>
<p>看 a 和 abs(c-b)+c 谁小选谁。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>字符串按以下步骤加密：<br>当对于前9个字符用1到9分别代替<br>对于第10个以上的字符除用次序数字代替外再尾接一个0<br>现在给你一个加密的字符串要你把他转化为原字符串。</p>
<p>注意到只要从后向前出现0就可以认为是第二种加密方式。否则就是第一种。<br>初始时用dfs做的没必要。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>只要是字典序在第一个和最后一个字符之间都可以最后的花销是固定最小的。<br>需要做的就是将第二个到倒数第二个字符按字典序排序便知道跳跃顺序了。</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>我们需要让分的组数最多，每组最少两人，可以计算每个人付费后还剩多少钱（可能有负数）。<br>然后排序，用双指针算法，若两指针和大于等于0则可以分到同一组。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>概率算法<br>由于 ? a b 和 ? b a 有可能不同。 大概有1/2的可能性不同。<br>对于50次询问每次都相同是几乎不可能的。<br>于是只要有1次不同那么答案就是两次询问值之和。<br>之前用的二分法，但是10^18过大，50次询问太少了。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>看错题了。<br>一个数除9的余数是各个位上之和除9的余数。<br>所以对于大数可以快速求出除9的余数。</p>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>先预处理出每个匹配位置，再dp</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1740</title>
    <url>/2023/05/17/1740/</url>
    <content><![CDATA[<p>Codeforces Round #831 (Div. 1 + Div. 2) 1740</p>
<p><a href="https://codeforces.com/contest/1740/problems">Complete problemset</a></p>
<h1 id="A-Factorise-N-M"><a href="#A-Factorise-N-M" class="headerlink" title="A. Factorise N+M"></a>A. Factorise N+M</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个素数n，求一个数m使得n+m不是素数</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>n+n不是素数</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Jumbo-Extra-Cheese-2"><a href="#B-Jumbo-Extra-Cheese-2" class="headerlink" title="B. Jumbo Extra Cheese 2"></a>B. Jumbo Extra Cheese 2</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出n个矩形求排成一行的最小周长</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>对于每个矩形两条较短的边要算两次，剩余的长的边可以被更长的边包含，所以答案是2倍所有短边之和+2倍最长长边</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">std::vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">		a[i] = x;</span><br><span class="line">		b[i] = y;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="number">2</span>*(<span class="built_in">accumulate</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0LL</span>)+*<span class="built_in">max_element</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>())) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Bricks-and-Bags"><a href="#C-Bricks-and-Bags" class="headerlink" title="C. Bricks and Bags"></a>C. Bricks and Bags</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>现在有n块砖头（n&gt;3），每块砖头的权重是$a_i$，现在需要将它们放到三个背包里，每个背包最少放一块，然后分别从三个包里拿出1块，假设从第i个包里拿出的砖权重为$w_i$，令总价值为$|w_1-w_2|+|w_2-w_3|$，问如何分配n块转使得从包里拿出三块转的最小总价值最大。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>对n块砖排序，考虑两种情况的最大值</p>
<ul>
<li>背包1 $a_1$，背包2 $a_{2\dots i}$，背包3 $a_{i+1 \dots n}$</li>
<li>背包1 $a_{1 \dots i-1}$，背包2 $a_{i\dots n-1}$，背包3 $a_{n}$</li>
</ul>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	set&lt;ll&gt; st;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		ll x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		st.<span class="built_in">insert</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">std::vector&lt;ll&gt; <span class="title">v</span><span class="params">(st.begin(), st.end())</span></span>;</span><br><span class="line">	<span class="type">int</span> sz = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (sz == <span class="number">1</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sz == <span class="number">2</span>) cout &lt;&lt; <span class="number">2</span>*(v[<span class="number">1</span>]-v[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;sz; i++) &#123;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, v[i]-v[<span class="number">0</span>]+v[i]-v[i<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=sz<span class="number">-3</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, v[i+<span class="number">1</span>]-v[i]+v[sz<span class="number">-1</span>]-v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Knowledge-Cards"><a href="#D-Knowledge-Cards" class="headerlink" title="D. Knowledge Cards"></a>D. Knowledge Cards</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出一个n行m列的棋盘，现在有一堆从1到k的卡牌放在(0,0)位置，每次可以将(0,0)位置的牌放到任意位置，也可以将非(n,m)位置的牌放到非(0,0)的位置，只有(0,0), (n,m)可以堆叠，问最后能否在(n,m)形成升序的排列</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>如果当前(n,m)位置需要卡牌c，然而除了(0,0)和(n,m)其他n<em>m-2个位置都已经满了，那么将无法形成升序，但凡存在一个空位卡牌c都能移动到(n,m)，所以可以用一个大根堆模拟，若堆内元素等于n</em>m-2则无法形成。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m, k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(k)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++) cin &gt;&gt; v[i];</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">	<span class="type">int</span> c = k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">		que.<span class="built_in">push</span>(v[i]);</span><br><span class="line">		<span class="keyword">if</span> (que.<span class="built_in">size</span>() == m*n<span class="number">-2</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;TIDAK\n&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (que.<span class="built_in">size</span>() &amp;&amp; que.<span class="built_in">top</span>() == c) &#123;</span><br><span class="line">			que.<span class="built_in">pop</span>();</span><br><span class="line">			c--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;YA\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Hanging-Hearts"><a href="#E-Hanging-Hearts" class="headerlink" title="E. Hanging Hearts"></a>E. Hanging Hearts</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给出一棵n个节点的树，用任意1到n的排列给每个节点赋权值。每次可以删除叶子节点然后将叶子节点的值加入到一个序列中，如果叶子节点的父节点权值大于它，那么父节点的值赋值为叶子节点的值。问最后形成的序列的最长非降序子序列是多长</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>在删除x节点时，x的值一定是以x为根的子树中的最小值。我么可以安排x子树的最小值在最深的叶子上，这样以x结尾的最长非降序序列就是x子树的深度，令$len[i]$是i的深度，$len[i] = \max {len[son_i]}+1$，$dp[i]$是以i为根的子树形成的最长非降序序列，$dp[i] = \max {len[son_i], \sum dp[son_i]}$</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len[N], dp[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i:g[x]) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(i);</span><br><span class="line">		dp[x] += dp[i];</span><br><span class="line">		len[x] = <span class="built_in">max</span>(len[x], len[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	len[x]++;</span><br><span class="line">	dp[x] = <span class="built_in">max</span>(dp[x], len[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">		g[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; dp[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1744</title>
    <url>/2023/05/17/1744/</url>
    <content><![CDATA[<p>Codeforces Round #828 (Div. 3) 1744</p>
<p><a href="https://codeforces.com/contest/1744/problems">Problems - Codeforces</a></p>
<h1 id="A-Number-Replacement"><a href="#A-Number-Replacement" class="headerlink" title="A. Number Replacement"></a>A. Number Replacement</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个长度都为n的数组a和字符串s<br>问能否将所有a[i] 映射为 s[i]。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>哈希表建立映射若a[i] 已经映射了一个非s[i]，则输出NO，当所有a[i]都满足则YES。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 505</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n; string s;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) cin &gt;&gt; a[i];</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">char</span>&gt; mp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mp.<span class="built_in">count</span>(a[i])) &#123;</span><br><span class="line">			mp[a[i]] = s[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mp[a[i]] != s[i]) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Even-Odd-Increments"><a href="#B-Even-Odd-Increments" class="headerlink" title="B. Even-Odd Increments"></a>B. Even-Odd Increments</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出一个长度为n的数组a，以及q次操作。<br>每次操作有两种类型：</p>
<ol>
<li>给所有偶数加上x</li>
<li>给所有计数加上x<br>每次操作后都需要输出新数组的和。</li>
</ol>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>根据每次操作的类型，添加的x的奇偶性，数组中奇偶数的个数，可以知道为总和贡献了多少，并在操作后更新奇偶数的个数。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, q; cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	ll s = <span class="number">0</span>, e = <span class="number">0</span>, o = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		ll x; cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span> (x%<span class="number">2</span>) o++;</span><br><span class="line">		<span class="keyword">else</span> e++;</span><br><span class="line">		s += x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;q; i++) &#123;</span><br><span class="line">		<span class="type">int</span> tp, x;</span><br><span class="line">		cin &gt;&gt; tp &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span>(tp) &#123;</span><br><span class="line">			s += o*x;</span><br><span class="line">			<span class="keyword">if</span> (x%<span class="number">2</span>) e = n, o = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			s += e*x;</span><br><span class="line">			<span class="keyword">if</span> (x%<span class="number">2</span>) e = <span class="number">0</span>, o = n; </span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Traffic-Light"><a href="#C-Traffic-Light" class="headerlink" title="C. Traffic Light"></a>C. Traffic Light</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给你一个长度为n的字符串<code>s</code>，和字符<code>c</code>。<br>字符串只包含<code>’r’</code>，<code>’y’</code>，<code>’g’</code>，分别代表红，黄，绿，当前的颜色是<code>c</code>，字符串中可能由多个<code>c</code>这种颜色，求每一个<code>c</code>右侧离他最近的<code>g</code>之间的距离的最大值。字符串是首位相接的循环字符串。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>直接拼接一次s，在两倍长度的字符串内一定可以贪心找到最大距离。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n; string c, s;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; c &gt;&gt; s;</span><br><span class="line">	<span class="keyword">if</span> (c[<span class="number">0</span>] == <span class="string">&#x27;g&#x27;</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	s += s;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="number">-1</span> &amp;&amp; s[i] == c[<span class="number">0</span>]) &#123;</span><br><span class="line">			p = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (p != <span class="number">-1</span> &amp;&amp; s[i] == <span class="string">&#x27;g&#x27;</span>) &#123;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, i-p);</span><br><span class="line">			p = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Divisibility-by-2-n"><a href="#D-Divisibility-by-2-n" class="headerlink" title="D. Divisibility by 2^n"></a>D. Divisibility by 2^n</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出一个长度为<code>n</code>的数组<code>a</code>，我们可以对数组进行多次操作，每次操作可以让<code>a[i] = a[i]*i</code>, （数组下标从<code>1</code>开始），但是每个下标最多只能操作一次，我们的目标是用最少的次数使得a的所有元素积成为$2^n$的倍数，若没有答案则输出-1。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先我们可以看原始数组之积中的2因子个数是否不小于n，是则不需要任何操作。否则，我们会选择每能贡献最多2因子的下标进行操作，直到满足2因子的个数大于等于n为止，若n次操作后都不满足则输出-1.</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		ll x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">while</span> (x%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> u = i, c=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (u%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">			u&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">			c++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (c) p.<span class="built_in">push_back</span>(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(p.<span class="built_in">rbegin</span>(), p.<span class="built_in">rend</span>());</span><br><span class="line">	<span class="keyword">if</span> (cnt &gt;= n) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;p.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cnt += p[i];</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= n) &#123;</span><br><span class="line">			cout &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E1-Divisible-Numbers-easy-version"><a href="#E1-Divisible-Numbers-easy-version" class="headerlink" title="E1. Divisible Numbers (easy version)"></a>E1. Divisible Numbers (easy version)</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给你四个整数a,b,c,d, 满足$1 \leq a &lt; c \leq 10^5$，$1 \leq b &lt; d \leq 10^5$，求整数x，y，使得$a &lt; x \leq c, b &lt; y \leq d$，<br>且x<em>y 被a</em>b整除</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>注意到数据范围1e5, 我们可以枚举x或y来求另一个y或x，这里我们枚举x，对于任意a&lt;x≤c，如何找到一个最小的y使得x<em>y能整除a</em>b，我们找到x和a<em>b公共部分，让a</em>b移除这一部分，剩余的部分乘以x才能是ab的倍数，所以<code>y = a*b/gcd(x, a*b)</code> 是最小使得x<em>y能整除a</em>b的数。然而此时的y应该满足b&lt;y≤d这一条件。我们要让y倍增到这一范围内，可以让$y = (\lfloor \frac{b}{y} \rfloor+1) * y$, 然后判断$y≤d$; 或者让$y= (\lfloor \frac{d}{y} \rfloor) * y$，然后判断$b&lt;y$</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll a, b, c, d;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">	ll m = a*b;</span><br><span class="line">	<span class="keyword">for</span> (ll x=a+<span class="number">1</span>; x&lt;=c; x++) &#123;</span><br><span class="line">		ll y = m/__gcd(m, x);</span><br><span class="line">		<span class="comment">// if (y&lt;=b) y = (b/y+1)*y;</span></span><br><span class="line">		y = d/y*y;</span><br><span class="line">		<span class="keyword">if</span> (b&lt;y &amp;&amp; y&lt;=d) &#123;</span><br><span class="line">			cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-1 -1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E2-Divisible-Numbers-hard-version"><a href="#E2-Divisible-Numbers-hard-version" class="headerlink" title="E2. Divisible Numbers (hard version)"></a>E2. Divisible Numbers (hard version)</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>与E1只有数据范围不同，$1 \leq a &lt; c \leq 10^9, 1 \leq b &lt; d \leq 10^9$</p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这次枚举x是不行了，我们试想什么样的数是a<em>b的倍数呢？如果这个数是a</em>b的倍数，那么也一定是a的因子及b的因子的倍数，a的因子量级大概是$a^{\frac{1}{3}}$,大概在1e3左右，b也如此，那么枚举a和b的因子数量级在1e6, 若当前枚举的a与b的因子之积为x，则y=a<em>b/gcd(a</em>b, x)是最小使得x<em>y成为a</em>b的倍数的数，然后判断能否倍增x到(a,c], y到(b,d]即可。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll a, b, c, d;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">	vector&lt;ll&gt; fa, fb;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i*i&lt;=a; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a%i==<span class="number">0</span>) fa.<span class="built_in">push_back</span>(i), fa.<span class="built_in">push_back</span>(a/i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i*i&lt;=b; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b%i==<span class="number">0</span>) fb.<span class="built_in">push_back</span>(i), fb.<span class="built_in">push_back</span>(b/i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (ll i:fa) &#123;</span><br><span class="line">		<span class="keyword">for</span> (ll j:fb) &#123;</span><br><span class="line">			ll x = i*j, y = a*b/(i*j);</span><br><span class="line">			<span class="keyword">if</span> (x&lt;=a) x = (a/x+<span class="number">1</span>)*x;</span><br><span class="line">			<span class="keyword">if</span> (y&lt;=b) y = (b/y+<span class="number">1</span>)*y;</span><br><span class="line">			<span class="keyword">if</span> (x&lt;=c &amp;&amp; y&lt;=d) &#123;</span><br><span class="line">				cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-1 -1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1746</title>
    <url>/2023/05/17/1746/</url>
    <content><![CDATA[<p>Codeforces Global Round 23 1746</p>
<p><a href="https://codeforces.com/contest/1746/problems">Complete problemset</a></p>
<h1 id="A-Maxmina"><a href="#A-Maxmina" class="headerlink" title="A. Maxmina"></a>A. Maxmina</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出长度为n的01数组a，和整数k，给出两种操作：</p>
<ul>
<li>选择连续的两个数，然后替换成二者中最小值。</li>
<li>选择连续的k个数，然后替换成k者中最大值。</li>
</ul>
<p>问经过任意次数操作后能否变为1.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果数组含1，我们可以对连续的0用操作1，然后变为单个0，当没有连续0的时候让0和1用操作1，最后变为长度为k的数组用操作2即可，所以只要含有1答案即使YES</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span> (x) ok = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; (ok?<span class="string">&quot;YES\n&quot;</span>:<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Rebellion"><a href="#B-Rebellion" class="headerlink" title="B. Rebellion"></a>B. Rebellion</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出长度为n的01数组a，每次操作可以选择两个不同的索引i，j。让a[i] += a[j], 然后移除a[j]</p>
<p>问最少需要多少次可以让a变为非降序数组。</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>双指针，从左向右找1，从右向左找0，然后交换并记录次数。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">		<span class="keyword">while</span> (l&lt;r &amp;&amp; a[r] == <span class="number">1</span>) r--;</span><br><span class="line">		<span class="keyword">while</span> (l&lt;r &amp;&amp; a[l] == <span class="number">0</span>) l++;</span><br><span class="line">		<span class="keyword">if</span> (l != r) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[l], a[r]);</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Permutation-Operations"><a href="#C-Permutation-Operations" class="headerlink" title="C. Permutation Operations"></a>C. Permutation Operations</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给你一个长度为n的排列a，并执行n次操作，第i次操作可以指定任意后缀让每个值都增长i。每次操作指定哪些后缀可以让最后的a逆序数最小。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>我们一次操作如果是指定了下标i那么只能消除a[i-1]和a[i]之间的差距，后缀相邻元素的差距都是同步增长的，所以一次操作只能修改一对相邻元素，所以我们可以先统计a[i-1]-a[i]&gt;0的数量cnt然后对其增序排序，对于前n-cnt次操作任意指定位置，然后后cnt次让排序后小的先执行。这样可以尽可能消除更多逆序对。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	std::vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> inv = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i<span class="number">-1</span>]&gt;a[i]) &#123;</span><br><span class="line">			v[a[i<span class="number">-1</span>]-a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">			inv++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n-inv; i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1 &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:v) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j:i) &#123;</span><br><span class="line">			cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Paths-on-the-Tree"><a href="#D-Paths-on-the-Tree" class="headerlink" title="D. Paths on the Tree"></a>D. Paths on the Tree</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出一颗n个节点的树，并且每个节点都有权值，现在需要选择k条从根出发的路径，使得每条所选路径上节点权值之和最大。要求是每个节点选择的次数与其他所有兄弟节点被选次数相差不超过1.</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>树上动态规划。只是状态的索引并不是连续的，我们可以将它存在哈希表中。</p>
<p>定义<code>dp[i][j]</code>为以i号节点为根出发j条路径的最大权值和。状态转移取决于子节点。设i的子节点数量为$sz_i$，由于兄弟节点选择次数相差不超过1，所以我们需要尽可能地将j平分给$sz_i$个节点，每个节点至少分配$\lfloor \frac{j}{sz_i} \rfloor$条路径。对于剩余的j%$sz_i$条改分给谁，应该选择各个子节点分配$\lfloor \frac{j}{sz_i}\rfloor + 1$条路径的贡献最大的j%$sz_i$条。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,ll&gt;&gt; ans[N];</span><br><span class="line">ll s[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123; </span><br><span class="line">	<span class="comment">// if (k == 0) return 0;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> [i,j]:ans[x]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == k) <span class="keyword">return</span> j;</span><br><span class="line">	&#125;</span><br><span class="line">	ll res = k*s[x];</span><br><span class="line">	<span class="type">int</span> sz = g[x].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (sz == <span class="number">0</span>) &#123;</span><br><span class="line">		ans[x].<span class="built_in">emplace_back</span>(k, res);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (k%sz == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i:g[x]) &#123;</span><br><span class="line">			res += <span class="built_in">dfs</span>(i, k/sz);		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ll dp1[sz], dp2[sz], dif[sz];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">			dp1[i] = <span class="built_in">dfs</span>(g[x][i], k/sz);</span><br><span class="line">			dp2[i] = <span class="built_in">dfs</span>(g[x][i], k/sz+<span class="number">1</span>);</span><br><span class="line">			dif[i] = dp2[i]-dp1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(dif, dif+sz, <span class="built_in">greater</span>&lt;ll&gt;());</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">			res += dp1[i];</span><br><span class="line">			<span class="keyword">if</span> (i&lt;k%sz) res += dif[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[x].<span class="built_in">emplace_back</span>(k, res);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) g[i].<span class="built_in">clear</span>(), ans[i].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">		g[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; s[i];</span><br><span class="line">	cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>, k) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E1-Joking-Easy-Version"><a href="#E1-Joking-Easy-Version" class="headerlink" title="E1. Joking (Easy Version)"></a>E1. Joking (Easy Version)</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>你需要从1到n中猜出x，最多询问82次，每次询问可以问x是否存在一个集合中，但是回答可能会说谎，不过保证连续两次询问不会说谎。另外你可以做多两次确认x。</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>我们把集合分为三组a,bc,可以在最多三次操作后排除一个集合，也就是说三次操作可以减少1/3规模</p>
<p>将剩余数字分为a0, a1, a2三部分，<br>最多三次查询可以减少1/3规模<br>最后剩余两个可以直接猜。<br>100000 * (2/3)^x = 2<br>math.log(2/100000, 2/3) = 26.684856644986407</p>
<p>27*3 = 81<br>最多81次</p>
<p>a0=y a1=y 时</p>
<p>两者不可能同时为真，也不可能同时为假<br>a0=y为假则a1=y为真，必在a1<br>a0=y为真则a1=y为假，必在a0<br>必在a0+a1</p>
<p>a0=y a1=n 时<br>不可能同时为假<br>a0=y真且a1=n假不可能存在<br>a0=y真且a1=n真，必在a0<br>a0=y假且a1=n真，必在a2<br>必在a0+a2</p>
<p>a0=n a0=n 时<br>不可能同时为假，也不可能一真一假，只可能都为真，必定不在a0<br>必在a1+a2</p>
<p>a0=0 a1=y 时<br>回到第一二两种情况</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">将剩余数字分为a0, a1, a2三部分，</span></span><br><span class="line"><span class="comment">最多三次查询可以减少1/3规模</span></span><br><span class="line"><span class="comment">最后剩余两个可以直接猜。</span></span><br><span class="line"><span class="comment">100000 * (2/3)^x = 2</span></span><br><span class="line"><span class="comment">math.log(2/100000, 2/3) = 26.684856644986407</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">27*3 = 81</span></span><br><span class="line"><span class="comment">最多81次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a0 a1</span></span><br><span class="line"><span class="comment">y  y     </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">两者不可能同时为真，也不可能同时为假</span></span><br><span class="line"><span class="comment">a0=y为假则a1=y为真，必在a1</span></span><br><span class="line"><span class="comment">a0=y为真则a1=y为假，必在a0</span></span><br><span class="line"><span class="comment">必在a0+a1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a0 a1</span></span><br><span class="line"><span class="comment">y  n     </span></span><br><span class="line"><span class="comment">不可能同时为假</span></span><br><span class="line"><span class="comment">a0=y真且a1=n假不可能存在</span></span><br><span class="line"><span class="comment">a0=y真且a1=n真，必在a0</span></span><br><span class="line"><span class="comment">a0=y假且a1=n真，必在a2</span></span><br><span class="line"><span class="comment">必在a0+a2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a0 a0</span></span><br><span class="line"><span class="comment">n  n</span></span><br><span class="line"><span class="comment">不可能同时为假，也不可能一真一假，只可能都为真,不在a0</span></span><br><span class="line"><span class="comment">必在a1+a2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a0 a1</span></span><br><span class="line"><span class="comment">n  y</span></span><br><span class="line"><span class="comment">回到第一二两种情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ask</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i:v) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="keyword">return</span> s==<span class="string">&quot;YES&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b, vector&lt;<span class="type">int</span>&gt;&amp; to)</span> </span>&#123;</span><br><span class="line">	to.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i:a) to.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i:b) to.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) v[i] = i+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; a[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			a[i%<span class="number">3</span>].<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">ask</span>(a[<span class="number">0</span>])) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">ask</span>(a[<span class="number">1</span>])) &#123;</span><br><span class="line">				<span class="built_in">merge</span>(a[<span class="number">0</span>], a[<span class="number">1</span>], v);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">merge</span>(a[<span class="number">0</span>], a[<span class="number">2</span>], v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">ask</span>(a[<span class="number">0</span>])) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">ask</span>(a[<span class="number">1</span>])) &#123;</span><br><span class="line">					<span class="built_in">merge</span>(a[<span class="number">0</span>], a[<span class="number">1</span>], v);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="built_in">merge</span>(a[<span class="number">0</span>], a[<span class="number">2</span>], v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">merge</span>(a[<span class="number">1</span>], a[<span class="number">2</span>], v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (v.<span class="built_in">size</span>()&lt;=<span class="number">2</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">			string s;</span><br><span class="line">			cin &gt;&gt; s;</span><br><span class="line">			<span class="keyword">if</span> (s == <span class="string">&quot;:(&quot;</span>) &#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">				cin &gt;&gt; s;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="F-Kazaee"><a href="#F-Kazaee" class="headerlink" title="F. Kazaee"></a>F. Kazaee</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给出一个长度为n的数组a, 执行q次如下操作之一：</p>
<ul>
<li>将a[i] 赋值为x</li>
<li>查询a[l…r]中每个数出现的次数是否是k的倍数。</li>
</ul>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>如果l到r中的每个数出现的次数都是k的倍数，那么任意选一部分也是将k的倍数，所以我们可以多次随机选取一些数检测，如果出现不是k的倍数那么就一定不是，如果都是k的倍数说明极大概率是。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 600005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T 32</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">	ll BIT[N];</span><br><span class="line">	<span class="comment">// ll xBIT[N];</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bit_add</span><span class="params">(<span class="type">int</span> x, ll val)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i=x; i&lt;N; i+=i&amp;-i) &#123;</span><br><span class="line">	        BIT[i] += val;       </span><br><span class="line">	        <span class="comment">// xBIT[i] += x*val;</span></span><br><span class="line">	        <span class="comment">// 区间查询时 BIT[i] += val; xBIT[i] += x*val;</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">ll <span class="title">bit_ps</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	    ll rt = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=i&amp;-i) &#123;</span><br><span class="line">	        rt += BIT[i];</span><br><span class="line">	        <span class="comment">// rt += x*BIT[i]-xBIT[i];</span></span><br><span class="line">	        <span class="comment">// 区间查询时 rt += (x+1)*BIT[i]-xBIT[i];</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> rt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; bit[T];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> sl[T][N];</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mp.<span class="built_in">count</span>(x)) <span class="keyword">return</span> mp[x];</span><br><span class="line">	<span class="keyword">return</span> mp[x] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	random_device rd;</span><br><span class="line">	<span class="function">mt19937 <span class="title">mt</span><span class="params">(rd())</span></span>;</span><br><span class="line">	<span class="type">int</span> n, q;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;T; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n+q; j++) &#123;</span><br><span class="line">			sl[i][j] = <span class="built_in">mt</span>()%<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">id</span>(a[i]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;T; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sl[j][x]) bit[j].<span class="built_in">bit_add</span>(i,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;q; j++) &#123;</span><br><span class="line">		<span class="type">int</span> opt; cin &gt;&gt; opt;</span><br><span class="line">		<span class="keyword">if</span> (opt==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> i, x; cin &gt;&gt; i &gt;&gt; x;</span><br><span class="line">			<span class="type">int</span> prex = <span class="built_in">id</span>(a[i]);</span><br><span class="line">			a[i] = x;</span><br><span class="line">			x = <span class="built_in">id</span>(x);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> c=<span class="number">0</span>; c&lt;T; c++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (sl[c][prex]) bit[c].<span class="built_in">bit_add</span>(i,<span class="number">-1</span>);</span><br><span class="line">				<span class="keyword">if</span> (sl[c][x]) bit[c].<span class="built_in">bit_add</span>(i,<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> l, r, k;</span><br><span class="line">			cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">			<span class="type">int</span> ok = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;T; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((bit[i].<span class="built_in">bit_ps</span>(r)-bit[i].<span class="built_in">bit_ps</span>(l<span class="number">-1</span>))%k) &#123;</span><br><span class="line">					ok = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; (ok?<span class="string">&quot;YES\n&quot;</span>:<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1759</title>
    <url>/2023/05/17/1759/</url>
    <content><![CDATA[<p>Codeforces Round #834 (Div. 3) 1759</p>
<p><a href="https://codeforces.com/contest/1759/problems">Complete problemset</a></p>
<h1 id="A-Yes-Yes"><a href="#A-Yes-Yes" class="headerlink" title="A. Yes-Yes?"></a>A. Yes-Yes?</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>判断字符串是否是无限循环字符串<code>YesYesYes…</code> 的一部分。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>单独判断开头是否是<code>Yes</code>中的一个字符，然后对于之后的字符判断是与之前的字符的关系即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998224353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="keyword">if</span> (s[<span class="number">0</span>] != <span class="string">&#x27;Y&#x27;</span> &amp;&amp; s[<span class="number">0</span>] != <span class="string">&#x27;e&#x27;</span> &amp;&amp; s[<span class="number">0</span>] != <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;Y&#x27;</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">&#x27;s&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;s&#x27;</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">&#x27;e&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">&#x27;Y&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>; <span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Lost-Permutation"><a href="#B-Lost-Permutation" class="headerlink" title="B. Lost Permutation"></a>B. Lost Permutation</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出一个排列中的一部分的数组b，然后给出一个数s，s是排列剩余部分的和。问能否形成一个排列</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>s的值不大，才1000，让s不断减去不在b中的排列数。当s=0说明可以，s&lt;0说明不可以。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998224353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m, s;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; s;</span><br><span class="line">	<span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">1000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">		mx = <span class="built_in">max</span>(mx, x);</span><br><span class="line">		v[x] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=mx; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!v[i]) s-=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (s &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; (s==<span class="number">0</span>?<span class="string">&quot;YES\n&quot;</span>:<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	mx++;</span><br><span class="line">	<span class="keyword">while</span> (s&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		s -= mx;</span><br><span class="line">		<span class="keyword">if</span> (s &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; (s==<span class="number">0</span>?<span class="string">&quot;YES\n&quot;</span>:<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		mx++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Thermostat"><a href="#C-Thermostat" class="headerlink" title="C. Thermostat"></a>C. Thermostat</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出l，r，a，b，x五个数，其中l≤a,b≤r，问从a移动到b的最少次数，每次移动的距离至少是x，如果没有答案就输出-1</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>不妨设a≤b</p>
<p>当a=b时，不需要移动，移动次数为0</p>
<p>当b-a≤x时，移动一次即可。</p>
<p>当l≤a时，可以先移动到 l 再移动到 b，共两步。</p>
<p>当b≤r时，可以先移动到 r 再移动到 b，共两步。</p>
<p>当l≤b 且 a≤r时，从 a 移动到 r 再移动到 l 再移动到 b</p>
<p>其余情况就是-1</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998224353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll l, r, x, a, b;</span><br><span class="line">	cin &gt;&gt; l &gt;&gt; r &gt;&gt; x &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">if</span> (a&gt;b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">	<span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b-a&gt;=x) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a-l&gt;=x || r-b&gt;=x) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;2\n&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b-l &gt;= x &amp;&amp; r-a &gt;= x) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;3\n&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Make-It-Round"><a href="#D-Make-It-Round" class="headerlink" title="D. Make It Round"></a>D. Make It Round</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出一个n和m，需要找到一个数x小于等于m使得x<em>n十进制下尾部的0尽可能的多且值也尽可能的大。输出x</em>n</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>0的个数取决于2和5因子的个数。</p>
<p>先看n的2和5因子有多少。p为2因子的个数，q为5因子的个数, mn 为p和q的最小值</p>
<p>然后让p-=mn， q-=mn。</p>
<p>此时p和q至少1者为0，x初始为0</p>
<p>当p非0时，在x不大于m的情况下我们让x累乘5因子，这样可以让n*x的0变多。</p>
<p>同理当q非0时，在x不大于m的情况下我们让x累乘2因子，这样可以让n*x的0变多。</p>
<p>最后x如果累乘10因子不大于m，则继续累乘10，一切只为了让0变多。</p>
<p>最后为了让值尽可能大，需要找到x最接近m的倍数。即$\lfloor \frac{m}{x} \rfloor \times x$</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998224353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll n, m, r;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	r = n;</span><br><span class="line">	<span class="type">int</span> q=<span class="number">0</span>, p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (r%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">		r/=<span class="number">2</span>;</span><br><span class="line">		q++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (r%<span class="number">5</span>==<span class="number">0</span>) &#123;</span><br><span class="line">		r/=<span class="number">5</span>;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mn = <span class="built_in">min</span>(p, q);</span><br><span class="line">	p -= mn;</span><br><span class="line">	q -= mn;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p&gt;<span class="number">0</span> &amp;&amp; ans*<span class="number">2</span>&lt;=m) &#123;</span><br><span class="line">		ans *= <span class="number">2</span>;</span><br><span class="line">		p--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q&gt;<span class="number">0</span> &amp;&amp; ans*<span class="number">5</span>&lt;=m) &#123;</span><br><span class="line">		ans *= <span class="number">5</span>;</span><br><span class="line">		q--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ans*<span class="number">10</span>&lt;=m) &#123;</span><br><span class="line">		ans*=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; ans &lt;&lt; &quot; o&quot; &lt;&lt; endl;</span></span><br><span class="line">	cout &lt;&lt; m/ans*ans*n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-The-Humanoid"><a href="#E-The-Humanoid" class="headerlink" title="E. The Humanoid"></a>E. The Humanoid</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>现在有n个怪物需要打败，每个怪物的力量是$a_i$，你的力量是h，当你的力量h大于$a_i$是，可以打败并吸收$\lfloor \frac{a_i}{2} \rfloor$点力量。然后你有三瓶药水可以在任何时候使用，两瓶绿色药水和一瓶蓝色药水，绿色药水可以将自身力量2倍，蓝色药水可以将自身力量3倍。问最多能打败多少怪物。</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>dp</p>
<p>建立以下状态</p>
<p>dp[0][i] 没有喝药打败第i个怪物后的力量，（若打不过则为0，以下同）</p>
<p>dp[1][i] 喝一瓶绿药打败第i个怪物后的力量</p>
<p>dp[2][i] 喝二瓶绿药打败第i个怪物后的力量</p>
<p>dp[3][i] 喝一瓶蓝药打败第i个怪物后的力量</p>
<p>dp[4][i] 喝一瓶蓝药和一瓶绿药打败第i个怪物后的力量</p>
<p>dp[5][i] 喝一瓶蓝药和二瓶绿药打败第i个怪物后的力量</p>
<p>最后遍历所有状态看非0的dp值最大的i是多少即可。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998224353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">6</span>][N];</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll n, h;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; h;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++) dp[j][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = h;</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>*h;</span><br><span class="line">	dp[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>*h;</span><br><span class="line">	dp[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">3</span>*h;</span><br><span class="line">	dp[<span class="number">4</span>][<span class="number">0</span>] = <span class="number">6</span>*h;</span><br><span class="line">	dp[<span class="number">5</span>][<span class="number">0</span>] = <span class="number">12</span>*h;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">0</span>][i<span class="number">-1</span>] &gt; a[i]) dp[<span class="number">0</span>][i] = <span class="built_in">max</span>(dp[<span class="number">0</span>][i], dp[<span class="number">0</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">0</span>][i<span class="number">-1</span>]*<span class="number">2</span> &gt; a[i]) dp[<span class="number">1</span>][i] = <span class="built_in">max</span>(dp[<span class="number">1</span>][i], <span class="number">2</span>*dp[<span class="number">0</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">0</span>][i<span class="number">-1</span>]*<span class="number">4</span> &gt; a[i]) dp[<span class="number">2</span>][i] = <span class="built_in">max</span>(dp[<span class="number">2</span>][i], <span class="number">4</span>*dp[<span class="number">0</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">0</span>][i<span class="number">-1</span>]*<span class="number">3</span> &gt; a[i]) dp[<span class="number">3</span>][i] = <span class="built_in">max</span>(dp[<span class="number">3</span>][i], <span class="number">3</span>*dp[<span class="number">0</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">0</span>][i<span class="number">-1</span>]*<span class="number">6</span> &gt; a[i]) dp[<span class="number">4</span>][i] = <span class="built_in">max</span>(dp[<span class="number">4</span>][i], <span class="number">6</span>*dp[<span class="number">0</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">0</span>][i<span class="number">-1</span>]*<span class="number">12</span> &gt; a[i]) dp[<span class="number">5</span>][i] = <span class="built_in">max</span>(dp[<span class="number">5</span>][i], <span class="number">12</span>*dp[<span class="number">0</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">1</span>][i<span class="number">-1</span>] &gt; a[i]) dp[<span class="number">1</span>][i] = <span class="built_in">max</span>(dp[<span class="number">1</span>][i], dp[<span class="number">1</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">1</span>][i<span class="number">-1</span>]*<span class="number">2</span> &gt; a[i]) dp[<span class="number">2</span>][i] = <span class="built_in">max</span>(dp[<span class="number">2</span>][i], <span class="number">2</span>*dp[<span class="number">1</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">1</span>][i<span class="number">-1</span>]*<span class="number">3</span> &gt; a[i]) dp[<span class="number">4</span>][i] = <span class="built_in">max</span>(dp[<span class="number">4</span>][i], <span class="number">3</span>*dp[<span class="number">1</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">1</span>][i<span class="number">-1</span>]*<span class="number">6</span> &gt; a[i]) dp[<span class="number">5</span>][i] = <span class="built_in">max</span>(dp[<span class="number">5</span>][i], <span class="number">6</span>*dp[<span class="number">1</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">2</span>][i<span class="number">-1</span>] &gt; a[i]) dp[<span class="number">2</span>][i] = <span class="built_in">max</span>(dp[<span class="number">2</span>][i], dp[<span class="number">2</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">2</span>][i<span class="number">-1</span>]*<span class="number">3</span> &gt; a[i]) dp[<span class="number">5</span>][i] = <span class="built_in">max</span>(dp[<span class="number">5</span>][i], <span class="number">3</span>*dp[<span class="number">2</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">3</span>][i<span class="number">-1</span>] &gt; a[i]) dp[<span class="number">3</span>][i] = <span class="built_in">max</span>(dp[<span class="number">3</span>][i], dp[<span class="number">3</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">3</span>][i<span class="number">-1</span>]*<span class="number">2</span> &gt; a[i]) dp[<span class="number">4</span>][i] = <span class="built_in">max</span>(dp[<span class="number">4</span>][i], <span class="number">2</span>*dp[<span class="number">3</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">3</span>][i<span class="number">-1</span>]*<span class="number">4</span> &gt; a[i]) dp[<span class="number">5</span>][i] = <span class="built_in">max</span>(dp[<span class="number">5</span>][i], <span class="number">4</span>*dp[<span class="number">3</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">4</span>][i<span class="number">-1</span>] &gt; a[i]) dp[<span class="number">4</span>][i] = <span class="built_in">max</span>(dp[<span class="number">4</span>][i], dp[<span class="number">4</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">4</span>][i<span class="number">-1</span>]*<span class="number">2</span> &gt; a[i]) dp[<span class="number">5</span>][i] = <span class="built_in">max</span>(dp[<span class="number">5</span>][i], <span class="number">2</span>*dp[<span class="number">4</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dp[<span class="number">5</span>][i<span class="number">-1</span>] &gt; a[i]) dp[<span class="number">5</span>][i] = <span class="built_in">max</span>(dp[<span class="number">5</span>][i], dp[<span class="number">5</span>][i<span class="number">-1</span>]+a[i]/<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[j][i] != <span class="number">0</span>) &#123;</span><br><span class="line">				mx = <span class="built_in">max</span>(mx, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="F-All-Possible-Digits"><a href="#F-All-Possible-Digits" class="headerlink" title="F. All Possible Digits"></a>F. All Possible Digits</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给出一个n位p进制数，用数组a表示。每次可以让这个p进制数自增1，问最少自增多少次后可以所有0到p-1的数字都出现过。</p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>模拟</p>
<p>最多自增不超过p-1次。考虑最后一位的变化，最后一位进位的情况。</p>
<p>$a_n$作为最后一位</p>
<p>考虑a_n到0是否都出现过。</p>
<p>如果都出现过，a_n需要移动到从p-1到a_n第一个没出现的数的位置。</p>
<p>否则就需要进位，模拟进位后位置在0，需要移动到从a_n到0第一个没有出现的数的位置</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998224353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, p;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) a[i] = <span class="number">0</span>;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		st.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=a[n]; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (st.<span class="built_in">count</span>(i) == <span class="number">0</span>) &#123;</span><br><span class="line">			pos = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123; <span class="comment">// 0到a[n]完好，考虑a[n]到p-1</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=p<span class="number">-1</span>; i&gt;=a[n]; i--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (st.<span class="built_in">count</span>(i) == <span class="number">0</span>) &#123;</span><br><span class="line">				ans = i-a[n];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	ans = p-a[n];<span class="comment">//a[n]移动到0位置，共p-a[n]步。</span></span><br><span class="line">	st.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] != p<span class="number">-1</span>) &#123;</span><br><span class="line">			st.<span class="built_in">insert</span>(a[i]+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=a[n]<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (st.<span class="built_in">count</span>(i) == <span class="number">0</span>) &#123;</span><br><span class="line">			ans += i; <span class="comment">// 需要经过0到i,共i+1步</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="G-Restore-the-Permutation"><a href="#G-Restore-the-Permutation" class="headerlink" title="G. Restore the Permutation"></a>G. Restore the Permutation</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>有一个排列b，给出所有偶数位置的数，求奇数位置的数，使得每个奇数位置的数小于后一位，且使整个排列字典序最小。如果没有就-1.</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>从后向前遍历已知的一半排列，对于x，需要找到不大于x的最大数放在x前方。可以在平衡树上二分查找。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998224353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) a[i] = <span class="number">0</span>, st.<span class="built_in">insert</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n/<span class="number">2</span>; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i*<span class="number">2</span>];</span><br><span class="line">		st.<span class="built_in">erase</span>(a[i*<span class="number">2</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (st.<span class="built_in">size</span>() != n/<span class="number">2</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ok = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=n; i&gt;=<span class="number">2</span>; i-=<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">auto</span> it = st.<span class="built_in">upper_bound</span>(a[i]);</span><br><span class="line">		<span class="keyword">if</span> (it == st.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">			ok = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		--it;</span><br><span class="line">		a[i<span class="number">-1</span>] = *it;</span><br><span class="line">		st.<span class="built_in">erase</span>(it);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">			cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1760</title>
    <url>/2023/05/17/1760/</url>
    <content><![CDATA[<p>Codeforces Round #835 (Div. 4) 1760</p>
<p><a href="https://codeforces.com/contest/1760/problems">Complete problemset</a></p>
<h1 id="A-Medium-Number"><a href="#A-Medium-Number" class="headerlink" title="A. Medium Number"></a>A. Medium Number</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>三个不同的数的中间的数。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>排序</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">	cin &gt;&gt; a[<span class="number">0</span>] &gt;&gt; a[<span class="number">1</span>] &gt;&gt; a[<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">sort</span>(a, a+<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Atilla’s-Favorite-Problem"><a href="#B-Atilla’s-Favorite-Problem" class="headerlink" title="B. Atilla’s Favorite Problem"></a>B. Atilla’s Favorite Problem</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出一个字符串问最大的字符是多少</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>遍历求最大值。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">	cout &lt;&lt; *<span class="built_in">max_element</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>())-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Advantage"><a href="#C-Advantage" class="headerlink" title="C. Advantage"></a>C. Advantage</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出一个数，求每个数减去除了自己外的最大值。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>求出最大值和次大值，当前若等于最大值则减去次大值，否则减去最大值。（<del>看错题，浪费了时间</del>）</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n; </span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		b[i] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(b, b+n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] == b[n<span class="number">-1</span>]) &#123;</span><br><span class="line">			cout &lt;&lt; a[i] - b[n<span class="number">-2</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; a[i] - b[n<span class="number">-1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Challenging-Valleys"><a href="#D-Challenging-Valleys" class="headerlink" title="D. Challenging Valleys"></a>D. Challenging Valleys</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>问一个数组从左至右是否先非增长，然后非减小。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p><del>又有看错题</del>，可以先去掉相邻相同的值，然后判断是否存在一个<strong>峰值</strong>即可。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	vector&lt;ll&gt; a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		ll x; cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span> (a.<span class="built_in">size</span>() &amp;&amp; a.<span class="built_in">back</span>()==x) <span class="keyword">continue</span>;</span><br><span class="line">		a.<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sz = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;sz<span class="number">-1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i<span class="number">-1</span>]&lt;a[i] &amp;&amp; a[i]&gt;a[i+<span class="number">1</span>]) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Binary-Inversions"><a href="#E-Binary-Inversions" class="headerlink" title="E. Binary Inversions"></a>E. Binary Inversions</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给出一个01串，<strong>最多</strong>操作一次：让一个位置的数反转。最后逆序对最多是多少？</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>前缀后缀和</p>
<p>令$p[i]$为$a[0…i]$中1出现的次数</p>
<p>令$s[i]$为$a[0…i]$中0出现的次数</p>
<p>那么遍历a，当前位置为i时，</p>
<p>若$a[i]$ 为1，让1变为0，则逆序数增加了$p[i]-1$个，减少了$s[i]$个</p>
<p>若$a[i]$ 为0，让0变为1，则逆序数减少加了$p[i]$个，增加了$s[i]-1$个</p>
<p>维护遍历时的最大值与不修改的最大值即可。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll p[N], s[N];</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	p[<span class="number">0</span>] = a[<span class="number">0</span>]==<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">		p[i] = p[i<span class="number">-1</span>] + (a[i] == <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	s[n<span class="number">-1</span>] = a[n<span class="number">-1</span>]==<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">		s[i] = s[i+<span class="number">1</span>] + (a[i] == <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">			res += s[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, res+p[i]<span class="number">-1</span>-s[i]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, res-p[i]+s[i]<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(ans, res) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="F-Quests"><a href="#F-Quests" class="headerlink" title="F. Quests"></a>F. Quests</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>有n个任务，每个任务完成后可以获得$a_i$个金币。每个任务可以做多次。但是每个任务都有相同的冷却时间k，k天之后才可以做相同的任务，问在d天内能至少赚c金币，k值最大能取多少。</p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>感觉这个题才是最难的。</p>
<p>直接枚举k，对于每个k我们肯定得贪心的选择最大金币的任务。对任务金币由大到小排序。但是有冷却的存在，所以在冷却时只能选择其它比较大的任务，但是也有可能所有任务都在冷却。</p>
<p>如果没有冷却每天都选最大值但是还是无法完成则是<code>Impossible</code></p>
<p>如果取最大冷却，也就是相当于每个任务只能完成一次，<code>d</code>天最多完成前<code>min(d,n)</code>个最大的任务。如果能完成则<code>Infinity</code></p>
<p>剩余的可以用二分法来枚举<code>k</code>，因为当<code>k</code>天能完成，则<code>k-1</code>天也能完成。所以找到最后一个能完成的<code>k</code>即可。</p>
<p>二分时枚举的冷却天数为<code>m</code>，则对于<code>d</code>天中的第<code>i</code>天，若<code>i%(m+1)&lt;n</code>，则第<code>i</code>天选择第<code>i%(m+1)</code>个任务</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll n, c, d;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; c &gt;&gt; d;</span><br><span class="line">	<span class="function">std::vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(a.<span class="built_in">rbegin</span>(), a.<span class="built_in">rend</span>());</span><br><span class="line">	<span class="keyword">if</span> (a[<span class="number">0</span>]*d &lt; c) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Impossible\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">accumulate</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>()+<span class="built_in">min</span>(n,d), <span class="number">0LL</span>) &gt;= c) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Infinity\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	ll l = <span class="number">0</span>, r = <span class="number">1e18</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		ll m = (r-l)/<span class="number">2</span>+l;</span><br><span class="line">		ll co = <span class="number">0</span>, ok = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;d; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i%(m+<span class="number">1</span>) &lt; n) co += a[i%(m+<span class="number">1</span>)];</span><br><span class="line">			<span class="keyword">if</span> (co&gt;=c) &#123;</span><br><span class="line">				ok = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">			l = m+<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r = m;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; r<span class="number">-1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="G-SlavicG’s-Favorite-Problem"><a href="#G-SlavicG’s-Favorite-Problem" class="headerlink" title="G. SlavicG’s Favorite Problem"></a>G. SlavicG’s Favorite Problem</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>给出一颗树，树边有权值。问是否可以从节点a移动到节点b。初始有一个x=0，每次移动后让x异或边权值。如果移动后的点是b，到达b后x必须为0。中途你可以传送到任何一个非b的点。</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>从b点开始进行广搜，求出每个点（除了b）到b的异或和。存入哈希表</p>
<p>如果存在异或和为0则直接可以从a传送到该点。所以答案为yes</p>
<p>如果不存在则从a开始广搜，在哈希表中如果存在当前点到a的异或和则可以传送到该点（注意广搜不能移动到b）。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;ll,ll&gt;&gt; g[N];</span><br><span class="line"></span><br><span class="line">map&lt;ll,ll&gt; mp;<span class="comment">//x到b的异或值映射到x</span></span><br><span class="line">ll n, a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfsb</span><span class="params">(ll u, ll fa, ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i,j]:g[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == fa) <span class="keyword">continue</span>;</span><br><span class="line">		mp[x^j] = i;</span><br><span class="line">		<span class="built_in">dfsb</span>(i, u, x^j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfsa</span><span class="params">(ll u, ll fa, ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i,j]:g[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == fa || i == b) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (mp.<span class="built_in">count</span>(j^x)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">dfsa</span>(i, u, x^j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mp.<span class="built_in">clear</span>();</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		g[i].<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">		ll x, y, z;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">		g[x].<span class="built_in">emplace_back</span>(y,z);</span><br><span class="line">		g[y].<span class="built_in">emplace_back</span>(x,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfsb</span>(b, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; ((mp.<span class="built_in">count</span>(<span class="number">0</span>) || <span class="built_in">dfsa</span>(a, <span class="number">-1</span>, <span class="number">0</span>))?<span class="string">&quot;YES\n&quot;</span>:<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1775</title>
    <url>/2023/05/17/1775/</url>
    <content><![CDATA[<p>Codeforces Round #843 (Div. 2) 1775<br><a href="https://codeforces.com/contest/1775/problems">Complete problemset</a></p>
<h1 id="A1-Gardener-and-the-Capybaras-easy-version"><a href="#A1-Gardener-and-the-Capybaras-easy-version" class="headerlink" title="A1. Gardener and the Capybaras (easy version)"></a>A1. Gardener and the Capybaras (easy version)</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个只由<code>’a’</code>和<code>‘b’</code> 组成的字符串s，问可否分成三个子串a，b，c，使得a≤b≥c 或者 a≥b≤c</p>
<p>字符串长度n不超过100</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>枚举拆分位置即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">			<span class="keyword">auto</span> a = s.<span class="built_in">substr</span>(<span class="number">0</span>,i), b = s.<span class="built_in">substr</span>(i,j-i), c = s.<span class="built_in">substr</span>(j);</span><br><span class="line">			<span class="keyword">if</span> (a&lt;=b &amp;&amp; c&lt;=b || a&gt;=b &amp;&amp; c&gt;=b) &#123;</span><br><span class="line">				cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;:(&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="A2-Gardener-and-the-Capybaras-hard-version"><a href="#A2-Gardener-and-the-Capybaras-hard-version" class="headerlink" title="A2. Gardener and the Capybaras (hard version)"></a>A2. Gardener and the Capybaras (hard version)</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一个只由<code>’a’</code>和<code>‘b’</code> 组成的字符串s，问可否分成三个子串a，b，c，使得a≤b≥c 或者 a≥b≤c</p>
<p>字符串长度n不超过200000</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>贪心</p>
<p>对于a≤b≥c的情况，我们在第二个字符到倒数第二个字符间寻找第一个<code>’b’</code>的位置p，让a = s[0], b=s[1:p], c=s[p+1,n-1]。</p>
<p>对于a≥b≤c的情况，我们在第二个字符到倒数第二个字符间寻找第一个<code>’a’</code>的位置p，让a = s[0,p-1], b=s[p], c=s[p+1,n-1]。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">			string a = s.<span class="built_in">substr</span>(<span class="number">0</span>,i), b = <span class="string">&quot;a&quot;</span>, c = s.<span class="built_in">substr</span>(i+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (a&gt;=b &amp;&amp; b&lt;=c) &#123;</span><br><span class="line">				cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">			string a = s.<span class="built_in">substr</span>(<span class="number">0</span>,i), b = s.<span class="built_in">substr</span>(i,n-i<span class="number">-1</span>), c = s.<span class="built_in">substr</span>(n<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span> (a&lt;=b &amp;&amp; b&gt;=c) &#123;</span><br><span class="line">				cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;:(\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Gardener-and-the-Array"><a href="#B-Gardener-and-the-Array" class="headerlink" title="B. Gardener and the Array"></a>B. Gardener and the Array</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>有n个数，已知n个数可能很大，于是给出n个数的二进制位。问能否找到两个不同的子序列使得两个子序列的<strong>或和</strong>相等</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>我们知道或和是不会随着数增加而减少的，我们可以寻找两个特殊的子序列。</p>
<p>其中一个是所有的n个数，另一个则可以是n-1个数。</p>
<p>我们检查去掉的这个数后会不会和n个数的或和相等即可。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(set&lt;<span class="type">int</span>&gt;&amp; a, map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i:a) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!b.<span class="built_in">count</span>(i) || b[i] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	std::vector&lt;set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">st</span>(n);</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> ki, p; cin &gt;&gt; ki;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;ki; j++) &#123;</span><br><span class="line">			cin &gt;&gt; p;</span><br><span class="line">			st[i].<span class="built_in">insert</span>(p);</span><br><span class="line">			v[p]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(st[i], v)) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;yes\n&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;no\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Interesting-Sequence"><a href="#C-Interesting-Sequence" class="headerlink" title="C. Interesting Sequence"></a>C. Interesting Sequence</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出两个数$n$和$x$，是否存在$n &amp; (n+1)&amp; \dots &amp; m=x$的$m$，存在则输出，否则输出-1。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>我们知道<strong>与和</strong>会不断减小，设$n$的由低到高位第$i$位二进制位为$n_i$，保证存在m的必要条件是$n_i \ge x_i$。</p>
<p>另外如果p是低位第一个满足$n_p = 1$且$x_p = 1$的位置，q是低位第一个满足$n_q=1$且$x_q=0$的位置。需要满足$q+1\le p$</p>
<p>此时答案就是n的末q位，置为0，然后第q+1位，置为1</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll n, x;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">	<span class="type">int</span> _10 = <span class="number">-1</span>, _11 = <span class="number">64</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">63</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> a = n&gt;&gt;i&amp;<span class="number">1</span>, b = x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; b == <span class="number">1</span>) _11 = i;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; b == <span class="number">0</span>) _10 = i;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> ;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">62</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="type">int</span> a = n&gt;&gt;i&amp;<span class="number">1</span>, b = x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; b == <span class="number">1</span>) _11 = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (_10 == <span class="number">-1</span>) &#123;</span><br><span class="line">		cout &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (_10 + <span class="number">1</span> &gt;= _11) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ((n&gt;&gt;_10+<span class="number">1</span>)&lt;&lt;_10+<span class="number">1</span>|<span class="number">1LL</span>&lt;&lt;_10+<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Friendly-Spiders"><a href="#D-Friendly-Spiders" class="headerlink" title="D. Friendly Spiders"></a>D. Friendly Spiders</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给出大小为n（2≤n≤3e5）的数组a（1≤a[i]≤3e5），若数u和v不互质则存在一条边，求从第s个数到第k个数的最短路径</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>直接建边求最短路由于边数太多会超时。</p>
<p>我们可以让每个数都连向虚拟节点：它们的质因数。由于小于3e5质因数的个数实际很少，只有100多个。这样连的边数大大减少，然后求bfs，求出路径，去除路径上虚拟节点。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 300005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 550</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; g[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> pre[N*<span class="number">2</span>], vis[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> nprime[MAXN];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(nprime, <span class="number">0</span>, <span class="built_in">sizeof</span>(nprime));</span><br><span class="line">	<span class="type">int</span> n = (<span class="type">int</span>) <span class="built_in">sqrt</span>(MAXN+<span class="number">0.5</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!nprime[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=i*i; j&lt;MAXN; j+=i) &#123;</span><br><span class="line">				nprime[j] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;MAXN; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!nprime[i]) &#123;</span><br><span class="line">			prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">			<span class="comment">// cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; prime.size();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) cin &gt;&gt; a[i];</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	x--; y--;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="type">int</span> u = a[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j:prime) &#123;</span><br><span class="line">			<span class="keyword">if</span> (u%j) <span class="keyword">continue</span>;</span><br><span class="line">			g[N+j].<span class="built_in">push_back</span>(i);</span><br><span class="line">			g[i].<span class="built_in">push_back</span>(N+j);</span><br><span class="line">			<span class="keyword">while</span> (u%j == <span class="number">0</span>) &#123;</span><br><span class="line">				u/=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (u != <span class="number">1</span>) &#123;</span><br><span class="line">			g[N+u].<span class="built_in">push_back</span>(i);</span><br><span class="line">			g[i].<span class="built_in">push_back</span>(N+u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(y);</span><br><span class="line">	vis[y] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i:g[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">				vis[i] = <span class="number">1</span>;</span><br><span class="line">				pre[i] = u;</span><br><span class="line">				q.<span class="built_in">push</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (vis[x] == <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; stp;</span><br><span class="line">	<span class="keyword">while</span> (x != y) &#123;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;N) stp.<span class="built_in">push_back</span>(x+<span class="number">1</span>);</span><br><span class="line">		x = pre[x];</span><br><span class="line">	&#125;</span><br><span class="line">	stp.<span class="built_in">push_back</span>(y+<span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; stp.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i:stp) &#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">get_prime</span>();</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-The-Human-Equation"><a href="#E-The-Human-Equation" class="headerlink" title="E. The Human Equation"></a>E. The Human Equation</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组，每次可以选取一个子序列，然后让子序列的奇数位置的数+1，偶数位置的数-1，或者奇数的位置的数-1，偶数位置的数+1。问让所有的数都为0的最小操作次数.</p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>其实每次我们相当于任选一些区间让这些区间+1或-1。</p>
<p>我们要找到区间和的绝对值最大的区间，设这个区间的绝对值为s</p>
<p>我们要操作的次数至少也要s次。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">std::vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="function">std::vector&lt;ll&gt; <span class="title">p</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) cin &gt;&gt; v[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) p[i] = p[i<span class="number">-1</span>]+v[i<span class="number">-1</span>];</span><br><span class="line">	cout &lt;&lt; *<span class="built_in">max_element</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>()) - *<span class="built_in">min_element</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>()) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="built_in">sol</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1778</title>
    <url>/2023/05/17/1778/</url>
    <content><![CDATA[<p>Codeforces Round #848 (Div. 2) 1778</p>
<p><a href="https://codeforces.com/contest/1778/problems">Complete problemset</a></p>
<h1 id="A-Flip-Flop-Sum"><a href="#A-Flip-Flop-Sum" class="headerlink" title="A. Flip Flop Sum"></a>A. Flip Flop Sum</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个长度为n数组a，数组中值要么为-1要么为1。</p>
<p>可以选择相邻两个数都进行反转（-1变为1，1变为-1），然后问数组和最大为多少。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先求总和s，然后遍历枚举求出$\max \limits_{i=1}^{n-1} s-2<em>a_i-2</em>a _{i-1}$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, s = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mx = -N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, s - <span class="number">2</span> * a[i - <span class="number">1</span>] - <span class="number">2</span> * a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; mx &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-The-Forbidden-Permutation"><a href="#B-The-Forbidden-Permutation" class="headerlink" title="B. The Forbidden Permutation"></a>B. The Forbidden Permutation</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出一个长度为$n$的排列$p$（$1≤p_i≤n$），和长度为$m$的数组$a$（$1≤a_i≤n$）。</p>
<p>如果对于所有$i$（$1≤i&lt;m$）满足$pos(a_i)&lt;pos(a_{i+1})≤pos(a_i)+d$，$pos(a_i)$是$a_i$在$p$中的位置。则称$a$为不好的数组。</p>
<p>现在问可以最少领项交换多少次使得数组a变为好数组。</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>先看是否存在i不满足$pos(a_i)&lt;pos(a_{i+1})≤pos(a_i)+d$。存在则是0。</p>
<p>否则</p>
<p>一种情况就是让$p_{a_i}$移动到$p_{a_{i+1}}$右侧，需要 $p_{a_{i+1}} - p_{a_i}$步。</p>
<p>另一种情况就是让$pos(a_{i+1})&gt;pos(a_i)+d$，我们可以让$p_{a_i}$左移，或$p_{a_{i+1}}$右移。使得之间有d个元素。</p>
<p>两种情况所移动的步数最小值即为答案。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mp[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, d;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        mp[i] = a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        mp[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp[a[i - <span class="number">1</span>]] &gt;= mp[a[i]] || mp[a[i]] &gt; mp[a[i - <span class="number">1</span>]] + d) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, mp[a[i]] - mp[a[i - <span class="number">1</span>]]);</span><br><span class="line">        <span class="keyword">if</span> (mp[a[i - <span class="number">1</span>]] + n - <span class="number">1</span> - mp[a[i]] &gt;=</span><br><span class="line">            mp[a[i - <span class="number">1</span>]] + d - mp[a[i]] + <span class="number">1</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, mp[a[i - <span class="number">1</span>]] + d - mp[a[i]] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Flexible-String-Revisit"><a href="#D-Flexible-String-Revisit" class="headerlink" title="D. Flexible String Revisit"></a>D. Flexible String Revisit</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>两个长度都为n的01数组a和b，每次可以等概率地选择a中一个位置进行反转，求让a和b第一次相等的期望</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>设f(i)为两个字符串有i个不同，使其变为相同所期望步数。</p>
<p>$f(i) = \frac{i}{n}(1+f(i-1))+\frac{n-i}{n}(1+f(i+1))=\frac{i}{n}f(i-1)+\frac{n-i}{n}f(i+1)+1$</p>
<p>$f(0)=0$</p>
<p>注意到$f(1) =1+\frac{n-i}{n}f(2)$，我们可以将$f(i) = \frac{i}{n}f(i-1)+\frac{n-i}{n}f(i+1)+1$化为$f(i) =a_i+b_if(i+1)$，显然$a_1 = 1, b_1 = \frac{n-i}{n}$</p>
<p>现在考虑$a_i,b_i$与$a_{i-1},b_{i-1}$的关系:</p>
<p>$f(i-1) =a_{i-1}+b_{i-1}f(i)$带入$f(i) = \frac{i}{n}f(i-1)+\frac{n-i}{n}f(i+1)+1$</p>
<p>得$f(i) = \frac{i}{n}(a_{i-1}+b_{i-1}f(i))+\frac{n-i}{n}f(i+1)+1$</p>
<p>整理得$f(i) = \frac{n+ia_{i-1}}{n-ib_{i-1}}+\frac{n-1}{n-ib_{i-1}}f(i+1)$</p>
<p>所以$a_i = \frac{n+ia_{i-1}}{n-ib_{i-1}}, b_i = \frac{n-1}{n-ib_{i-1}}$</p>
<p>注意到$f(n) =1+f(n-1)$，我们可以将$f(i) = \frac{i}{n}f(i-1)+\frac{n-i}{n}f(i+1)+1$化为$f(i) =c_i+d_if(i-1)$，显然$a_n = 1, b_n = 1$</p>
<p>现在考虑$c_i,d_i$与$c_{i+1},d_{i+1}$的关系:</p>
<p>$f(i+1) =c_{i+1}+d_{i+1}f(i)$带入$f(i) = \frac{i}{n}f(i-1)+\frac{n-i}{n}f(i+1)+1$</p>
<p>得$f(i) = \frac{i}{n}f(i-1)+\frac{n-i}{n}(c_{i+1}+d_{i+1}f(i))+1$</p>
<p>整理得$f(i) = \frac{n+(n-i)c_{i+1}}{n-(n-i)d_{i+1}}+\frac{i}{n-(n-i)d_{i+1}}f(i-1)$</p>
<p>所以$c_i = \frac{n+(n-i)c_{i+1}}{n-(n-i)d_{i+1}}, d_i = \frac{i}{n-(n-i)d_{i+1}}$</p>
<p>由$f(i-1) =a_{i-1}+b_{i-1}f(i),f(i) =c_i+d_if(i-1)$，解得$f(i) = \frac{c_i+d_ia_i-1}{1-d_ib_i-1}$</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll a[N], b[N], c[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll rt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            rt = rt * x % MOD;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">mi</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x % MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fpow</span>(<span class="built_in">mi</span>(x), MOD - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="type">int</span> dif = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dif += x[i] != y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dif == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>, b[<span class="number">1</span>] = <span class="built_in">mi</span>((n - <span class="number">1</span>) * <span class="built_in">inv</span>(n)), c[n] = <span class="number">1</span>, d[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = <span class="built_in">mi</span>(<span class="built_in">mi</span>(n + i * a[i - <span class="number">1</span>]) * <span class="built_in">inv</span>(n - i * b[i - <span class="number">1</span>]));</span><br><span class="line">        b[i] = <span class="built_in">mi</span>((n - i) * <span class="built_in">inv</span>(n - i * b[i - <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        c[i] = <span class="built_in">mi</span>(<span class="built_in">mi</span>(n + (n - i) * c[i + <span class="number">1</span>]) * <span class="built_in">inv</span>(n - (n - i) * d[i + <span class="number">1</span>]));</span><br><span class="line">        d[i] = <span class="built_in">mi</span>(i * <span class="built_in">inv</span>(n - (n - i) * d[i + <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">mi</span>(<span class="built_in">mi</span>(c[dif] + d[dif] * a[dif - <span class="number">1</span>]) * <span class="built_in">inv</span>(<span class="number">1</span> - d[dif] * b[dif - <span class="number">1</span>]))</span><br><span class="line">         &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-The-Tree-Has-Fallen"><a href="#E-The-Tree-Has-Fallen" class="headerlink" title="E. The Tree Has Fallen!"></a>E. The Tree Has Fallen!</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出一颗无根树，每个节点i都有一个节点值a[i]。现在有q次询问，每次询问选择一个节点r作为根，然后选择一个节点v，求v子树中选择一些节点让其异或值最大。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>sample</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sample</span><br></pre></td></tr></table></figure>

<h1 id="F-Maximizing-Root"><a href="#F-Maximizing-Root" class="headerlink" title="F. Maximizing Root"></a>F. Maximizing Root</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给出一颗有根树，每次操作你可以任意选择一个节点v，然后让v子树每个节点值乘以x，x为v子树节点的某个公约数。求任意操作次后，根节点最大为多少。</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>sample</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sample</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1781D Many Perfect Squares</title>
    <url>/2023/06/06/1781D/</url>
    <content><![CDATA[<h1 id="Many-Perfect-Squares"><a href="#Many-Perfect-Squares" class="headerlink" title="Many Perfect Squares"></a>Many Perfect Squares</h1><p>Created by LXC on Sat Jun  3 00:24:40 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1781/D">https://codeforces.com/problemset/problem/1781/D</a></p>
<p>ranting: 1800</p>
<p>tag: brute force, math, number theory</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>给出n个不同的升序排序的数（n≤50），如果给这n个数都加一个正整数使得n个数中平方数最多，最多是多少。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>对于任意两个数$a_i$和$a_j$，$i&lt;j$。考虑所有的非负整数k，使得这两个数加上k成为平方数。</p>
<p>任意两个数$a_j$和$a_i$的差值可以分解为两个数$q-p$和$p+q$的乘积，只需枚举其因子，便得知$q-p$和$q+p$，进一步可以解出$p$和$q$。测试$x=q^2-a_j$时有多少个数加上x会成为平方数，维护这个数最大即可。</p>
<p>设$p^2 = a_i+x$，$q^2 = a_j + x$</p>
<p>$q^2 - p^2 = (q-p)(q+p) = a_j-a_i$</p>
<p>设$x = q-p$，$y = q + p$。</p>
<p>$q = \frac{x+y}{2}$，若$q^2-a_j$非负便找到了一个可测的$x$。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](ll x) &#123;</span><br><span class="line">        <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i : a) &#123;</span><br><span class="line">            ll s = <span class="built_in">sqrt</span>(i + x);</span><br><span class="line">            <span class="keyword">if</span> (s * s == x + i) &#123;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, c);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            ll pq = a[j] - a[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k * k &lt;= pq; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pq % k == <span class="number">0</span>) &#123;</span><br><span class="line">                    ll p = (k + pq / k) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (p * p - a[j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">check</span>(p * p - a[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
        <tag>number theory</tag>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>1782</title>
    <url>/2023/05/17/1782/</url>
    <content><![CDATA[<p>Codeforces Round #844 (Div. 1 + Div. 2, based on VK Cup 2022 - Elimination Round) 1782</p>
<p><a href="https://codeforces.com/contest/1782/problems">Complete problemset</a></p>
<h1 id="A-Parallel-Projection"><a href="#A-Parallel-Projection" class="headerlink" title="A. Parallel Projection"></a>A. Parallel Projection</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个长为d，宽为w，高为h的立方体，给出顶面的一个坐标(a,b)，底面的一个坐标(f,g)，求两个坐标的在表面的最短距离</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出这两个点到四个侧边的最短距离v，答案就是<code>v+h+|a-f|+|b-g|</code></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> w, d, h;</span><br><span class="line">    cin &gt;&gt; w &gt;&gt; d &gt;&gt; h;</span><br><span class="line">    <span class="type">int</span> a, b, f, g;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; f &gt;&gt; g;</span><br><span class="line">    cout &lt;&lt; h + <span class="built_in">abs</span>(a - f) + <span class="built_in">abs</span>(b - g) +</span><br><span class="line">                <span class="built_in">min</span>(&#123;a, w - a, b, d - b, f, w - f, g, d - g&#125;)*<span class="number">2</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Going-to-the-Cinema"><a href="#B-Going-to-the-Cinema" class="headerlink" title="B. Going to the Cinema"></a>B. Going to the Cinema</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>有n个人要去电影院，给出一个长度为n的数组a。</p>
<p>如果第i个人要去电影院，那么至少要有$a_i$其他个人也去电影院。</p>
<p>如果第i个人不去电影院，那么其他去电影院的人要小于$a_i$。</p>
<p>否则第i个人就不开心。</p>
<p>求要让所有人都开心那么有多少种方式</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>如果有i个人去电影院，那么对应的是a数组中最小的i个数。因此可以升序排序后遍历判断。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    a.<span class="built_in">push_back</span>(N);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] != <span class="number">0</span>)</span><br><span class="line">        ans++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, a[i]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= i &amp;&amp; a[i + <span class="number">1</span>] &gt; i + <span class="number">1</span>)</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Equal-Frequencies"><a href="#C-Equal-Frequencies" class="headerlink" title="C. Equal Frequencies"></a>C. Equal Frequencies</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>如果一个字符串中出现的所有字符出现次数相同，那么就称之为平衡字符串。</p>
<p>现在给出一个长度为n的字符串，可以修改任意位置的字符为任意其他字符。</p>
<p>构造一个修改次数最少的平衡串。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>显然总共只有26个字母。假设最后的平衡字符串中有i种字符，那么每个字符出现的次数就是$\frac{n}{i}$。</p>
<p>已知的字符串中若有sz种字符，那么我们需要选取min(i,sz)个出现次数最多的字符，且这些字符最多也只有$\frac{n}{i}$个不修改。我们统计出不修改的字符个数，剩余的就是需要修改的个数了。暴力求出最小修改的个数mn及对应的出现字符种类数p。</p>
<p>接下来就是构造出平衡串。</p>
<p>我们如果原串的字符种数不足p则需要补齐到p。</p>
<p>标记不需要修改的字符，进而统计缺失的每个字符的个数。</p>
<p>对于非标记的字符，修改成缺失的字符。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i : s)</span><br><span class="line">        mp[i]++;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">cnt</span>(mp.<span class="built_in">begin</span>(), mp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>(),</span><br><span class="line">         [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123; <span class="keyword">return</span> a.second &gt; b.second; &#125;);</span><br><span class="line">    <span class="comment">// for (auto [i, j] : cnt)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="type">int</span> sz = cnt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> mn = <span class="number">1e9</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">min</span>(i, sz); j++) &#123;</span><br><span class="line">                r += <span class="built_in">min</span>(cnt[j].second, n / i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n - r &lt; mn) &#123;</span><br><span class="line">                mn = n - r;</span><br><span class="line">                p = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; mn &lt;&lt; endl;</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(sz, p); i++)</span><br><span class="line">        v[cnt[i].first];</span><br><span class="line">    <span class="keyword">if</span> (p &gt; sz) &#123;</span><br><span class="line">        <span class="type">int</span> t = sz;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!v.<span class="built_in">count</span>(i))</span><br><span class="line">                v[i], t++;</span><br><span class="line">            <span class="keyword">if</span> (t == p)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (auto [i, j] : v)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v.<span class="built_in">count</span>(s[i]) &amp;&amp; v[s[i]] &lt; n / p) &#123;</span><br><span class="line">            v[s[i]]++;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; vis[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="keyword">if</span> (vis[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y &lt; n / p) &#123;</span><br><span class="line">                s[i] = x;</span><br><span class="line">                v[x]++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Many-Perfect-Squares"><a href="#D-Many-Perfect-Squares" class="headerlink" title="D. Many Perfect Squares"></a>D. Many Perfect Squares</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出n个不同的升序排序的数（n≤50），如果给这n个数都加一个正整数使得n个数中平方数最多，最多是多少。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>对于任意两个数$a_i$和$a_j$，$i&lt;j$。考虑所有的非负整数k，使得这两个数加上k成为平方数。</p>
<p>设$p^2 = a_i+k$，$q^2 = a_j + k$</p>
<p>$q^2 - p^2 = (q-p)(q+p) = a_j-a_i$</p>
<p>设$x = q-p$，$y = q + p$。</p>
<p>$q = \frac{x+y}{2}$，若$q^2-a_j$非负便找到了一个满足的k。</p>
<p>用哈希表记录每个k的能使$a_i+k$成为平方数的$a_i$的个数</p>
<p>最后哈希表中最大集合的大小就是答案。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 55</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;ll, set&lt;ll&gt;&gt; mp;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            ll v = a[j] - a[i];</span><br><span class="line">            <span class="keyword">for</span> (ll x = <span class="number">1</span>; x * x &lt;= v; x++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v % x)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                ll y = v / x;</span><br><span class="line">                <span class="keyword">if</span> ((x + y) % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; a[j] &lt;= (x + y) / <span class="number">2</span> * (x + y) / <span class="number">2</span>) &#123;</span><br><span class="line">                    mp[(x + y) / <span class="number">2</span> * (x + y) / <span class="number">2</span> - a[j]].<span class="built_in">insert</span>(a[i]);</span><br><span class="line">                    mp[(x + y) / <span class="number">2</span> * (x + y) / <span class="number">2</span> - a[j]].<span class="built_in">insert</span>(a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : mp) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (<span class="type">int</span>)j.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1788</title>
    <url>/2023/05/17/1788/</url>
    <content><![CDATA[<p>Codeforces Round #851 (Div. 2) 1788</p>
<p><a href="https://codeforces.com/contest/1788/problems">Complete problemset</a></p>
<h1 id="A-One-and-Two"><a href="#A-One-and-Two" class="headerlink" title="A. One and Two"></a>A. One and Two</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个只由1和2组成的数组，问能否找到k使得a[1:k]的乘积等于a[k+1:n]的乘积。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>统计2的个数c，若为奇数则无解。</p>
<p>否则找到第一个满足a[1:k]中2个数等于c/2的位置k。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">count</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (c % <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p += a[i] == <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == c / <span class="number">2</span>) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Sum-of-Two-Numbers"><a href="#B-Sum-of-Two-Numbers" class="headerlink" title="B. Sum of Two Numbers"></a>B. Sum of Two Numbers</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>寻找两个数a，b使得a+b=n</p>
<p>且cnt(a) 与cnt(b)的差值不超过1</p>
<p>cnt(a)为a的十进制各个位之和</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>设$x = \lfloor \frac{n}{2} \rfloor$，$y = \lceil \frac{n}{2} \rceil$</p>
<p>一种特殊情况就是x低位是连续的9，y的低位是连续的0.</p>
<p>我们将9拆成5和4分配到x和y对应位上。保证差值不超过1</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cnt</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll rt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        rt += x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll a = n / <span class="number">2</span>, b = n - n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(<span class="built_in">cnt</span>(a) - <span class="built_in">cnt</span>(b)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string sa = <span class="built_in">to_string</span>(a), sb = <span class="built_in">to_string</span>(b);</span><br><span class="line">    <span class="type">int</span> sz = sa.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(sa.<span class="built_in">begin</span>(), sa.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(sb.<span class="built_in">begin</span>(), sb.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, c = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sa[i] == <span class="string">&#x27;9&#x27;</span> &amp;&amp; sb[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c % <span class="number">2</span>) &#123;</span><br><span class="line">                sa[i] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">                sb[i] = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sa[i] = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">                sb[i] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(sa.<span class="built_in">begin</span>(), sa.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(sb.<span class="built_in">begin</span>(), sb.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; sa &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sb &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Matching-Numbers"><a href="#C-Matching-Numbers" class="headerlink" title="C. Matching Numbers"></a>C. Matching Numbers</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>1到2n共2n个数，能否两两相加形成n个数，且n个数构成公差为1的等差数列。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>设构成的n个数起始为a，结束于b</p>
<p>则有</p>
<p>b-a=n-1</p>
<p>(1+2n)*2n/2 = (a+b)n/2</p>
<p>得a=(3+3n)/2</p>
<p>找规律构造即可：区分偶数和奇数。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">3</span> + <span class="number">3</span> * n) % <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> s = (<span class="number">3</span> + <span class="number">3</span> * n) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s - i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s - i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Moving-Dots"><a href="#D-Moving-Dots" class="headerlink" title="D. Moving Dots"></a>D. Moving Dots</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出数轴上的n个点，每个点会朝向离自己最近的点移动，如果两侧的点离自己同样远，则朝左移动。当两个点相遇则停止。</p>
<p>求最后所有点都停止后，停止点的个数。</p>
<p>这个问题很简单。</p>
<p>所以现在问n个点的所有大于2的子集所有停止位置个数之和。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>同一个停止位置可能在多个子集中出现过。</p>
<p>考虑任意两个相向运动的x，y（x&lt;y）的停止位置在多少个子集中出现过。</p>
<p>设d=y-x，所有小于x-d的点个数为cntl，所有大于等于y+d的点个数为cntr</p>
<p>x和y相遇停止的点的贡献为$2^{cntl}*2^{cntr}$</p>
<p>枚举x和y，二分法可找出cntl和cntr</p>
<p>时间复杂度$O(n^2logn)$</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll p[N];</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * <span class="number">2</span> % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            ll d = a[j] - a[i];</span><br><span class="line">            ll lcnt = <span class="built_in">lower_bound</span>(a, a + n, a[i] - d) - a;</span><br><span class="line">            ll rcnt = n - (<span class="built_in">lower_bound</span>(a, a + n, a[j] + d) - a);</span><br><span class="line">            ans += p[lcnt] * p[rcnt] % MOD;</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Sum-Over-Zero"><a href="#E-Sum-Over-Zero" class="headerlink" title="E. Sum Over Zero"></a>E. Sum Over Zero</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给出一个长度为n的数组a，现在要选取若干不相交的区间且区间和不小于0，使得所有区间的长度之和最大。</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>dp</p>
<p>设$f_i$为前i个数中选取若干区间且区间和不小于0，的区间最大值。</p>
<p>$f_0 = 0$</p>
<p>对于$f_i$的求解考虑最后一个区间包不包含$a_i$</p>
<p>若不含$a_i$，则$f_i$由$f_{i-1}$转移</p>
<p>若包含$a_i$，则需要找到sum(a[j…i])≥0的所有j，$f_i$由最大的$f_j+i-j$转移。</p>
<p>设$p_i$为前i个数之和。$p_0 = 0, p_i = p_{i-1}+a_i,i&gt;0$</p>
<p>状态转移方程$f_0 = 0, f_i = \max(f_{i-1}, \max \limits_{p_j\le p_i} (f_j+i-j)),i&gt;0$</p>
<p>可以离散化前缀和数组，然后用线段树或树状数组维护$f_i-i$</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINF 0xf3f3f3f3f3f3f3f3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll p[N], f[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll mx = NINF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= i &amp; -i) &#123;</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; N; i += i &amp; -i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">max</span>(a[i], val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0xf3</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    map&lt;ll, <span class="type">int</span>&gt; idx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        p[i] += p[i - <span class="number">1</span>];</span><br><span class="line">        idx[p[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    idx[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> sz = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i, j] : idx)</span><br><span class="line">        j = sz++;</span><br><span class="line">    <span class="built_in">add</span>(idx[<span class="number">0</span>], <span class="number">0</span>);  <span class="comment">// add(idx[p[0]], f[0]-0);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = <span class="built_in">max</span>(f[i - <span class="number">1</span>], <span class="built_in">ask</span>(idx[p[i]]) + i);</span><br><span class="line">        <span class="built_in">add</span>(idx[p[i]], f[i] - i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1790</title>
    <url>/2023/05/17/1790/</url>
    <content><![CDATA[<p>Codeforces Round #847 (Div. 3) 1790</p>
<p><a href="https://codeforces.com/contest/1790/problems">Complete problemset</a></p>
<h1 id="A-Polycarp-and-the-Day-of-Pi"><a href="#A-Polycarp-and-the-Day-of-Pi" class="headerlink" title="A. Polycarp and the Day of Pi"></a>A. Polycarp and the Day of Pi</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>判断字符串s（s.lenght ≤ 30）前缀有多少位是圆周率</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接比较</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string pi = <span class="string">&quot;314159265358979323846264338327&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pi[i] == s[i])</span><br><span class="line">            cnt++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Taisia-and-Dice"><a href="#B-Taisia-and-Dice" class="headerlink" title="B. Taisia and Dice"></a>B. Taisia and Dice</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>有n个六面色子，构造出总点数位s，去除一个最大点数后总点数位r的投掷点数序列</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>一个点数位s-r，剩余n-1个可以尽可能平均分配，每个至少为$\frac{r}{n-1}$，再将$r%(n-1)$个点数+1以分配余数。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, s, r;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; s - r;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (r / n + (i &lt; r % n ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Premutation"><a href="#C-Premutation" class="headerlink" title="C. Premutation"></a>C. Premutation</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>有一个长度为n的排列，给出n个长度为n-1的序列，每个序列由删除了排列中的一个数构成。这n个序列是互不相同的，也就是说每个删除的数都不同。求原来的排列。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>对应第一个给出的序列可以找出缺失的数x。</p>
<p>然后对于剩余的n-1个序列，我们找出由多少个数t在x的左侧。</p>
<p>然后在第一个序列的p位置插入即可。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span>, a</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        v[x]++;</span><br><span class="line">        a.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!v[i])</span><br><span class="line">            p = i;</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (x == p)</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                st.<span class="built_in">insert</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>() + st.<span class="built_in">size</span>(), p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a)</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Matryoshkas"><a href="#D-Matryoshkas" class="headerlink" title="D. Matryoshkas"></a>D. Matryoshkas</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出一个长度为n的数组。</p>
<p>定义相邻结合为集合中的数字都是相邻的。</p>
<p>问将n个数分成相邻集合的最少个数</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>统计每个数出现的次数，并将出现的数升序排序。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        mp[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(mp.<span class="built_in">begin</span>(), mp.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = v.<span class="built_in">back</span>().second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i - <span class="number">1</span>].first + <span class="number">1</span> &lt; v[i].first) &#123;</span><br><span class="line">            ans += v[i - <span class="number">1</span>].second;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v[i - <span class="number">1</span>].second &gt; v[i].second) &#123;</span><br><span class="line">            ans += v[i - <span class="number">1</span>].second - v[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Vlad-and-a-Pair-of-Numbers"><a href="#E-Vlad-and-a-Pair-of-Numbers" class="headerlink" title="E. Vlad and a Pair of Numbers"></a>E. Vlad and a Pair of Numbers</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给出$a\oplus b$，求a和b使得$a \oplus b = \frac{a+b}{2}$，没有答案则输出-1</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>显然$a\oplus b$是偶数。</p>
<p>对于$a\oplus b$中第i位为1，则a或b的第i位为1，不妨设a的第i位为1，b的第i位为0。</p>
<p>对于$a\oplus b$中第i位为0，则a和b的第i位都为1或0，要让$a \oplus b = \frac{a+b}{2}$，必然$a\oplus b$为1的位低一位为0，即$a\oplus b$的第i位为1则第i-1位为0。否则没有答案。</p>
<p>所以答案就是$\frac{a\oplus b}{2}|a\oplus b$和$\frac{a\oplus b}{2}$</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ll a = 0, b = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">33</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;&gt; (i - <span class="number">1</span>) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// a |= 1 &lt;&lt; (i - 1);</span></span><br><span class="line">            <span class="comment">// a |= 1 &lt;&lt; i;</span></span><br><span class="line">            <span class="comment">// b |= 1 &lt;&lt; (i - 1);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    cout &lt;&lt; (x &gt;&gt; <span class="number">1</span> | x) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (x &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="F-Timofey-and-Black-White-Tree"><a href="#F-Timofey-and-Black-White-Tree" class="headerlink" title="F. Timofey and Black-White Tree"></a>F. Timofey and Black-White Tree</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给出一颗树，树中节点初始一个节点为黑色，其余为白色。</p>
<p>接下来有n-1次染色操作，每次让一个节点染为黑色。</p>
<p>求每次染色操作后所有染色节点中距离最短的两个节点的距离。</p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>若第i次染色后最短距离为mn，那么第i+1次染色距离不会大于mn。</p>
<p>我们考虑一种极端情况——一条链。</p>
<p>最坏的情况，经过$O(\sqrt n)$次染色后，最短距离为$O(\sqrt n)$。</p>
<p>我们可以每次对于新的染色做bfs，在范围超过mn时剪枝。</p>
<p>我们粗略的估计，认为前$O(\sqrt n)$次是作的完整的广搜，广搜复杂度为$O(n)$，剩余$O(n-\sqrt n)$次的广搜复杂度为$O(\sqrt n)$，总时间复杂度是$O(n \sqrt n)$</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span>, <span class="title">dis</span><span class="params">(n + <span class="number">1</span>, INF)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        g[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = INF + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(c[i]);</span><br><span class="line">        vis[c[i]] = <span class="number">1</span>;</span><br><span class="line">        dis[c[i]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (dis[u] &gt;= ans)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : g[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[x] &gt; dis[u] + <span class="number">1</span>) &#123;</span><br><span class="line">                    vis[x] = <span class="number">1</span>;</span><br><span class="line">                    dis[x] = dis[u] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(x);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!vis[x]) &#123;</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, dis[u] + <span class="number">1</span> + dis[x]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="G-Tokens-on-Graph"><a href="#G-Tokens-on-Graph" class="headerlink" title="G. Tokens on Graph"></a>G. Tokens on Graph</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>给出一个图，图中有不可动的bonus点，和可以移动的token点。在初始时bonus之间没有重叠，token之间也没有重叠。但bonus和token之间可以重叠。另外token移动后token之间可以重叠。</p>
<p>现在移动的规则是：</p>
<p>选择一个token移动到相邻节点，当移动后的位置是bonus则可以选择另一个其他token节点移动。</p>
<p>问是否存在一个token可以移动到1号节点。</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>如果存在token和1号重叠或者在1号相邻位置，则答案是YES。</p>
<p>如果不相邻且不重叠。考虑一个token点v可以移动到1号，那么至少在v号和1号之间（不包含）的节点应该都是bonus。每当v移动一步，需要其他token节点移动1步到bonus，然后再让v移动。。。以此类推。我们可以通过广搜找出这些token点。</p>
<p>现在考虑每个token节点u可以移动到bonus的次数stp[u]。如果某个token节点没有bonus相邻则没有移动次数；如果与一个bonus连通块相邻（重叠不行），若连通块大小为1，则可以移动的的次数是1次，否则可以移动无数次。</p>
<p>对于我们用广搜找出的有机会到达1号节点的token，枚举是否可达一号。若枚举的节点为v，sum(stp)-stp[v]则为非v的其他token节点可移动到bonus的次数，由于我们可以让v先移动，所以让其余token点移动<code>v到1的最短路径-1</code>次则有答案输出YES。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> T[N], B[N];</span><br><span class="line"><span class="type">int</span> n, m, p, q;</span><br><span class="line">map&lt;<span class="type">int</span>, ll&gt; stp;  <span class="comment">// stp[i] 编号为i的token可以操控的次数0，1，INF</span></span><br><span class="line"><span class="type">int</span> dis[N];        <span class="comment">// dis[i] 编号为i的token到1节点的距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[x] &gt; dis[u] + <span class="number">1</span>) &#123;</span><br><span class="line">            dis[x] = dis[u] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (B[x])</span><br><span class="line">                <span class="built_in">dfs</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    stp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        g[i].<span class="built_in">clear</span>();</span><br><span class="line">        T[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">        dis[i] = N;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        T[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        B[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">1</span>]) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : g[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[x]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i]) &#123;</span><br><span class="line">            ll con = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : g[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (B[x])</span><br><span class="line">                    con = N;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if (T[i]) 傻逼了，草。。。若i的bouns连通块为1，没有可行步数。</span></span><br><span class="line">            <span class="comment">//     stp[i] = max(stp[i], con);</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : g[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (T[x])</span><br><span class="line">                    stp[x] = <span class="built_in">max</span>(stp[x], con);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    ll s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i, j] : stp)</span><br><span class="line">        s += j;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[i] == N || !T[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (s - stp[i] &gt;= dis[i] - <span class="number">1</span>) &#123;  <span class="comment">// i先行，其余只需dis[i]-1步</span></span><br><span class="line">            ok = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ok ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1792D Fixed Prefix Permutations</title>
    <url>/2023/06/06/1792D/</url>
    <content><![CDATA[<h1 id="Fixed-Prefix-Permutations"><a href="#Fixed-Prefix-Permutations" class="headerlink" title="Fixed Prefix Permutations"></a>Fixed Prefix Permutations</h1><p>Created by LXC on Fri Jun  2 10:11:40 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1792/D">https://codeforces.com/problemset/problem/1792/D</a></p>
<p>ranting: 1700</p>
<p>tag: binary search, bitmasks, data structures, hashing, math, sortings</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>给出n个排列，每个排列的长度为m（m&lt;10）。</p>
<p>定义排列的乘法，排列a与排列b相乘得到排列r，即$a\cdot b= r$，其中$r_j = b_{a_{j}}$</p>
<p>定义排列的美丽值，当排列r的美丽值为k，那么$a_{1} = 1, a_{2} = 2, \cdots, a_{k} = k, a_{k+1} \ne k+1$。当$a_{1} \ne 1$时美丽值为0</p>
<p>现在需要输出当i在1到n时，$a_i\cdot a_j, (1\le j\le n)$的最大美丽值。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>由于$a_i\cdot a_j= r$，那么$a_i = r\cdot a_j^{-1}$。</p>
<p>当$r$的美丽值为$k$时，$a_i$与$a_j^{-1}$的前k个数是相等的。</p>
<p>我们可以先将每个排列的逆求出。然后存入能快速查询的数据结构——前缀树。对于每个$a_i$只需在前缀树中寻找最长前缀便是答案。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGMA 11</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="type">int</span> tr[MAXN][SIGMA];  <span class="comment">// 数组存储Trie树节点,下标起到指针作用</span></span><br><span class="line">    <span class="type">int</span> sz;               <span class="comment">// Trie中当前节点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tr[<span class="number">0</span>], <span class="number">0</span>, <span class="built_in">sizeof</span>(tr[<span class="number">0</span>]));</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>(), u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tr[u][s[i]] == <span class="number">0</span>) &#123;  <span class="comment">// 不存在新开就一个节点</span></span><br><span class="line">                tr[u][s[i]] = sz;</span><br><span class="line">                <span class="built_in">memset</span>(tr[sz], <span class="number">0</span>, <span class="built_in">sizeof</span>(tr[sz]));</span><br><span class="line">                sz++;</span><br><span class="line">            &#125;</span><br><span class="line">            u = tr[u][s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>(), u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tr[u][s[i]] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            u = tr[u][s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][<span class="number">11</span>];</span><br><span class="line">Trie trie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    trie.<span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; j : i)</span><br><span class="line">            cin &gt;&gt; j, j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : a) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            b[i[j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        trie.<span class="built_in">insert</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : a) &#123;</span><br><span class="line">        cout &lt;&lt; trie.<span class="built_in">query</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>data structures</tag>
        <tag>math</tag>
        <tag>binary search</tag>
        <tag>sortings</tag>
        <tag>bitmasks</tag>
        <tag>hashing</tag>
      </tags>
  </entry>
  <entry>
    <title>1793</title>
    <url>/2023/05/17/1793/</url>
    <content><![CDATA[<p>Codeforces Round #852 (Div. 2) 1793</p>
<p><a href="https://codeforces.com/contest/1793/problems">Complete problemset</a></p>
<h1 id="A-Yet-Another-Promotion"><a href="#A-Yet-Another-Promotion" class="headerlink" title="A. Yet Another Promotion"></a>A. Yet Another Promotion</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在需要买至少n斤土豆，有a元每斤和b元每斤两种不同单价的土豆。</p>
<p>其中每买m斤a元每斤就送一斤。</p>
<p>问需要的最小金额是多少。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果$a\le b$，显然选择a更优，花费为$(n-n/(m+1))*a$</p>
<p>否则$a&gt;b$, 两种不同的单价的土豆在买$m+1$斤分别的花费是$m<em>a$和$(m+1)b$，我们选择较小者。剩余n%(m+1)则买b。花费$min(m</em>a, (m+1)b)*n/(m+1) + n%(m+1)b$</p>
<p>因此答案为$min((n-n/(m+1))<em>a, min(m</em>a, (m+1)b)*n/(m+1) + n%(m+1)b)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, b, n, m;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>((n - n / (m + <span class="number">1</span>)) * a,</span><br><span class="line">                n / (m + <span class="number">1</span>) * <span class="built_in">min</span>(m * a, (m + <span class="number">1</span>) * b) + n % (m + <span class="number">1</span>) * b)</span><br><span class="line">         &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// if (a &lt;= b) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; n * a - n / (m + 1) * a &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125; else if (m * (a - b) &lt; b) &#123;</span></span><br><span class="line">    <span class="comment">//     ll ca = n / (m + 1) * (m + 1), cb = n - ca;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; ca * a - ca / (m + 1) * a + cb * b &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; n * b &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Fedya-and-Array"><a href="#B-Fedya-and-Array" class="headerlink" title="B. Fedya and Array"></a>B. Fedya and Array</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>构造一个最短的数组，使得环形数组中相邻元素之差为1，数组中最大值是x，最小值是y。</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>长度2(x-y)，从x到y再到x即可。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> * (x - y) &lt;&lt; endl;</span><br><span class="line">    ll u = x;</span><br><span class="line">    <span class="keyword">for</span> (ll i = x; i &gt;= y; i--) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = y + <span class="number">1</span>; i &lt;= x - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Dora-and-Search"><a href="#C-Dora-and-Search" class="headerlink" title="C. Dora and Search"></a>C. Dora and Search</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组，找到一个区间<code>[l,r]</code> 使得l和r位置不是最大值和最小值。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>双指针，左右指针分别指向起始和末尾，当有指针为最大或最小值时则移动，左指针向右移动，右指针向左移动。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> mn = <span class="number">1</span>, mx = n, l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r &amp;&amp; (a[l] == mn || a[l] == mx || a[r] == mn || a[r] == mx)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[l] == mn)</span><br><span class="line">            mn++, l++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[l] == mx)</span><br><span class="line">            mx--, l++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[r] == mn)</span><br><span class="line">            mn++, r--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[r] == mx)</span><br><span class="line">            mx--, r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l != r) &#123;</span><br><span class="line">        cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Moscow-Gorillas"><a href="#D-Moscow-Gorillas" class="headerlink" title="D. Moscow Gorillas"></a>D. Moscow Gorillas</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出两个数组，问有多少个区间的mex相同。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>一个区间只要包含了1到n的最小区间那么这个区间的MEX至少为n。利用这一点，一个区间只要包含了1到n+1的最小区间那么这个区间的MEX至少为n+1，由此包含了1到n的最小区间但是没有包含1到n+1的最小区间，就得到了MEX恰好为n的区间数。</p>
<p>对两个数组相同的MEX值区间范围求交集。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span>, <span class="title">q</span><span class="params">(n)</span>, <span class="title">wp</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">wq</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        wp[p[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">        wq[q[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll l1 = <span class="built_in">min</span>(wp[<span class="number">1</span>], wq[<span class="number">1</span>]), r1 = <span class="built_in">max</span>(wp[<span class="number">1</span>], wq[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">auto</span> cpt = [](ll x) -&gt; ll &#123; <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span>; &#125;;</span><br><span class="line">    ll ans = <span class="built_in">cpt</span>(l1) + <span class="built_in">cpt</span>(n - r1 - <span class="number">1</span>) + <span class="built_in">cpt</span>(<span class="built_in">max</span>(r1 - l1 - <span class="number">1</span>, <span class="number">0LL</span>)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            a.<span class="built_in">emplace_back</span>(wp[i], wp[i]);</span><br><span class="line">            b.<span class="built_in">emplace_back</span>(wq[i], wq[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x1, y1] = a.<span class="built_in">back</span>();</span><br><span class="line">            a.<span class="built_in">emplace_back</span>(<span class="built_in">min</span>(x1, wp[i]), <span class="built_in">max</span>(y1, wp[i]));</span><br><span class="line">            <span class="keyword">auto</span> [x2, y2] = b.<span class="built_in">back</span>();</span><br><span class="line">            b.<span class="built_in">emplace_back</span>(<span class="built_in">min</span>(x2, wq[i]), <span class="built_in">max</span>(y2, wq[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// auto [x1, y1] = a[i - 1];</span></span><br><span class="line">        <span class="comment">// auto [x2, y2] = a[i];</span></span><br><span class="line">        <span class="comment">// auto [x3, y3] = b[i - 1];</span></span><br><span class="line">        <span class="comment">// auto [x4, y4] = b[i];</span></span><br><span class="line">        <span class="type">int</span> la = a[i - <span class="number">1</span>].first, ra = a[i - <span class="number">1</span>].second;</span><br><span class="line">        <span class="type">int</span> lla = a[i].first, rra = a[i].second;</span><br><span class="line">        <span class="keyword">if</span> (lla &lt; la) &#123;</span><br><span class="line">            <span class="comment">// lla++;</span></span><br><span class="line">            <span class="comment">// rra = n - 1;</span></span><br><span class="line">            rra = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// rra--;</span></span><br><span class="line">            <span class="comment">// lla = 0;</span></span><br><span class="line">            lla = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lb = b[i - <span class="number">1</span>].first, rb = b[i - <span class="number">1</span>].second;</span><br><span class="line">        <span class="type">int</span> llb = b[i].first, rrb = b[i].second;</span><br><span class="line">        <span class="keyword">if</span> (llb &lt; lb) &#123;</span><br><span class="line">            <span class="comment">// llb++;</span></span><br><span class="line">            <span class="comment">// rrb = n - 1;</span></span><br><span class="line">            rrb = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// rrb--;</span></span><br><span class="line">            <span class="comment">// llb = 0;</span></span><br><span class="line">            llb = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll lcnt = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(la, lb) - <span class="built_in">max</span>(lla, llb));</span><br><span class="line">        ll rcnt = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(rra, rrb) - <span class="built_in">max</span>(ra, rb));</span><br><span class="line">        ans += lcnt * rcnt;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 856 (Div. 2) 1794</title>
    <url>/2023/05/17/1794/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-856-Div-2-1794"><a href="#Codeforces-Round-856-Div-2-1794" class="headerlink" title="Codeforces Round 856 (Div. 2) 1794"></a>Codeforces Round 856 (Div. 2) 1794</h1><p><a href="https://codeforces.com/contest/1794/problems">Complete problemset</a></p>
<h2 id="A-Prefix-and-Suffix-Array"><a href="#A-Prefix-and-Suffix-Array" class="headerlink" title="A. Prefix and Suffix Array"></a>A. Prefix and Suffix Array</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一个长度为n的字符串，给出n-1个前缀和n-1个后缀，判断该串是否回文</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于长度相同的两个串反转其中一串，两个串应该相同。若存在不相同则不是回文串。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(<span class="number">2</span> * n - <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(),</span><br><span class="line">         [&amp;](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>(); &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s[i].<span class="built_in">begin</span>(), s[i].<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Not-Dividing"><a href="#B-Not-Dividing" class="headerlink" title="B. Not Dividing"></a>B. Not Dividing</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个长度为n的数组a，$1≤a_i$，最多操作2n次使得$a_{i+1}$不能被$a_{i}$整除</p>
<p>每次操作可以让其中一个数增加1.</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>如果有一个数是1，那么任何数都被它整除。</p>
<p>所以我们让所有数都增长1，花费操作n次</p>
<p>接下来对于$a_{i+1}%a_{i}=0$，让$a_{i+1}++$。由于$a_i&gt;1$，$a_{i+1}%a_{i}=1$，保证不被整除。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] % a[i - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            a[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Scoring-Subsequences"><a href="#C-Scoring-Subsequences" class="headerlink" title="C. Scoring Subsequences"></a>C. Scoring Subsequences</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出一个升序的数组a，对于$[a_1,a_2,\dots,a_n]$的<strong>分数</strong>定义为$\frac{a_1<em>a_2</em>a_3*\cdots *a_n}{n!}$。我们定义一个序列的<strong>花费</strong>为该序列<strong>所有子序列中</strong>的<strong>最大分数</strong>的序列长度。</p>
<p>求每个a每个前缀的<strong>花费</strong>。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>对于子序列的选取肯定是选最大的几个数才能让分数尽可能的大。所以如果随着后缀的增长，分数没有减小那么优先选择这个后缀。</p>
<p>举个例子，不妨现在有个序列$[a_1, a_2, a_3, a_4,a_5]$，如果他的花费是3，由于序列升序缘故，最大分数应该是$\frac{a_3 * a_4 * a_5}{1<em>2</em>3}$，且满足$\frac{a_3 * a_4 * a_5}{1<em>2</em>3}≥\frac{a_4 * a_5}{1*2} ≥ \frac{a_5}{1}$。</p>
<p>其实也就是对于$[a_1,a_2,\dots,a_n]$，如果$\frac{a_i}{n-i+1}≥1$，那么这个序列的花费就至少是n-i+1。所以可以用二分法找到从右到左第一个l使得$\frac{a_l}{n-l+1}=0$。那么这个序列的花费就是n-l。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = i;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> m = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[m] / (i - m + <span class="number">1</span>)) &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; l &lt;&lt; endl;</span></span><br><span class="line">        b[i] = i - l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-Counting-Factorizations"><a href="#D-Counting-Factorizations" class="headerlink" title="D. Counting Factorizations"></a>D. Counting Factorizations</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>一个正整数m可以被质数的幂次表示，$m=p_1^{e1}⋅p_2^{e_2}⋅…⋅p_n^{e_n}$</p>
<p>给出一个含2n个数的可重集合求这个集合可以组合表示的m有多少个。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我们将2n个数分类为质数和质数，有由于每种数可能出现多个。</p>
<p>设$a_i$为第i个出现的非质数的出现次数，设a共有t个。</p>
<p>设$b_i$为第i个出现的质数的出现次数，设b共有s个。</p>
<p>显然我们需要选出n个不同的质数作为底数。所以当s &lt; n则答案为0.</p>
<p>当我们选了n个数作为底数，接下来剩余的n个数可以作为指数，指数中有重复所以需要做多重全排列$\frac{n!}{a_1!a_2!\cdots a_t!b_1’!b_2’!\cdots b_s’!}$，作为本次选取n个数的计数。当本次选择了第i个质数，则$b_i’=b_i-1$，否则$b_i’=b_i$</p>
<p>选取n个数的选法有$C_s^n$种。感觉很复杂。</p>
<p>我们可以用dp，设在$[1,\cdots,x]$中选取y个数，考虑第x个质数选与不选。</p>
<p>$f_{x,y} = \frac{f_{x-1, y-1}}{(b_x-1)!}+\frac{f_{x-1, y}}{b_x!}$</p>
<p>答案为$f_{s, n}\frac{n!}{a_1!a_2!\cdots a_t!}$</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll fac[<span class="number">5000</span>], inv_fac[<span class="number">5000</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a, b;</span><br><span class="line"><span class="type">bool</span> nprime[N];</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">5000</span>][<span class="number">5000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll rt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            rt = rt * x % MOD;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(nprime, <span class="number">0</span>, <span class="built_in">sizeof</span>(nprime));</span><br><span class="line">    nprime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> n = (<span class="type">int</span>)<span class="built_in">sqrt</span>(N + <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nprime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt; N; j += i) &#123;</span><br><span class="line">                nprime[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;  <span class="comment">// [0...x]中选y个, 考虑x选不选</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (y == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f[x][y] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> f[x][y];</span><br><span class="line">    f[x][y] = <span class="built_in">dfs</span>(x - <span class="number">1</span>, y) * inv_fac[b[x]] % MOD;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        f[x][y] += <span class="built_in">dfs</span>(x - <span class="number">1</span>, y - <span class="number">1</span>) * inv_fac[b[x] - <span class="number">1</span>] % MOD;</span><br><span class="line">        f[x][y] %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;=&quot; &lt;&lt; f[x][y] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> f[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">get_prime</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p, np;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (nprime[x]) &#123;</span><br><span class="line">            np[x]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">size</span>() &lt; n) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : np) &#123;</span><br><span class="line">        a.<span class="built_in">push_back</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : p) &#123;</span><br><span class="line">        b.<span class="built_in">push_back</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">    inv_fac[<span class="number">2</span> * n] = <span class="built_in">fpow</span>(fac[<span class="number">2</span> * n], MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        inv_fac[i - <span class="number">1</span>] = inv_fac[i] * i % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= b.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            f[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; dfs(b.size() - 1, n) &lt;&lt; endl;</span></span><br><span class="line">    ll ans = fac[n] * <span class="built_in">dfs</span>(b.<span class="built_in">size</span>() - <span class="number">1</span>, n) % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        ans = ans * inv_fac[a[i]] % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-Labeling-the-Tree-with-Distances"><a href="#E-Labeling-the-Tree-with-Distances" class="headerlink" title="E. Labeling the Tree with Distances"></a>E. Labeling the Tree with Distances</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给出一颗n个节点的无根树，然后给出一个长度为n-1的数组，将数组中的数标记到树中的节点上，每个节点只能标记一次，最后有一个节点没有标记。</p>
<p>现在要找到所有的好节点。好节点就是所有有标记的节点到这个好节点的距离恰好就是标记的值。距离就是这个两个节点之间的最短路的边数。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>todo</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">todo</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1795</title>
    <url>/2023/05/17/1795/</url>
    <content><![CDATA[<p>Educational Codeforces Round 143 (Rated for Div. 2) 1795</p>
<p><a href="https://codeforces.com/contest/1795/problems">Complete problemset</a></p>
<h1 id="A-Two-Towers"><a href="#A-Two-Towers" class="headerlink" title="A. Two Towers"></a>A. Two Towers</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出两数组，每个数组只有两种值，我们可以移动一个数组的末尾元素到另一个数组的末尾。能否通过移动让每个数组相邻元素不同。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们将数组合并，然后枚举分割点即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(a.<span class="built_in">substr</span>(<span class="number">0</span>, i)) &amp;&amp; <span class="built_in">check</span>(a.<span class="built_in">substr</span>(i))) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Ideal-Point"><a href="#B-Ideal-Point" class="headerlink" title="B. Ideal Point"></a>B. Ideal Point</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>对于多段线段覆盖得最多的点称为ideal point，问能否通过删除一些边让k成为ideal point。</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>如果线段覆盖k，则不删除。最后检测k是否为ideal point</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">51</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= k &amp;&amp; k &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">                a[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == k)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= a[k]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Tea-Tasting"><a href="#C-Tea-Tasting" class="headerlink" title="C. Tea Tasting"></a>C. Tea Tasting</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>n个人喝n种茶，前i-1个人喝完茶后，第i个人会喝前i种茶，设$a_i$是第i种茶剩余的量，$b_i$是第i个人每次能喝茶的量，第i个人喝第j种茶喝的量是$min(b_i, a_i)$，问每个人喝了多少茶。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>考虑每一种茶对多少人有多少贡献。</p>
<p>第i种茶只会对第i个人及之后有贡献。</p>
<p>每个人i的贡献最多是$b_i$，不足则将剩余茶作为贡献。</p>
<p>我们如果枚举每个人，效率低下，可以求出前缀数组，二分查找，找到最后一个贡献的人。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll a[N], b[N], d[N], o[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = b[i] = d[i] = o[i] = ans[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        b[i] += b[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lower_bound</span>(b, b + n + <span class="number">1</span>, a[i] + b[i - <span class="number">1</span>]) - b;</span><br><span class="line">        d[i]++;</span><br><span class="line">        d[p]--;</span><br><span class="line">        o[p] += a[i] - b[p - <span class="number">1</span>] + b[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; b[p - 1] - b[i - 1] &lt;&lt; &quot; op: &quot; &lt;&lt;</span></span><br><span class="line">        <span class="comment">// o[p]</span></span><br><span class="line">        <span class="comment">//      &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot; d\n&quot;;</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; o[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot; o\n&quot;;</span></span><br><span class="line">    ll pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pre += d[i];</span><br><span class="line">        cout &lt;&lt; pre * (b[i] - b[i - <span class="number">1</span>]) + o[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Triangle-Coloring"><a href="#D-Triangle-Coloring" class="headerlink" title="D. Triangle Coloring"></a>D. Triangle Coloring</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>现在又n个点，n是6的倍数，其中1 2 3为1组，4 5 6为1组，。。。，每组内点之间都有有权边相连。现在需要将这n个点一遍染成红色，一遍染成蓝色，然后我们选取连接不同颜色的边，求有多少种染色方式使得所有选取的边权和最大。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>当一组中的三个点是同一种颜色，那么没有任何边会选取。</p>
<p>所以为了边权最大，三个点应该有两种颜色，这势必有两个点颜色一样。也就是说三条边会选择两条边，我们应该选择最大的两条。选择这两条边的涂色方式有两种——两红一蓝或两蓝一红。</p>
<p>在同一种涂色的情况下，不妨设是两红一蓝，三条边边权都一样，就有三种涂法，否则两条较短边边权一样就有两种涂法，其余就一种涂法。</p>
<p>我们注意如果有两蓝一红的涂色，由于一半蓝和一半红的约束，一定有对应的一组是两红一蓝。</p>
<p>所以有一半的组是两蓝一红的涂色，有一半的组是两红一蓝的涂色。在n/3个组中选一半涂一种另一种涂剩余的，组合数$C_{\frac{n}{3}}^{\frac{n}{6}}$</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[<span class="number">3</span>];</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;  <span class="comment">// n个里选m个</span></span><br><span class="line">    ll inv[n + <span class="number">1</span>];</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    ll rt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        rt = rt * (n - i + <span class="number">1</span>) % MOD * inv[i] % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            cin &gt;&gt; v[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v, v + <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (v[<span class="number">0</span>] == v[<span class="number">1</span>] &amp;&amp; v[<span class="number">0</span>] == v[<span class="number">2</span>]) &#123;</span><br><span class="line">            ans *= <span class="number">3</span>;</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v[<span class="number">1</span>] == v[<span class="number">0</span>]) &#123;</span><br><span class="line">            ans *= <span class="number">2</span>;</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="function">ans * <span class="title">C</span><span class="params">(n / <span class="number">3</span>, n / <span class="number">6</span>)</span> % MOD &lt;&lt; endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1799D1 Hot Start Up (easy version)</title>
    <url>/2023/05/20/1799D1/</url>
    <content><![CDATA[<h1 id="Hot-Start-Up-easy-version"><a href="#Hot-Start-Up-easy-version" class="headerlink" title="Hot Start Up (easy version)"></a>Hot Start Up (easy version)</h1><p>Created by LXC on Fri May 19 19:14:39 2023</p>
<p><a href="https://codeforces.com/problemset/problem/1799/D1">https://codeforces.com/problemset/problem/1799/D1</a></p>
<p>ranting: 1900</p>
<p>tag: dp</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在由k种程序</p>
<p>在一个cpu中如果执行了第$i$种和然后又执行第$i$种程序，则花费$hot_i$时间。否则是$cold_i$时间</p>
<p>现在有一个长度为n的需要执行的程序序列。有两个cpu，两个cpu只能同时运行一个。</p>
<p>运行完所有程序所需要的时间是多少。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑每个程序放置的是哪个cpu，总共有$2^n$种状态，可以考虑关于前缀的子问题。</p>
<p>但是当前的程序放那个cpu，如果cpu跑的程序和当前一样则用的是hot时间，否则是cold时间。<br>所以需要知道每个cpu之前跑的是什么程序，但是两个cpu，共有$O(k^2)$种。再加上当前放置的程序共有$O(nk^2)$种状态。</p>
<p>但是其实不需要记录两个cpu的最近状态，当我们放置第i个程序的时候，第i-1个程序必定在两个cpu中。</p>
<p>所以我们可以这样设状态：</p>
<p>$f_{i,j}$ 在第i个程序放在第一个cpu，且第二个cpu的最近跑的程序是j的情况下，前i个程序的最少运行时间。</p>
<p>$g_{i,j}$ 在第i个程序放在第二个cpu，且第一个cpu的最近跑的程序是j的情况下，前i个程序的最少运行时间。</p>
<p>状态转移</p>
<p>$f_{i,j} =  \left { \begin{array}{ll}\max \limits_{j=0}^{k}f_{i-1,j} + hot_{a_i} &amp; a_i = a_{i-1} \ \max \limits_{j=0}^{k}f_{i-1,j} + cold_{a_i} &amp; a_i \ne a_{i-1} \end{array} \right .$</p>
<p>$f_{i,a_{i-1}} =  \left { \begin{array}{ll}\max \limits_{j=0}^{k}g_{i-1,j} + hot_{a_i} &amp; a_i = j \ \max \limits_{j=0}^{k}g_{i-1,j} + cold_{a_i} &amp; a_i \ne j \end{array} \right .$</p>
<p>$g_{i,j} =  \left { \begin{array}{ll}\max \limits_{j=0}^{k}g_{i-1,j} + hot_{a_i} &amp; a_i = a_{i-1} \ \max \limits_{j=0}^{k}g_{i-1,j} + cold_{a_i} &amp; a_i \ne a_{i-1} \end{array} \right .$</p>
<p>$g_{i,a_{i-1}} =  \left { \begin{array}{ll}\max \limits_{j=0}^{k}f_{i-1,j} + hot_{a_i} &amp; a_i = j \ \max \limits_{j=0}^{k}f_{i-1,j} + cold_{a_i} &amp; a_i \ne j \end{array} \right .$</p>
<p>初始化 $f_{1,0} = g_{1,0} = cold_{a_1}，otherwise\ f_{i,j} = \infin$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll a[N], cold[N], hot[N];</span><br><span class="line">ll f[N][N], g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        cin &gt;&gt; cold[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        cin &gt;&gt; hot[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每组数据都按照最坏的情况初始化 超时</span></span><br><span class="line">    <span class="comment">// memset(f, 0x3f, sizeof(f));</span></span><br><span class="line">    <span class="comment">// memset(g, 0x3f, sizeof(g));</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            g[i][j] = f[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">0</span>] = f[<span class="number">1</span>][<span class="number">0</span>] = cold[a[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            f[i][j] =</span><br><span class="line">                <span class="built_in">min</span>(f[i][j],</span><br><span class="line">                    f[i - <span class="number">1</span>][j] + (a[i] == a[i - <span class="number">1</span>] ? hot[a[i]] : cold[a[i]]));</span><br><span class="line">            f[i][a[i - <span class="number">1</span>]] =</span><br><span class="line">                <span class="built_in">min</span>(f[i][a[i - <span class="number">1</span>]],</span><br><span class="line">                    g[i - <span class="number">1</span>][j] + (a[i] == j ? hot[a[i]] : cold[a[i]]));</span><br><span class="line">            g[i][j] =</span><br><span class="line">                <span class="built_in">min</span>(g[i][j],</span><br><span class="line">                    g[i - <span class="number">1</span>][j] + (a[i] == a[i - <span class="number">1</span>] ? hot[a[i]] : cold[a[i]]));</span><br><span class="line">            g[i][a[i - <span class="number">1</span>]] =</span><br><span class="line">                <span class="built_in">min</span>(g[i][a[i - <span class="number">1</span>]],</span><br><span class="line">                    f[i - <span class="number">1</span>][j] + (a[i] == j ? hot[a[i]] : cold[a[i]]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mn = g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        mn = <span class="built_in">min</span>(&#123;mn, f[n][i], g[n][i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; mn &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 855 (Div. 3) 1800</title>
    <url>/2023/05/17/1800/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-855-Div-3-1800"><a href="#Codeforces-Round-855-Div-3-1800" class="headerlink" title="Codeforces Round 855 (Div. 3) 1800"></a>Codeforces Round 855 (Div. 3) 1800</h1><p><a href="https://codeforces.com/contest/1800/problems">Complete problemset</a></p>
<h2 id="A-Is-It-a-Cat"><a href="#A-Is-It-a-Cat" class="headerlink" title="A. Is It a Cat?"></a>A. Is It a Cat?</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>问一个字符串在转化大写并去重后是否是“MEOW”。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>转化大写并去重后判断是否为“MEOW”。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>&amp; i : s)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">islower</span>(i))</span><br><span class="line">            i = i - <span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; s.substr(0, unique(s.begin(), s.end()) - s.begin()) &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; (s.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="built_in">unique</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()) - s.<span class="built_in">begin</span>()) == <span class="string">&quot;MEOW&quot;</span></span><br><span class="line">                 ? <span class="string">&quot;YES\n&quot;</span></span><br><span class="line">                 : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Count-the-Number-of-Pairs"><a href="#B-Count-the-Number-of-Pairs" class="headerlink" title="B. Count the Number of Pairs"></a>B. Count the Number of Pairs</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个只有英文字母的串，每次操作你可以将一个字母在大小写间任意转化。</p>
<p>最多操作k次。</p>
<p>同一字母的大写和小写可以配对，问最多有多少个配对的大小写。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>统计每个字母的大小写个数，不妨设小写为a个，大写为b个。</p>
<p>那么min(a,b)可为答案贡献。此外max(a,b)-min(a,b)则为多出的大写或小写。我们将一半转化，那么又有贡献min((max(a,b)-min(a,b))/2，k)，并让k减少相同数值的次数。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> ch[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="built_in">sizeof</span>(ch));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i : s)</span><br><span class="line">        ch[i]++;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        ans += <span class="built_in">min</span>(ch[<span class="string">&#x27;a&#x27;</span> + i], ch[<span class="string">&#x27;A&#x27;</span> + i]);</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">min</span>(<span class="built_in">abs</span>(ch[<span class="string">&#x27;a&#x27;</span> + i] - ch[<span class="string">&#x27;A&#x27;</span> + i]) / <span class="number">2</span>, k);</span><br><span class="line">        ans += d;</span><br><span class="line">        k -= d;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C2-Powering-the-Hero-hard-version"><a href="#C2-Powering-the-Hero-hard-version" class="headerlink" title="C2. Powering the Hero (hard version)"></a>C2. Powering the Hero (hard version)</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有一叠牌，如果值为0则是英雄牌，非0则是增益牌。</p>
<p>当选到增益牌，可以选择丢掉或者放到另一个牌堆上。</p>
<p>当选到英雄牌，则可以从增益牌堆顶拿出一张（如果有），给英雄增值。然后将英雄的值加入到总战力中。</p>
<p>问最大战力是多少。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>用大根堆模拟即可。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;ll&gt; q;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (x) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans += q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-Remove-Two-Letters"><a href="#D-Remove-Two-Letters" class="headerlink" title="D. Remove Two Letters"></a>D. Remove Two Letters</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个长为n的字符串，问删除两个连续字符后拼接的字符串有多少种。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>像“abab”，“aba”这种交替的串。</p>
<p>交替的串长度为l则有l-1个重复。</p>
<p>所以总的串的个数是n-1，减去重复即可。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> ans = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> a = s[<span class="number">0</span>], b = s[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == a)</span><br><span class="line">            ans--;</span><br><span class="line">        a = b;</span><br><span class="line">        b = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E2-Unforgivable-Curse-hard-version"><a href="#E2-Unforgivable-Curse-hard-version" class="headerlink" title="E2. Unforgivable Curse (hard version)"></a>E2. Unforgivable Curse (hard version)</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>长度为n的字符串s和t。每次可以交换s[i]和s[i+k]或者s[i]和s[i+k+1]。可以交换任意次。</p>
<p>问最后可以s是否可以与t相等。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>首先每个字符出现的次数应该一致。</p>
<p>当n≥2k时必定可行。</p>
<p>当n&lt;k时必定不行。</p>
<p>当k≤n&lt;2k时，由n可以跳到n-k。因此只需判断s[n-k:k] = t[n-k:k]</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string s, t;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    string ss = s, st = t;</span><br><span class="line">    <span class="built_in">sort</span>(ss.<span class="built_in">begin</span>(), ss.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(st.<span class="built_in">begin</span>(), st.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (ss != st) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">2</span> * k) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; k) &#123;</span><br><span class="line">        cout &lt;&lt; (s == t ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// k&lt;=n&lt;2k</span></span><br><span class="line">        <span class="type">int</span> u = n - k;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; s.substr(u, k - u) &lt;&lt; endl;</span></span><br><span class="line">        cout &lt;&lt; (s.<span class="built_in">substr</span>(u, k - u) == t.<span class="built_in">substr</span>(u, k - u) ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F-Dasha-and-Nightmares"><a href="#F-Dasha-and-Nightmares" class="headerlink" title="F. Dasha and Nightmares"></a>F. Dasha and Nightmares</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给出n个小写英文字符串。s_i为第i个字符串。</p>
<p>现在问有多少个数对⟨i,j⟩ (1≤i≤j≤n).</p>
<p>数对满足条件：</p>
<ul>
<li>拼接$s_is_j$长度为奇数。</li>
<li>拼接后的字符串中字符恰好为25个。</li>
<li>每个字符出现的次数也是奇数次。</li>
</ul>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>我们可以求出所有以$s_j$结尾的字符串。我们可以用哈希表存储$s_j$之前的字符串的相关信息。</p>
<p>发现条件与奇偶性有关，可以用26位二进制数表示每个字符串的字符出现次数的奇偶性。</p>
<p>字符个数恰好为25个，所以可以用26个哈希表，对于缺失的字符哪个字符就用哪个哈希表。</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct custom_hash &#123;</span></span><br><span class="line"><span class="comment">//     static uint64_t splitmix64(uint64_t x) &#123;</span></span><br><span class="line"><span class="comment">//         x += 0x9e3779b97f4a7c15;</span></span><br><span class="line"><span class="comment">//         x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;</span></span><br><span class="line"><span class="comment">//         x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb;</span></span><br><span class="line"><span class="comment">//         return x ^ (x &gt;&gt; 31);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     size_t operator()(uint64_t x) const &#123;</span></span><br><span class="line"><span class="comment">//         static const uint64_t FIXED_RANDOM =</span></span><br><span class="line"><span class="comment">//             chrono::steady_clock::now().time_since_epoch().count();</span></span><br><span class="line"><span class="comment">//         return splitmix64(x + FIXED_RANDOM);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void sol() &#123;</span></span><br><span class="line"><span class="comment">//     // unordered_map&lt;int, int&gt; mp[26];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     unordered_map&lt;int, int, custom_hash&gt; mp[26];</span></span><br><span class="line"><span class="comment">//     int mask = (1 &lt;&lt; 26) - 1;</span></span><br><span class="line"><span class="comment">//     ll ans = 0;</span></span><br><span class="line"><span class="comment">//     int n;</span></span><br><span class="line"><span class="comment">//     string s;</span></span><br><span class="line"><span class="comment">//     cin &gt;&gt; n;</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//         cin &gt;&gt; s;</span></span><br><span class="line"><span class="comment">//         int u = 0;</span></span><br><span class="line"><span class="comment">//         vector&lt;int&gt; c(26);</span></span><br><span class="line"><span class="comment">//         for (char j : s) &#123;</span></span><br><span class="line"><span class="comment">//             u ^= 1 &lt;&lt; j - &#x27;a&#x27;;</span></span><br><span class="line"><span class="comment">//             c[j - &#x27;a&#x27;]++;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         for (int j = 0; j &lt; 26; j++) &#123;</span></span><br><span class="line"><span class="comment">//             if (c[j] == 0) &#123;</span></span><br><span class="line"><span class="comment">//                 mp[j][u | (1 &lt;&lt; j)]++;</span></span><br><span class="line"><span class="comment">//                 ans += mp[j][(u ^ mask) | (1 &lt;&lt; j)];</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mp[<span class="number">1</span> &lt;&lt; <span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mask = (<span class="number">1</span> &lt;&lt; <span class="number">26</span>) - <span class="number">1</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">c</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> j : s) &#123;</span><br><span class="line">            b[i] ^= <span class="number">1</span> &lt;&lt; j - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            c[i][j - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> _ = <span class="number">0</span>; _ &lt; <span class="number">26</span>; _++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i][_])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            mp[b[i]]++;</span><br><span class="line">            ans += mp[(b[i] ^ mask) ^ (<span class="number">1</span> &lt;&lt; _)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i][_])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            mp[b[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="G-Symmetree"><a href="#G-Symmetree" class="headerlink" title="G. Symmetree"></a>G. Symmetree</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>问一棵树是否镜像对称。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>对每颗子树进行哈希，可以用对于当前节点的哈希值可以用排好序的当前节点的所有子树的哈希值序列进行映射。</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line">map&lt;vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; h;</span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sym[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ch;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ch.<span class="built_in">push_back</span>(<span class="built_in">dfs</span>(v, u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ch.<span class="built_in">begin</span>(), ch.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (h.<span class="built_in">count</span>(ch) == <span class="number">0</span>) &#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ch)</span><br><span class="line">            mp[i]++;</span><br><span class="line">        <span class="type">int</span> odd = <span class="number">0</span>, issym = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : mp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j % <span class="number">2</span>) &#123;</span><br><span class="line">                odd++;</span><br><span class="line">                issym &amp;= sym[i];</span><br><span class="line">            &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        sym[val] = odd &lt; <span class="number">2</span> &amp;&amp; issym;</span><br><span class="line">        h[ch] = val++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h[ch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    h.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        g[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; val; i++)</span><br><span class="line">        sym[i] = <span class="number">0</span>;</span><br><span class="line">    val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (sym[<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>)] ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 857 (Div. 2)1802</title>
    <url>/2023/05/17/1802/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-857-Div-2-1802"><a href="#Codeforces-Round-857-Div-2-1802" class="headerlink" title="Codeforces Round 857 (Div. 2)1802"></a>Codeforces Round 857 (Div. 2)1802</h1><p><a href="https://codeforces.com/contest/1802/problems">Complete problemset</a></p>
<h2 id="A-Likes"><a href="#A-Likes" class="headerlink" title="A. Likes"></a>A. Likes</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个数组a代表一个帖子的点赞情况，当$a_i&gt;0$时说明$a_i$这个用户点了赞，当$a_i&lt;0$则代表$-a_i$这个用户取消了点赞。用户没有点赞前不能取消，如果可以给这个数组排序，请问用户在每个时刻最大和最小的点赞数是多少？</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于最大点赞数应该让所有$a_i&gt;0$的用户排在前面。</p>
<p>对于最小点赞数应该让所有存在$a_i$和$-a_i$的用户排在一起，且这些用户都要排在前面。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">            a++;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a - i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1 0 &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a - b; i++) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Settlement-of-Guinea-Pigs"><a href="#B-Settlement-of-Guinea-Pigs" class="headerlink" title="B. Settlement of Guinea Pigs"></a>B. Settlement of Guinea Pigs</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>现在一个人在养猪，他把猪关在笼子，这种笼子只能关两只猪。一个数组a代表了这个人接下来的n天的行动。</p>
<p>当$a_i = 1$时，这个人买一只猪。</p>
<p>当$a_i = 2$时，这个人找医生为所买的猪鉴别性别。</p>
<p>这个人不想把公猪和母猪关到一起。请问需要多少个笼子。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们把已有的猪分为两类，一类是已经鉴别过性别的猪，设个数为a；一类是未鉴别过性别的猪，设个数为b。</p>
<p>对于b只未知性别的猪只能分布单独关在一个笼子。对于a经过分析至少需要$\lfloor\frac{a}{2}\rfloor+1$个笼子。如果a是奇数则可以拆成偶数只公猪和奇数头母猪，若a是偶数则可以拆除奇数头公猪和奇数头母猪。</p>
<p>所以答案维护每一天$\lfloor\frac{a}{2}\rfloor+1+b$的最大值即可。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, u = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            u++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (p ? p / <span class="number">2</span> + <span class="number">1</span> : <span class="number">0</span>) + u);</span><br><span class="line">            p += u;</span><br><span class="line">            u = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (p ? p / <span class="number">2</span> + <span class="number">1</span> : <span class="number">0</span>) + u);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-The-Very-Beautiful-Blanket"><a href="#C-The-Very-Beautiful-Blanket" class="headerlink" title="C. The Very Beautiful Blanket"></a>C. The Very Beautiful Blanket</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>求一个n行m列的矩阵，使得每个4* 4 的子矩阵A满足</p>
<p>$A_{11} \oplus A_{12} \oplus A_{21} \oplus A_{22} = A_{33} \oplus A_{34} \oplus A_{43} \oplus A_{44}$</p>
<p>$A_{13} \oplus A_{14} \oplus A_{23} \oplus A_{24} = A_{31} \oplus A_{32} \oplus A_{41} \oplus A_{42}$</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>递归构造一个$2^k*2^k$矩阵，以下为k=2时的矩阵。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"><span class="number">9</span>  <span class="number">10</span> <span class="number">13</span> <span class="number">14</span></span><br><span class="line"><span class="number">11</span> <span class="number">12</span> <span class="number">15</span> <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>我们可以构造出256*256的矩阵，然后任意查询直接查表即可。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">1</span> &lt;&lt; <span class="number">8</span>][<span class="number">1</span> &lt;&lt; <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> sz, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sz == <span class="number">1</span>) &#123;</span><br><span class="line">        a[x][y] = val - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(x, y, sz / <span class="number">2</span>, val - sz * sz / <span class="number">4</span> * <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(x + sz / <span class="number">2</span>, y, sz / <span class="number">2</span>, val - sz * sz / <span class="number">4</span> * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(x, y + sz / <span class="number">2</span>, sz / <span class="number">2</span>, val - sz * sz / <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(x + sz / <span class="number">2</span>, y + sz / <span class="number">2</span>, sz / <span class="number">2</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[x][y] ^ a[x + <span class="number">1</span>][y] ^ a[x][y + <span class="number">1</span>] ^ a[x + <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; n * m &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// assert(check(8, 9) == 0);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-Buying-gifts"><a href="#D-Buying-gifts" class="headerlink" title="D. Buying gifts"></a>D. Buying gifts</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>一个人有两个朋友x和y，他为它们两个买礼物。</p>
<p>现在有n个商店，第i个商店有两件商品$a_i$和$b_i$。这两件商品只能且必须买一件。若买了$a_i$则送给x，否则买$b_i$送给y。</p>
<p>现在问在买给x的礼物中最贵的礼物和买给y的礼物中最贵的礼物的最小差值是多少。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>考虑如果x收到的最贵的礼物$a_k$，所有大于$a_k$的礼物$a_r$不能买，所以只能买$b_r$，因此维护$min(|max(b_r)-a_k|)$作为候选答案。此外所有小于$a_k$的礼物$a_l$，可买可不买，我们可以在所有$b_l$中二分找到最接近$a_k$的值t，维护$min(|t-a_k|)$为答案。</p>
<p>注意当存在多个值等于$a_k$时，在所有<strong>小于等于</strong>$a_k$的礼物$a_l$，可买可不买。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        mp[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        st.<span class="built_in">insert</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1e9</span> + <span class="number">8</span>, mx = <span class="number">-1e9</span> - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i, j] : mp) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot;: &quot;;</span></span><br><span class="line">        <span class="comment">// for (int k : j) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; k &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(mx - i));</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                st.<span class="built_in">erase</span>(st.<span class="built_in">find</span>(j[<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it = st.<span class="built_in">upper_bound</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (it != st.<span class="built_in">end</span>())</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(*it - i));</span><br><span class="line">            <span class="keyword">if</span> (it != st.<span class="built_in">begin</span>())</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(*--it - i));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k : j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">                    st.<span class="built_in">erase</span>(st.<span class="built_in">find</span>(k));</span><br><span class="line">                mx = <span class="built_in">max</span>(mx, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Nebius Welcome Round (Div. 1 + Div. 2) 1804</title>
    <url>/2023/05/17/1804/</url>
    <content><![CDATA[<h1 id="Nebius-Welcome-Round-Div-1-Div-2-1804"><a href="#Nebius-Welcome-Round-Div-1-Div-2-1804" class="headerlink" title="Nebius Welcome Round (Div. 1 + Div. 2) 1804"></a>Nebius Welcome Round (Div. 1 + Div. 2) 1804</h1><p><a href="https://codeforces.com/contest/1804/problems">Complete problemset</a></p>
<h2 id="A-Lame-King"><a href="#A-Lame-King" class="headerlink" title="A. Lame King"></a>A. Lame King</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在一个平面直角坐标系中，你在(0,0)点，需要移动到(a,b)点。</p>
<p>每次移动只能向上下左右移动一格或者不动。每次移动不能与上次移动的操作一致。</p>
<p>从(0,0)到(a,b)的最小移动次数。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不妨设a&lt;b</p>
<p>我们先从(0,0)到(a,a)。花费2*a步</p>
<p>再从(a,a)到(a,b)花费的步数是max(0,(b-a)*2-1)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    a = <span class="built_in">abs</span>(a);</span><br><span class="line">    b = <span class="built_in">abs</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="built_in">swap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">0</span>, (b - a) * <span class="number">2</span> - <span class="number">1</span>) + <span class="number">2</span> * a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Vaccination"><a href="#B-Vaccination" class="headerlink" title="B. Vaccination"></a>B. Vaccination</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>现在又n个人需要打疫苗，将会在$t_1,t_2,\cdots,t_n$时刻进医院。</p>
<p>每包疫苗可以给k个人注射。疫苗开动后d秒就会变质，不能给其他人注射。</p>
<p>每个人进入医院后必须在w秒内注射。</p>
<p>问最少需要多少包疫苗。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对这n个人按照入场顺序分若干批次进行注射，每一批需要一包疫苗。</p>
<p>在这一批人中应该满足条件：人数不超过k，第一个入场的和最后一个入场的时间差不超过k+w.我们可以让第一个人等待w秒，然后开动疫苗，这样可以让这包疫苗能给更多的人注射。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k, d, w;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; d &gt;&gt; w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, t = a[<span class="number">0</span>], i = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i - p + <span class="number">1</span> &lt;= k &amp;&amp; a[i] - t &lt;= w + d)</span><br><span class="line">            i++;</span><br><span class="line">        p = i;</span><br><span class="line">        t = a[i];</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Pull-Your-Luck"><a href="#C-Pull-Your-Luck" class="headerlink" title="C. Pull Your Luck"></a>C. Pull Your Luck</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>现在有个环状轮盘，轮盘有n个区间，每个区间编号从0到n-1。</p>
<p>给出三个数n，x，p。n≤1e5, x≤n, p≤1e9</p>
<p>一个球在x区间，你可以给它施加一个力f, f≤p。这个球在第1秒可以移动f格。第2秒可以移动f-1格。。。第f秒则可以移动1格。</p>
<p>一个合适的力f，使得恰好停在编号为0的格子。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>如果施加的力为f，则可以移动f(f+1)/2格。当力为2n时则移动2n*(2n+1)/2。恰好为n的倍数。说明回到了原处。因此力的大小在2n及之内。我们只需遍历1到min(p,2n)寻找是否存在一个答案即可。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, x, p;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(<span class="number">2</span> * n, p); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((i + <span class="number">1</span>) * i / <span class="number">2</span> + x) % n == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-Accommodation"><a href="#D-Accommodation" class="headerlink" title="D. Accommodation"></a>D. Accommodation</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个n*m的矩阵，代表一栋n层高每层m个窗户的楼。m是4的倍数。</p>
<p>现在已知每层有m/4个双窗房间，有m/2个单窗房间。双窗户房间有两个灯，单窗户房间有一个灯。</p>
<p>这个矩阵中1代表该窗户是亮着灯的。</p>
<p>如果一个房间中至少有一个灯亮着说明这个房间有人在住着。</p>
<p>现在已知了灯亮灭情况，求最多有多少房间有人入住，最少有多少房间入住。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>每一层是独立的，所以可以单独求出每层最多人数和最少人数。</p>
<p>对于每一层，定义：</p>
<p>A 为入住房间的个数。</p>
<p>B 为亮着灯的窗户个数。</p>
<p>D 为灭灯的窗户个数。</p>
<p>O 为灭灯的单窗房的个数。</p>
<p>O1 为亮着灯的单窗房的个数。</p>
<p>T 为全灭灯的双窗房的个数。</p>
<p>T1 为亮一个灯的双窗房的个数。</p>
<p>T2 为亮两个灯的双窗房的个数。</p>
<p>我们已知A = O1+T1+T2, B = O1+T1+2*T2。</p>
<p>所以A = B-T2。入住的房间个数只与亮着两个灯的双窗房有关。</p>
<p>T2最大化，则找出了该层最小入住的人数。</p>
<p>T2最小化，则找出了该层最大入住的人数。</p>
<p>如何最大化T2，只需找出所有连续的亮着的窗口段。不妨设这些段为$l_1,l_2,\cdots,l_s$。则最大化的$T2 = min(\frac{m}{4}, \sum \limits_{i=1}^{s} \lfloor \frac{l_i}{2}\rfloor)$</p>
<p>如何最小化T2，只需找到不存在连续两个亮着的窗口段。不妨设这些段为$l_1’,l_2’,\cdots,l_s’$。则最小化的$T2=max(0,\frac{m}{4}-\sum\limits_{i=1}^{s}\lfloor\frac{l_i’}{2}\rfloor)$</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>, mn = <span class="number">0</span>;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> b = <span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> mx_t2 = <span class="number">0</span>, mn_t2 = <span class="number">0</span>, c1 = <span class="number">1</span>, c2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j - <span class="number">1</span>] == s[j] &amp;&amp; s[j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                c1++;</span><br><span class="line"></span><br><span class="line">                mn_t2 += c2 / <span class="number">2</span>;</span><br><span class="line">                c2 = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mx_t2 += c1 / <span class="number">2</span>;</span><br><span class="line">                c1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                c2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mx_t2 += c1 / <span class="number">2</span>;</span><br><span class="line">        mn_t2 += c2 / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;---------\n&quot;;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; mx_t2 &lt;&lt; &quot; &quot; &lt;&lt; mn_t2 &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; b - min(mx_t2, m / 4) &lt;&lt; &quot; &quot; &lt;&lt; b - max(0, m / 4 - mn_t2)</span></span><br><span class="line">        <span class="comment">//      &lt;&lt; endl;</span></span><br><span class="line">        mn += b - <span class="built_in">min</span>(mx_t2, m / <span class="number">4</span>);</span><br><span class="line">        mx += b - <span class="built_in">max</span>(<span class="number">0</span>, m / <span class="number">4</span> - mn_t2);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; mn &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mx &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>1806</title>
    <url>/2023/05/17/1806/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1806/problems">Complete problemset</a></p>
<h2 id="A-Walking-Master"><a href="#A-Walking-Master" class="headerlink" title="A. Walking Master"></a>A. Walking Master</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>当前位置在(x,y)，你每次移动可以到(x+1,y+1)或者(x-1,y)</p>
<p>请问从(a,b)到(c,d)最少需要多少步数。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>b不能大于d</p>
<p>然后我们让(a,b)移动到(a+d-b, d)位置。</p>
<p>这时候在c 应该小于a+d-b。</p>
<p>总距离是a+d-b-c</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, b, c, d;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c -= d - b;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; d - b + a - c &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Mex-Master"><a href="#B-Mex-Master" class="headerlink" title="B. Mex Master"></a>B. Mex Master</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个数组，数组的分数是$mex(a_1+a_2, a_2+a_3, … , a_{n-1}+a_n)$</p>
<p>现在可以重新排列这个数组，求分数最小值</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>如果大于0的元素大于等于floor(n/2)个，那么最小值就是0。</p>
<p>否则如果大于0的元素中全是1，则分数最小值是2</p>
<p>否则最小值为1</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">            pos++;</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mx &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Sequence-Master"><a href="#C-Sequence-Master" class="headerlink" title="C. Sequence Master"></a>C. Sequence Master</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出一个长度为2m的数组a。</p>
<p>现在需要构造2m个数的数组b，使得b中任意m个的和等于剩余任意m个的积。</p>
<p>并且$\sum \limits_{i=1}^{2m} |a_i-b_i|$最小</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这个需要找规律。</p>
<p>这个性质：m为奇数时只有0满足，m为偶数时除了2和4有特殊情况，其余都是-1除了一个是m。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(<span class="number">2</span> * n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    <span class="keyword">auto</span> get_ans = [&amp;]() &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i : a)</span><br><span class="line">            ans += <span class="built_in">abs</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ll c = <span class="number">0</span>, eans = ans;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : a)</span><br><span class="line">                c += <span class="built_in">abs</span>(<span class="number">-1</span> - i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">                eans = <span class="built_in">min</span>(eans, c - <span class="built_in">abs</span>(<span class="number">-1</span> - i) + <span class="built_in">abs</span>(n - i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> eans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(<span class="built_in">get_ans</span>(), <span class="built_in">abs</span>(a[<span class="number">0</span>] - a[<span class="number">1</span>])) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i : a)</span><br><span class="line">            ans += <span class="built_in">abs</span>(i - <span class="number">2</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(<span class="built_in">get_ans</span>(), ans) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">get_ans</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-Tree-Master"><a href="#E-Tree-Master" class="headerlink" title="E. Tree Master"></a>E. Tree Master</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一颗树，以及q次查询。</p>
<p>每次查询会给出两个树中的节点x和y。这两个节点都属于同一层。</p>
<p>现在要求$f(x,y)$，$f(x,y) = a_x*a_y+f(p_x,p_y)$。$a_x$是x节点值，$p_x$是x节点的父节点。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>直接记忆化搜索即可，但是注意节点的个数由1e5。所以状态值非常多。反而会降低时间效率。</p>
<p>我们可以减少一些存储空间，多暴力搜寻一些状态。</p>
<p>可以这样设计哈希。为每一层的节点编号，对于一层中超过sqrt(n)不记录哈希。</p>
<p>最后时间复杂度$O(n^{\frac{3}{2}})$</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQ 320</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll h[N][SQ + <span class="number">5</span>];  <span class="comment">// h[i][id[j]] 节点i和j的ans</span></span><br><span class="line"><span class="type">int</span> cnt[N];       <span class="comment">// cnt[i] 第i层的节点个数</span></span><br><span class="line"><span class="type">int</span> lev[N];       <span class="comment">// lev[i] i节点在第几层</span></span><br><span class="line"><span class="type">int</span> id[N];        <span class="comment">// id[i] i节点在所属层的第几个</span></span><br><span class="line">ll a[N], p[N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">    id[u] = cnt[l]++;</span><br><span class="line">    lev[u] = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : g[u]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i, l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x &amp;&amp; !y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt[lev[y]] &lt; SQ &amp;&amp; h[x][id[y]])</span><br><span class="line">        <span class="keyword">return</span> h[x][id[y]];</span><br><span class="line">    ll ans = <span class="built_in">ask</span>(p[x], p[y]) + a[x] * a[y];</span><br><span class="line">    <span class="keyword">if</span> (cnt[lev[y]] &lt; SQ)</span><br><span class="line">        <span class="keyword">return</span> h[x][id[y]] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        g[p[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">ask</span>(x, y) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 145 (Rated for Div. 2) 1809</title>
    <url>/2023/05/17/1809/</url>
    <content><![CDATA[<h1 id="Educational-Codeforces-Round-145-Rated-for-Div-2-1809"><a href="#Educational-Codeforces-Round-145-Rated-for-Div-2-1809" class="headerlink" title="Educational Codeforces Round 145 (Rated for Div. 2) 1809"></a>Educational Codeforces Round 145 (Rated for Div. 2) 1809</h1><p><a href="https://codeforces.com/contest/1809/problems">Complete problemset</a></p>
<h2 id="A-Garland"><a href="#A-Garland" class="headerlink" title="A. Garland"></a>A. Garland</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出四个数字代表四个灯泡，每个数字代表一种颜色。</p>
<p>现在每次操作可以将一个灯泡熄灭或打开。前提是不能与上次操纵的灯泡颜色一样。</p>
<p>问将全灭的四个灯泡变为全亮的最少操作次数。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>情况较少，直接统计每个数的出现次数，再分类讨论。</p>
<p>只有一种颜色则无解。</p>
<p>有两种颜色，其中一种出现小于两次，则只需要4步。</p>
<p>其余情况都是4步。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i : s)</span><br><span class="line">        mp[i]++;</span><br><span class="line">    <span class="keyword">if</span> (mp.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mp.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">begin</span>()-&gt;second == <span class="number">2</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;4\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;6\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;4\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Points-on-Plane"><a href="#B-Points-on-Plane" class="headerlink" title="B. Points on Plane"></a>B. Points on Plane</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>把1个点放到二维平面上的代价为|x|+|y|，(x,y)为放的位置。</p>
<p>现在要把n个点放到二维平面上，且n个点任意两个点之间的距离大于1。</p>
<p>n个点的代价是每个点的代价中的最大值。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>能放的点随代价增大而增大。所以可以二分代价。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ll m = (r - l) / <span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span> ((m + <span class="number">1</span>) * (m + <span class="number">1</span>) &gt;= n)</span><br><span class="line">            r = m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; r &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Sum-on-Subarrays"><a href="#C-Sum-on-Subarrays" class="headerlink" title="C. Sum on Subarrays"></a>C. Sum on Subarrays</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>构造长度为n（最多为30）的数组，数组中的每个数范围在-1000到1000之间。</p>
<p>使得恰好有p个子数组的和为正数，其余子数组的和为负数。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>构造形如 <code>1000, 1000, …. , 1000 , -1, -1, …, -1, 100, -200, -1, -1, … , -1</code>的序列。</p>
<p>第一个1000 贡献了n个正数子数组。</p>
<p>第二个1000 贡献了n-1个正数子数组。</p>
<p>第i个1000 贡献了n-i+1个正数子数组。</p>
<p>最后一个1000与100之间的-1的个数t贡献了t+1个整数子数组，所以如果前面的1000的所贡献的正数子数组为k则最后不需要100这个数出现，即后面全部为负数。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> p = n;</span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">0</span> &amp;&amp; k &gt;= p) &#123;</span><br><span class="line">        k -= p;</span><br><span class="line">        p--;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="number">-100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ans.<span class="built_in">size</span>() &lt; n)</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; ans.size() &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : ans) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-Binary-String-Sorting"><a href="#D-Binary-String-Sorting" class="headerlink" title="D. Binary String Sorting"></a>D. Binary String Sorting</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个01串。</p>
<p>每次可以有两种操作：</p>
<ul>
<li>交换相邻的两个字符，代价1e12。</li>
<li>删除一个字符，代价1e12+1。</li>
</ul>
<p>求最小代价使得01串非降序。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>首先需要观察出一个性质，最多只会交换1次。因为交换这种操作肯定是发生在1在前0在后这种情况。如果交换两次最后有序了涉及的交换的元素一定是3个相邻的元素。如果是两对相邻的元素共计四个元素，那么交换也不会出现有序。既然是三个相邻元素那么交换两次共花费2e12+2，不如删除一次交换一次花费2e12+1。</p>
<p>那么我们的目标就是把数组删除一些元素使得成为形如000…0001111….111 或者 000…0010111….111。</p>
<p>可以枚举分割线，统计左侧需要删除的1的数量和右侧需要删除0的数量，然后维护最小值即可。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll coin1 = <span class="number">1e12</span>, coin2 = <span class="number">1e12</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> s1 = <span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27;1&#x27;</span>), s0 = n - s1;</span><br><span class="line">    <span class="type">int</span> c1 = <span class="number">0</span>, c0 = <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="built_in">min</span>(s1, s0) * coin2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        c1 += s[i] == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        c0 += s[i] == <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, (c1 + s0 - c0) * coin2);</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, (c1 + s0 - c0 - <span class="number">2</span>) * coin2 + coin1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 146 (Rated for Div. 2) 1814</title>
    <url>/2023/05/17/1814/</url>
    <content><![CDATA[<h1 id="Educational-Codeforces-Round-146-Rated-for-Div-2-1814"><a href="#Educational-Codeforces-Round-146-Rated-for-Div-2-1814" class="headerlink" title="Educational Codeforces Round 146 (Rated for Div. 2) 1814"></a>Educational Codeforces Round 146 (Rated for Div. 2) 1814</h1><p><a href="https://codeforces.com/contest/1814/problems">Complete problemset</a></p>
<h2 id="A-Coins"><a href="#A-Coins" class="headerlink" title="A. Coins"></a>A. Coins</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出n和k，问是否存在非负整数x和y使得2x+ky=n</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据裴蜀定理，若n是gcd(2,k)的倍数则有解</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ll g = <span class="built_in">gcd</span>(<span class="number">2</span>, k);</span><br><span class="line">    <span class="keyword">if</span> (n % g == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Long-Legs"><a href="#B-Long-Legs" class="headerlink" title="B. Long Legs"></a>B. Long Legs</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>在一个二维平面上，求(0,0) 到 (a,b)所需要的最少操作数。</p>
<p>每次操作：</p>
<ul>
<li>让当前位置(x,y) 变为 (x+m,y)</li>
<li>让当前位置(x,y) 变为 (x,y+m)</li>
<li>让m增加1</li>
</ul>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>不妨设在到达(a,b)时的m为x，那么需要执行3操作x-1次。</p>
<p>到达a的最短跳跃次数为$\lceil\frac{a}{x}\rceil$，到达b的最短跳跃次数是$\lceil\frac{b}{x}\rceil$。</p>
<p>所以我们可以枚举x求出最小的$\lceil\frac{a}{x}\rceil+\lceil\frac{b}{x}\rceil+x-1$</p>
<p>当a=b时是最坏的情况，可以认为是一个求正比例函数和反比例函数的交点。</p>
<p>所以我们枚举比$O(\sqrt {2max(a,b)})$稍大数量级的x即可。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll ans = <span class="number">1e10</span>;</span><br><span class="line">		<span class="comment">//2 * sqrt(2 * max(a, b))</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, (a + i - <span class="number">1</span>) / i + (b + i - <span class="number">1</span>) / i + i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Search-in-Parallel"><a href="#C-Search-in-Parallel" class="headerlink" title="C. Search in Parallel"></a>C. Search in Parallel</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有两个序列a,b，两个序列中的值全部都不相同。</p>
<p>现在如果需要找一个值x，那么可以在a和b中同时遍历查询。a中每遍历一个元素需要s1秒，b中每遍历一个元素需要s2秒。</p>
<p>现在告诉你n个数的数组r，其中$r_i$代表着你需要查询i共$r_i$次，请构造两个序列使得查询总时间最小。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>贪心</p>
<p>查询次数多的肯定排在前面，先排序。</p>
<p>对于每个数x，那么到底放到a和b哪个序列中呢？</p>
<p>如果当前a中有$cnt_a$个数，b中有$cnt_b$个数。那么$cnt_a<em>s1$和$cnt_b</em>s2$谁小就选谁。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, s1, s2;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; i : r)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">idx</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">iota</span>(idx.<span class="built_in">begin</span>(), idx.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(idx.<span class="built_in">begin</span>(), idx.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> r[x] &gt; r[y]; &#125;);</span><br><span class="line">    <span class="comment">// for (int i : idx)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i + 1 &lt;&lt; &quot;--&quot;;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="type">int</span> p = s1, q = s2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; l1, l2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : idx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; q) &#123;</span><br><span class="line">            l1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">            p += s1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">            q += s2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : l1)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; l2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : l2)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 872 (Div. 2)</title>
    <url>/2023/05/17/1825/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-872-Div-2"><a href="#Codeforces-Round-872-Div-2" class="headerlink" title="Codeforces Round 872 (Div. 2)"></a>Codeforces Round 872 (Div. 2)</h1><p><a href="https://codeforces.com/contest/1825/problems">Complete problemset</a></p>
<h2 id="A-LuoTianyi-and-the-Palindrome-String"><a href="#A-LuoTianyi-and-the-Palindrome-String" class="headerlink" title="A. LuoTianyi and the Palindrome String"></a>A. LuoTianyi and the Palindrome String</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个回文串，求其最长非空非回文子序列的长度。若没有则输出-1</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果回文串不是由一个字符组成，那么答案就是n-1。注意特殊情况n=1</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s[<span class="number">0</span>])) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; (n - <span class="number">1</span> ? n - <span class="number">1</span> : <span class="number">-1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-LuoTianyi-and-the-Table"><a href="#B-LuoTianyi-and-the-Table" class="headerlink" title="B. LuoTianyi and the Table"></a>B. LuoTianyi and the Table</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出$n\times m$个数，需要填充到二维数组$a_{n\times m}$中使得下式最小化</p>
<p>$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}\left(\max\limits_{1 \le x \le i, 1 \le y \le j}a_{x,y}-\min\limits_{1 \le x \le i, 1 \le y \le j}a_{x,y}\right)$</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>贪心</p>
<p>不妨设n&lt;m</p>
<p>设最小值，次小值，次大值，最大值分别为a1,a2,a3,a4</p>
<p>显然当把最大值放到$a_{0,0}$时，次小值应当放置在$a_{1,0}$，这样第一列的贡献是$(a4 - a2)(n - 1)$，然后最小值放到$a_{0,1}$，这样第二列到最后一列的贡献是$(a4 - a1)(m - 1)n$</p>
<p>另一种放法就是将最小值放到$a_{0,0}$，次大值放在$a_{1,0}$，贡献为$(a3 - a1)(n - 1)$，最大值放在$a_{0,1}$，贡献为$(a4 - a1)(m - 1) n$</p>
<p>两种放置方法的最小值就是答案。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n * m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m)</span><br><span class="line">        <span class="built_in">swap</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    ll a1 = a[<span class="number">0</span>], a2 = a[<span class="number">1</span>], a3 = a[n * m - <span class="number">2</span>], a4 = a[n * m - <span class="number">1</span>];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>((a4 - a2) * (n - <span class="number">1</span>) + (a4 - a1) * (m - <span class="number">1</span>) * n,</span><br><span class="line">                (a3 - a1) * (n - <span class="number">1</span>) + (a4 - a1) * (m - <span class="number">1</span>) * n)</span><br><span class="line">         &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-LuoTianyi-and-the-Show"><a href="#C-LuoTianyi-and-the-Show" class="headerlink" title="C. LuoTianyi and the Show"></a>C. LuoTianyi and the Show</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有m个座位排成一排，现在有n个人要坐入其中，每个人有坐入的方式有三种：</p>
<ol>
<li>坐在最左边的人的左边，如果1号位置有人那么不能坐入，如果当前没有人坐，则坐在座位m</li>
<li>坐在最右边的人的右边，如果m号位置有人那么不能坐入，如果当前没有人坐，则坐在座位1</li>
<li>坐在指定的x位置，如果x位置有人则不能坐入。</li>
</ol>
<p>现在知道所有人的坐入方式，你可以重新排列顺序，使得坐入最多的人。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>坐入方式1的人数为$l$</p>
<p>坐入方式2的人数为$r$</p>
<p>对于坐入方式3的人要去重，在去重后得到这些人的位置序列a，这些人的数目为k。</p>
<p>遍历$a$对于每个位置$a_i$，我们考虑$a_i$左侧的空位，有$a_i-1$个，由于我们总是可以将$a_0,a_1,\cdots,a_{i-1}$填入，所以剩余能填入的空位有$a_i-1-i$个，我们需要填入$l$个，所以总共能填入$min(a_i-1-i,l)$个</p>
<p>同理考虑$a_i$右侧空位，有$m-a_i$个，总是可以将$a_{i+1},a_{i+2},\cdots,a_{k-1}$，剩余$m-a_i-(k-1-i)$个位置，将$r$个填入，总共能填入$min(m-a_i-(k-1-i), r)$个。</p>
<p>对于所有$a_i$，维护这二者最大值+k为答案。</p>
<p>还有两种特殊情况就是如果一开始就是放置的1位置或者m位置，那么对应的l和r就不能使用。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">-2</span>) &#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    a.<span class="built_in">erase</span>(<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> asz = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">min</span>(<span class="built_in">max</span>(l, r) + asz, m);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; asz; i++) &#123;</span><br><span class="line">        <span class="type">int</span> lcnt = a[i] - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rcnt = m - a[i];</span><br><span class="line">        <span class="comment">// cout &lt;&lt; lcnt &lt;&lt; &quot; &quot; &lt;&lt; rcnt &lt;&lt; &quot; \n&quot;;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; a[i] &lt;&lt; &quot;--&quot;;</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(lcnt - i, l) + <span class="built_in">min</span>(rcnt - (asz - i - <span class="number">1</span>), r) + asz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D2-LuoTianyi-and-the-Floating-Islands-Hard-Version"><a href="#D2-LuoTianyi-and-the-Floating-Islands-Hard-Version" class="headerlink" title="D2. LuoTianyi and the Floating Islands (Hard Version)"></a>D2. LuoTianyi and the Floating Islands (Hard Version)</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>简单版本k≤3,困难版k≤n</p>
<p>有一些岛屿共n个，岛屿之间的路径形成了一颗树，你需要将k个人分配到不同的岛屿。</p>
<p>如果一个岛屿到分配了k个人岛屿的路径之和是在所有岛屿中最小的，那么这个岛屿就是好岛屿。</p>
<p>现在求在所有分配方式中好岛屿的期望个数。模1e9+7</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>对于k为奇数， 每种分配方式只有一个好点，所有期望是1.</p>
<p>对于k为偶数，我们考虑好边的期望，好边的期望+1就是好点的期望。</p>
<p>$Y=好边的数目$</p>
<p>$X_i = 边i是否为好边，X_i = 1是，X_i = 0否$</p>
<p>$Y = \sum X_i$</p>
<p>期望线性性</p>
<p>$E(Y) = E(\sum X_i) = \sum E(X_i)$</p>
<p>$E(X_i) = 1\times P(X_i = 1) +0\times P(X_i = 0)$</p>
<p>所以每条边是好边的概率之和就是好边的期望</p>
<p>对于一条边是好边的概率如何算？</p>
<p>只需要分别将k/2个点分给在这条边所连通的两个连通块即可。</p>
<p>设1为树的根节点，若u为v的父节点，对于边$&lt;u,v&gt;$为好边的概率是$\frac{\binom{sz_v}{\frac{k}{2}}\binom{n-sz_v}{\frac{k}{2}}}{\binom{n}{k}}$</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> sz[N];  <span class="comment">// cnt[i] i的子树节点个数</span></span><br><span class="line"></span><br><span class="line">ll fac[N];  <span class="comment">// fac[i] i!</span></span><br><span class="line">ll inv[N];  <span class="comment">// inv[i] i! 逆元</span></span><br><span class="line"></span><br><span class="line">ll n, k;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll rt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            rt = rt * x % MOD;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % MOD * inv[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        <span class="keyword">if</span> (sz[v] &gt;= k / <span class="number">2</span> &amp;&amp; n - sz[v] &gt;= k / <span class="number">2</span>) &#123;</span><br><span class="line">            ans += <span class="built_in">C</span>(sz[v], k / <span class="number">2</span>) * <span class="built_in">C</span>(n - sz[v], k / <span class="number">2</span>) % MOD;</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[n] = <span class="built_in">fpow</span>(fac[n], MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    ans *= fac[n - k] * fac[k] % MOD;</span><br><span class="line">    ans %= MOD;</span><br><span class="line">    ans = ans * inv[n] % MOD;</span><br><span class="line">    cout &lt;&lt; (ans + <span class="number">1</span>) % MOD &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-LuoTianyi-and-XOR-Tree"><a href="#E-LuoTianyi-and-XOR-Tree" class="headerlink" title="E. LuoTianyi and XOR-Tree"></a>E. LuoTianyi and XOR-Tree</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给出一颗有根树，根节点为1</p>
<p>现在每个节点都有一个值。我们可以修改节点的值为任意值</p>
<p>求修改最少的节点值使得所有从根节点到叶子的路径异或和为0</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>启发式合并</p>
<p>计算根节点到每个节点的路径异或和。</p>
<p>对于子节点中异或和的值出现次数最多的保留1次传给父节点，其余的需要修改。</p>
<p>这个涉及到集合的合并，我们只需要将小集合合并到大集合就可以保证不超时。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; f[N];  <span class="comment">// f[x] 从 根节点 到 点x的所有儿子 的异或和 的有重集合</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">1</span>;  <span class="comment">// 子树中最大值 精妙的初始值1</span></span><br><span class="line">    <span class="type">int</span> sz = <span class="number">0</span>;  <span class="comment">// u为根的树的节点数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        val[v] ^= val[u];</span><br><span class="line">        sz++;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        <span class="comment">// 启发式合并</span></span><br><span class="line">        <span class="keyword">if</span> (f[u].<span class="built_in">size</span>() &lt; f[v].<span class="built_in">size</span>())</span><br><span class="line">            <span class="built_in">swap</span>(f[u], f[v]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : f[v]) &#123;</span><br><span class="line">            f[u][i] += j;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, f[u][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mx != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = f[u].<span class="built_in">begin</span>(); it != f[u].<span class="built_in">end</span>();) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second != mx) &#123;</span><br><span class="line">                f[u].<span class="built_in">erase</span>(it++);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                it-&gt;second = <span class="number">1</span>;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (sz == <span class="number">0</span>)</span><br><span class="line">        f[u][val[u]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans += sz - mx;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; u &lt;&lt; &quot; val &quot; &lt;&lt; val[u] &lt;&lt; &quot; sz &quot; &lt;&lt; sz &lt;&lt; &quot; mx &quot; &lt;&lt; mx &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// for (auto [i, j] : f[u]) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; -- &quot; &lt;&lt; j &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; ans + (!f[<span class="number">1</span>].<span class="built_in">count</span>(<span class="number">0</span>)) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 148 (Rated for Div. 2)</title>
    <url>/2023/05/17/1832/</url>
    <content><![CDATA[<h1 id="Educational-Codeforces-Round-148-Rated-for-Div-2"><a href="#Educational-Codeforces-Round-148-Rated-for-Div-2" class="headerlink" title="Educational Codeforces Round 148 (Rated for Div. 2)"></a>Educational Codeforces Round 148 (Rated for Div. 2)</h1><p><a href="https://codeforces.com/contest/1832/problems">Complete problemset</a></p>
<h2 id="A-New-Palindrome"><a href="#A-New-Palindrome" class="headerlink" title="A. New Palindrome"></a>A. New Palindrome</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个回文串，求是否能够通过重组字符得到一个新的回文串</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>若回文串长度为n，在$[0,\frac{n}{2})$区间的字符存在不同，则可以形成新的回文串。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[<span class="number">0</span>]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Maximum-Sum"><a href="#B-Maximum-Sum" class="headerlink" title="B. Maximum Sum"></a>B. Maximum Sum</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出n个互补相同的数，求恰好k次操作后剩余的数的最大值。</p>
<p>每次操作可以移除最大值或者最小的两个值。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>如果我们移除了$x$个最大值，那么就要移除$2(k-x)$个最小值。</p>
<p>通过排序后求前缀和，$p_i$为前i个数的前缀和。</p>
<p>答案为$\max \limits_{i=0}^k p_{n-i}-p_{2k-2i}$</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : a) &#123;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">p</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] + a[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = p[n] - p[<span class="number">2</span> * k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, p[n - i] - p[<span class="number">2</span> * (k - i)]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Contrast-Value"><a href="#C-Contrast-Value" class="headerlink" title="C. Contrast Value"></a>C. Contrast Value</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>对于数组$a_1, a_2, a_3, \cdots, a_n$的对比度值为$|a_1-a_2|+|a_2-a_3|+|a_3-a_4|+\cdots+|a_{n-1}-a_n|$。</p>
<p>现在要求从数组a中选出一个最短子序列b，使得b的对比度与a相同。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>对于改变单调性的点似乎需要选择。</p>
<p>去重，找改变单调性的所有点，再加上两个端点即可。</p>
<p>注意特殊情况：全部都是同一个值。只需要选择一个点。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    a.<span class="built_in">erase</span>(<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">2</span>] &lt; a[i - <span class="number">1</span>] &amp;&amp; a[i - <span class="number">1</span>] &gt; a[i])</span><br><span class="line">            c++;</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">2</span>] &gt; a[i - <span class="number">1</span>] &amp;&amp; a[i - <span class="number">1</span>] &lt; a[i])</span><br><span class="line">            c++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D1-Red-Blue-Operations-Easy-Version"><a href="#D1-Red-Blue-Operations-Easy-Version" class="headerlink" title="D1. Red-Blue Operations (Easy Version)"></a>D1. Red-Blue Operations (Easy Version)</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出n个数的数组$a_0,a_1,\cdots, a_{n-1}$，和q次查询</p>
<p>数组每个元素有红蓝两种颜色，初始时，颜色为红色。</p>
<p>每次查询会给出一个k，然后执行k次操作：</p>
<p>第i次操作，我们可以选择数组中任意一个元素$a_i$，如果这个元素是红色则让$a_i+=i$；否则这个元素是蓝色则让$a_i-=i$</p>
<p>每次查询是独立的，问每次查询执行完k次操作后，数组中的最大的最小值是多少。</p>
<p>$n,q\le 1000$</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>贪心</p>
<p>对于k≤n，由于开始时都是红色， 每个值都可以增长，所以为了让最小值最大，应当对较小的值进行增长。让最小值增长k，让次小值增长k-1, 等等。我们对a进行升序排序，则对于$a_i+= k-i, i \in [0,k-1]$，然后从中选择最小的$a_i, i \in [0,n-1]$便是答案。</p>
<p>对于k≥n。我们对a进行升序排序。</p>
<ul>
<li>如果k-n是个偶数，则可以对$a_i+=k-i,i\in [0,n-1]$，然后求其最小值$mn = \min \limits_{i=0}^{n-1}a_i$。由于在初始时连续两次对同一个元素操作后会让该元素-1，并且颜色仍然是红色。所以剩余的k-n次操作相当于有$\frac{k-n}{2}$次-1操作。我们需要将这些-1分配到数组中，显然每个当前数组中每个值只要不小于mn则是可以减少的。所以先考虑当前数组最多能减少多少值使得mn不变。这个值是$\sum \limits_{i=0}^{n-1}a_i-mn$<ul>
<li>若$\sum \limits_{i=0}^{n-1}a_i-mn \ge \frac{k-n}{2}$，最小值不会发生变化，此时答案为mn。</li>
<li>若$\sum \limits_{i=0}^{n-1}a_i-mn &lt; \frac{k-n}{2}$，设$d=\frac{k-n}{2}-\sum \limits_{i=0}^{n-1}a_i-mn$ ，需要将d个-1操作均匀分配给n个mn，这样最小值就是$mn-\lceil\frac{d}{n}\rceil$</li>
</ul>
</li>
<li>如果k-n是个奇数，我们无法让所有元素变成蓝色，所以保留最大的元素不增长。可以对$a_i+=k-i,i\in [0,n-2]$，同样的剩余的k-n+1次操作是偶数，我们用与之前相同方法，可以算出最小值mn</li>
<li>注意n=1时，需要特殊处理。</li>
</ul>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= n) &#123;</span><br><span class="line">            ll mn = <span class="number">1e10</span> + <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; k)</span><br><span class="line">                    mn = <span class="built_in">min</span>(mn, a[i] + k - i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    mn = <span class="built_in">min</span>(mn, a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; mn &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vector&lt;ll&gt; <span class="built_in">b</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                b[i] += k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k % <span class="number">2</span>) &#123;</span><br><span class="line">                b[n - <span class="number">1</span>] += k--;</span><br><span class="line">            &#125;</span><br><span class="line">            ll mn = *<span class="built_in">min_element</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">            ll m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ll i : b) &#123;</span><br><span class="line">                m += i - mn;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m &lt; k / <span class="number">2</span>) &#123;</span><br><span class="line">                mn -= (k / <span class="number">2</span> - m + n - <span class="number">1</span>) / n;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; mn &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D2-Red-Blue-Operations-Hard-Version"><a href="#D2-Red-Blue-Operations-Hard-Version" class="headerlink" title="D2. Red-Blue Operations (Hard Version)"></a>D2. Red-Blue Operations (Hard Version)</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给出n个数的数组$a_0,a_1,\cdots, a_{n-1}$，和q次查询</p>
<p>数组每个元素有红蓝两种颜色，初始时，颜色为红色。</p>
<p>每次查询会给出一个k，然后执行k次操作：</p>
<p>第i次操作，我们可以选择数组中任意一个元素$a_i$，如果这个元素是红色则让$a_i+=i$；否则这个元素是蓝色则让$a_i-=i$</p>
<p>每次查询是独立的，问每次查询执行完k次操作后，数组中的最大的最小值是多少。</p>
<p>$n,q\le 200000$</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>数据变大。每次查询我们不能暴力。</p>
<p>所以需要能够快速计算最小值mn。</p>
<p>我们预处理出数组$b_i  = a_i -i$，并求出b的前缀最小值，$pmb_i$为$b_{0\cdots i}$中最小值。</p>
<p>当k&lt;n时，$pmb_{k-1}+k$则为前缀中的最小值，此时$a_{k\cdots n-1}$中的最小值是$a_k$。因此最小值$mn = min(pmb_{k-1}+k, a_k)$</p>
<p>当k≥n时，</p>
<ul>
<li>当k-n为偶数，$mn = pmb_{n-1}+k$，然后可以将$\frac{k-n}{2}$个-1分配到$b_0+k,b_1+k,\cdots,b_{n-1}+k$中。可以预先处理出$sum_b = \sum \limits_{i=0}^{i=n-1}b_i$，则考虑$sum_b + n\cdot k - n\cdot mn$ 与$\frac{k-n}{2}$的大小关系。从而确定是否更新$mn$</li>
<li>当k-n为奇数，$mn = \min (pmb_{n-2}+k, a_{n-1})$，然后可以将$\frac{k-n+1}{2}$个-1分配到$b_0+k,b_1+k,\cdots,b_{n-2}+k,a_{n-1}$中。考虑$sum_b - (a_{n-1}-(n-1)) + a_{n-1}+ (n-1)\cdot k - n\cdot mn$ 与$\frac{k-n+1}{2}$的大小关系。从而确定是否更新$mn$</li>
</ul>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : a) &#123;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    ll sum_b = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pre_min_b</span><span class="params">(n)</span></span>;  <span class="comment">// b[i] = a[i]-i, pre_min_b[i] = min(b[0...i])</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            pre_min_b[i] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pre_min_b[i] = <span class="built_in">min</span>(a[i] - i, pre_min_b[i - <span class="number">1</span>]);</span><br><span class="line">        sum_b += a[i] - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll k, mn;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            mn = a[<span class="number">0</span>] - k / <span class="number">2</span> + (k % <span class="number">2</span> ? k : <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; n) &#123;</span><br><span class="line">            mn = <span class="built_in">min</span>(pre_min_b[k - <span class="number">1</span>] + k, a[k]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((k - n + <span class="number">1</span>) % <span class="number">2</span>) &#123;</span><br><span class="line">                mn = pre_min_b[n - <span class="number">1</span>] + k;</span><br><span class="line">                <span class="comment">// 分配 (k-n)/2个-1 到 b[0]+k, b[1]+k, ..., b[n-2]+k, b[n-1]+k</span></span><br><span class="line">                <span class="keyword">if</span> (sum_b + n * (k - mn) &lt;</span><br><span class="line">                    (k - n) / <span class="number">2</span>) &#123;  <span class="comment">// -1多了，最小值不是mn了</span></span><br><span class="line">                    ll d = (k - n) / <span class="number">2</span> - sum_b - n * (k - mn);</span><br><span class="line">                    mn -= (d + n - <span class="number">1</span>) / n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mn = <span class="built_in">min</span>(pre_min_b[n - <span class="number">2</span>] + k, a[n - <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// 分配 (k-n+1)/2个-1 到 b[0]+k, b[1]+k, ..., b[n-2]+k, a[n-1]</span></span><br><span class="line">                <span class="comment">//  sum_b-(a[n-1]-(n-1))+a[n-1] + k*(n-1)= 序列总和</span></span><br><span class="line">                <span class="comment">//  考虑序列每个值都变为mn，序列总和-mn*n &lt; (k-n+1)/2</span></span><br><span class="line">                <span class="comment">//  则最小值将比mn小</span></span><br><span class="line">                <span class="keyword">if</span> (sum_b + (k + <span class="number">1</span>) * (n - <span class="number">1</span>) - mn * n &lt; (k - n + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">                    ll d = (k - n + <span class="number">1</span>) / <span class="number">2</span> - sum_b - (k + <span class="number">1</span>) * (n - <span class="number">1</span>) + mn * n;</span><br><span class="line">                    mn -= (d + n - <span class="number">1</span>) / n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; mn &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; fixed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Execution time: &quot;</span></span><br><span class="line">         &lt;&lt; (end_time - start_time) * (<span class="type">int</span>)<span class="number">1e3</span> / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-Combinatorics-Problem"><a href="#E-Combinatorics-Problem" class="headerlink" title="E. Combinatorics Problem"></a>E. Combinatorics Problem</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给出$n,a_1,x,y,m,k, (n\le 10^7; 0\le a_1,x,y &lt; m; 2 \le m \le 998244353; 1\le k \le 5)$</p>
<p>已知数组$a_{i} = a_{i-1}x+y \bmod n, 1&lt;i\le n$</p>
<p>$b_i = (\sum\limits_{j=1}^{i} \binom{i - j + 1}{k} \cdot a_j) \bmod 998244353$，当$x&lt;y$时$\binom{x}{y} = 0$。</p>
<p>求$\bigoplus \limits_{i=1}^{n} b_i*i$</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>$b_i = (\sum\limits_{j=1}^{i} \binom{i - j + 1}{k} \cdot a_j)$</p>
<p>$b_i = (\sum\limits_{j=1}^{i} \binom{i-j}{k} \cdot a_j) + (\sum\limits_{j=1}^{i} \binom{i-j}{k-1} \cdot a_j)$</p>
<p>设$dp_{i,k} = \sum\limits_{j=1}^{i} \binom{i - j + 1}{k} \cdot a_j$</p>
<p>$dp_{i,k} = dp_{i-1, k}+dp_{i-1, k-1}$</p>
<p>类似求杨辉三角。我们可以对a求k+1次前缀和。代码简洁。</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x, y, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a[<span class="number">1</span>] &gt;&gt; x &gt;&gt; y &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = (a[i - <span class="number">1</span>] * x + y) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            b[j] = b[j - <span class="number">1</span>] + a[j];</span><br><span class="line">            b[j] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans ^= a[i] * (k + i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; fixed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Execution time: &quot;</span></span><br><span class="line">         &lt;&lt; (end_time - start_time) * (<span class="type">int</span>)<span class="number">1e3</span> / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 878 (Div. 3)</title>
    <url>/2023/06/10/1840/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-878-Div-3"><a href="#Codeforces-Round-878-Div-3" class="headerlink" title="Codeforces Round 878 (Div. 3)"></a>Codeforces Round 878 (Div. 3)</h1><p><a href="https://codeforces.com/contest/1840/problems">Complete problemset</a></p>
<h2 id="A-Cipher-Shifer"><a href="#A-Cipher-Shifer" class="headerlink" title="A. Cipher Shifer"></a><a href="https://codeforces.com/contest/1840/problem/A">A. Cipher Shifer</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个串a，这个串是被加密的，现在需要找出原来的串。</p>
<p>原串的加密方式是对于每个字符<code>x</code>，修改为<code>x+任意数量与x不同的字符+x</code>。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们遍历加密后的串，对于当前字符x，我们跳过后面与他不同的字符以及与x相等的第一个字符。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        <span class="type">int</span> p = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; n &amp;&amp; s[p] != s[i])</span><br><span class="line">            p++;</span><br><span class="line">        i = p + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Binary-Cafe"><a href="#B-Binary-Cafe" class="headerlink" title="B. Binary Cafe"></a><a href="https://codeforces.com/contest/1840/problem/B">B. Binary Cafe</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出两个数n和k，问$2^0, 2^1, \cdots, 2^{k-1}$内有多少种子序列（可空）的和小于等于n。</p>
<p>n,k &lt; 1e9</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>直接看n以内的二进制数有多少个就行。显然是n+1个。<br>但是有些是不合法的高位可能超过了k。<br>所以找到一个$2^i&lt;=n+1$的i，答案就是$2^i$和$n+1$的最小值</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ll cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        cnt *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= n + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(n + <span class="number">1</span>, cnt) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Ski-Resort"><a href="#C-Ski-Resort" class="headerlink" title="C. Ski Resort"></a><a href="https://codeforces.com/contest/1840/problem/C">C. Ski Resort</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出接下来n天的温度，有个人想去度假滑雪，他需要至少玩连续k天，然后玩的这些天的温度必须都小于等于q。</p>
<p>问有多少种度假日期选择计划。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>以大于q的温度的作为分割点，得到若干连续子段。</p>
<p>对于第i个子段的长度若为$len_i$，如果$len_i &lt; k$无法度假，否则这个子段有$(len_i - k + 1 + 1)(len_i - k + 1)/2$种选法</p>
<p>统计每个子段的贡献，并求和便是答案，$\sum (len_i - k + 1 + 1)(len_i - k + 1)/2$</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, k, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    ll p = <span class="number">-1</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; q) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - p - <span class="number">1</span> &gt;= k)</span><br><span class="line">                ans += (i - p - k + <span class="number">1</span>) * (i - p - k) / <span class="number">2</span>;</span><br><span class="line">            p = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n - p - <span class="number">1</span> &gt;= k)</span><br><span class="line">        ans += (n - p - k + <span class="number">1</span>) * (n - p - k) / <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-Wooden-Toy-Festival"><a href="#D-Wooden-Toy-Festival" class="headerlink" title="D. Wooden Toy Festival"></a><a href="https://codeforces.com/contest/1840/problem/D">D. Wooden Toy Festival</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>转化一下题意，有n个车在一条数轴上，给出n个车的位置，现在需要在数轴上确定三个车库，每辆车车速每秒走一单位。问最少要多久能让所有车入库。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>二分。</p>
<p>假设需要m秒，那么每范围在2m内的车属于同一个车库。贪心可获得在m秒下需要多少车库y，随着m的增大y会减小（单调函数可二分）。我们只要保证y不大于3，则m是合法的。找到满足y不大于3的最小的m即可。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// for (int i : a)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; a[i] - a[i - 1] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">1e10</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ll m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>, c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] - a[p] &gt; <span class="number">2</span> * m)</span><br><span class="line">                p = i, c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; r &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-Character-Blocking"><a href="#E-Character-Blocking" class="headerlink" title="E. Character Blocking"></a><a href="https://codeforces.com/contest/1840/problem/E">E. Character Blocking</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给出两个字符串，s1和s2。</p>
<p>给出q次操作，每次操作有三种情况。</p>
<ol>
<li><p>禁用两个串的x位置t秒（t是固定的）。</p>
</li>
<li><p>交换同一个串或两个串内选出的两个字符（不包含禁用位置）。</p>
</li>
<li><p>输出在不包含禁用字符后是否两个串相等</p>
</li>
</ol>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>模拟</p>
<p>维护一个变量diff，表示当前字符串在不包含禁用的位置有多少位置不相等。</p>
<p>我们用一个队列存储被禁用的位置。队首与当时间戳的差为t则出队，恢复禁用。</p>
<p>在禁用操作时，禁用前不相等相等则dif减少，禁用后不相等相等则dif增加。不能交换禁用位置，所以无需考虑禁用后字符会变化。</p>
<p>交换时考虑是否交换同一个位置（无论涉及几个串）：</p>
<ul>
<li>如果是同一个位置，显然交换后不会产生dif变化。</li>
<li>否则统计交换前与交换后两个位置的相等情况。</li>
</ul>
<p>最后对于输出操作，输出diff即可。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s[<span class="number">2</span>];</span><br><span class="line">    cin &gt;&gt; s[<span class="number">0</span>] &gt;&gt; s[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> t, q;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> dif = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        dif += (s[<span class="number">0</span>][i] != s[<span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    deque&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> opt;</span><br><span class="line">        cin &gt;&gt; opt;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> pos;</span><br><span class="line">            cin &gt;&gt; pos;</span><br><span class="line">            pos--;</span><br><span class="line">            dq.<span class="built_in">emplace_back</span>(i, pos);</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>][pos] != s[<span class="number">1</span>][pos])</span><br><span class="line">                dif--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> w1, p1, w2, p2;</span><br><span class="line">            cin &gt;&gt; w1 &gt;&gt; p1 &gt;&gt; w2 &gt;&gt; p2;</span><br><span class="line">            p1--;</span><br><span class="line">            p2--;</span><br><span class="line">            w1--;</span><br><span class="line">            w2--;</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(s[w1][p1], s[w2][p1]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> d1 = (s[<span class="number">0</span>][p1] != s[<span class="number">1</span>][p1]);</span><br><span class="line">                <span class="type">int</span> d2 = (s[<span class="number">0</span>][p2] != s[<span class="number">1</span>][p2]);</span><br><span class="line">                <span class="built_in">swap</span>(s[w1][p1], s[w2][p2]);</span><br><span class="line">                <span class="type">int</span> d3 = (s[<span class="number">0</span>][p1] != s[<span class="number">1</span>][p1]);</span><br><span class="line">                <span class="type">int</span> d4 = (s[<span class="number">0</span>][p2] != s[<span class="number">1</span>][p2]);</span><br><span class="line">                dif += d3 - d1;</span><br><span class="line">                dif += d4 - d2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (dq.<span class="built_in">size</span>() &amp;&amp; dq.<span class="built_in">front</span>().first + t &lt;= i) &#123;</span><br><span class="line">                <span class="type">int</span> pp = dq.<span class="built_in">front</span>().second;</span><br><span class="line">                <span class="keyword">if</span> (s[<span class="number">0</span>][pp] != s[<span class="number">1</span>][pp])</span><br><span class="line">                    dif++;</span><br><span class="line">                dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; (dif == <span class="number">0</span> ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (dq.<span class="built_in">size</span>() &amp;&amp; dq.<span class="built_in">front</span>().first + t &lt;= i) &#123;</span><br><span class="line">            <span class="type">int</span> pp = dq.<span class="built_in">front</span>().second;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">1</span>][pp] != s[<span class="number">0</span>][pp])</span><br><span class="line">                dif++;</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F-Railguns"><a href="#F-Railguns" class="headerlink" title="F. Railguns"></a><a href="https://codeforces.com/contest/1840/problem/F">F. Railguns</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给出一个二维矩阵大小n+1行m+1列。</p>
<p>有一些时刻，某行或某列会被死亡激光照射。</p>
<p>你现在在(0,0)位置，每秒可以让行或列坐标增加1，或不动。</p>
<p>目标是(n,m)位置，问最少所花时间是多少。</p>
<p>不能走出输出-1</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>广搜？dp？</p>
<p>设状态<code>dp[i][j][k]</code>为从起点到(i,j)位置时共计等待了k秒能否到达（0否 1是）。</p>
<p>初始化<code>dp[0][0][0] = 1</code>。</p>
<p>状态转移<code>dp[i][j][k] = dp[i-1][j][k] or dp[i][j-1][k] or dp[i][j][k-1]</code></p>
<p>可以通过广搜形式进行状态转移，每轮广搜让时间增长，同一时刻的某个状态可能由多个状态转移来，而队列中如果存储太多相同状态会超时，注意去重。</p>
<p>当能到达状态<code>dp[i][j][]</code>则有解。</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, r;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; r;</span><br><span class="line">    set&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t, d, c;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; d &gt;&gt; c;</span><br><span class="line">        st.<span class="built_in">insert</span>(&#123;t, d, c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> vis[n + <span class="number">1</span>][m + <span class="number">1</span>][r + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    queue&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> stp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// cout &lt;&lt; stp &lt;&lt; &quot;:&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y, w] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; w &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">count</span>(&#123;stp, <span class="number">1</span>, x&#125;) || st.<span class="built_in">count</span>(&#123;stp, <span class="number">2</span>, y&#125;)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x == n &amp;&amp; y == m) &#123;</span><br><span class="line">                cout &lt;&lt; stp &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt;= n &amp;&amp; vis[x + <span class="number">1</span>][y][w] != stp + <span class="number">1</span>)</span><br><span class="line">                q.<span class="built_in">emplace</span>(x + <span class="number">1</span>, y, w), vis[x + <span class="number">1</span>][y][w] = stp + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (y + <span class="number">1</span> &lt;= m &amp;&amp; vis[x][y + <span class="number">1</span>][w] != stp + <span class="number">1</span>)</span><br><span class="line">                q.<span class="built_in">emplace</span>(x, y + <span class="number">1</span>, w), vis[x][y + <span class="number">1</span>][w] = stp + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (w + <span class="number">1</span> &lt;= r &amp;&amp; vis[x][y][w + <span class="number">1</span>] != stp + <span class="number">1</span>)</span><br><span class="line">                q.<span class="built_in">emplace</span>(x, y, w + <span class="number">1</span>), vis[x][y][w + <span class="number">1</span>] = stp + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stp++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="G1-In-Search-of-Truth-Easy-Version"><a href="#G1-In-Search-of-Truth-Easy-Version" class="headerlink" title="G1. In Search of Truth (Easy Version)"></a><a href="https://codeforces.com/contest/1840/problem/G1">G1. In Search of Truth (Easy Version)</a></h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>给出一个未知的环形排列，当前位置的值是x，现在每次移动可以指定顺时针或逆时针以任意步长移动一步。现在求在2023次移动内找到这个排列的大小。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>分块</p>
<p>最多2023次，但是数组大小为1e6。成平方关系。</p>
<p>我们记录每个数第一次遇到的时刻。</p>
<p>先以走一步的方式走1000次，然后以步长为1000走1000次，必定有一个数会遇到两次，两次相遇的时间之差为答案。</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getval</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    cur += k;</span><br><span class="line">    cur %= a.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;cout &quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;cin &quot;</span> &lt;&lt; a[cur] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> a[cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> stp = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= stp; i++) &#123;</span><br><span class="line">        <span class="comment">// int v = getval(1);</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;+ 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        cin &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (mp[v] != <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; i - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[v] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * stp;; i += stp) &#123;</span><br><span class="line">        <span class="comment">// int v = getval(stp);</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;+ &quot;</span> &lt;&lt; stp &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        cin &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (mp[v] != <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; i - mp[v] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[v] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="G2-In-Search-of-Truth-Hard-Version"><a href="#G2-In-Search-of-Truth-Hard-Version" class="headerlink" title="G2. In Search of Truth (Hard Version)"></a><a href="https://codeforces.com/contest/1840/problem/G2">G2. In Search of Truth (Hard Version)</a></h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 863 (Div. 3) 1811</title>
    <url>/2023/05/17/1881/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-863-Div-3-1811"><a href="#Codeforces-Round-863-Div-3-1811" class="headerlink" title="Codeforces Round 863 (Div. 3) 1811"></a>Codeforces Round 863 (Div. 3) 1811</h1><p><a href="https://codeforces.com/contest/1811/problems">Complete problemset</a></p>
<h2 id="A-Insert-Digit"><a href="#A-Insert-Digit" class="headerlink" title="A. Insert Digit"></a>A. Insert Digit</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个10进制大数，然后需要插入一个数位d（0≤d≤9）。使得这个大数最大。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>当前位若严格小于待插入的d则插入。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d &gt; s[i] - <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">0</span>, i) &lt;&lt; d &lt;&lt; s.<span class="built_in">substr</span>(i) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; d &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Conveyor-Belts"><a href="#B-Conveyor-Belts" class="headerlink" title="B. Conveyor Belts"></a>B. Conveyor Belts</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>现在有一个n*n的矩阵，n是偶数。</p>
<p>代表有n/2个嵌套的环状履带。在履带上每秒可以移动到下一个位置。</p>
<p>每次可以向某个方向移动一步且不花费时间，问最少要多少步可以从(a, b)到(c,d)</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>只要计算这两个位置相隔了多少个履带即可。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, x1, y1, x2, y2;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    ll d1 = <span class="built_in">min</span>(&#123;x1, n - x1 + <span class="number">1</span>, y1, n - y1 + <span class="number">1</span>&#125;);</span><br><span class="line">    ll d2 = <span class="built_in">min</span>(&#123;x2, n - x2 + <span class="number">1</span>, y2, n - y2 + <span class="number">1</span>&#125;);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">abs</span>(d1 - d2) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Restore-the-Array"><a href="#C-Restore-the-Array" class="headerlink" title="C. Restore the Array"></a>C. Restore the Array</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>两个数组a和b，其中a的长度为n，b的长度为n-1，$b_i = max(a_i,a_{i+1})$</p>
<p>现在给出了b数组请构造一个a数组。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>对于$b_i &lt; b_{i+1}$，$a_{i+1} ≠ b_{i+1}$。所以一种构造法是$a_i = a_{i+1} = b_i, a_{i+2} = b_{i+1}$</p>
<p>其余情况则让$a_i = b_i$即可</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n - <span class="number">1</span>)</span>, <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; a[i - <span class="number">1</span>] &lt; a[i]) &#123;</span><br><span class="line">            ans[i] = a[i - <span class="number">1</span>];</span><br><span class="line">            ans[i + <span class="number">1</span>] = a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : ans) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-Umka-and-a-Long-Flight"><a href="#D-Umka-and-a-Long-Flight" class="headerlink" title="D. Umka and a Long Flight"></a>D. Umka and a Long Flight</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个宽度为$F_n$长度为$F_{n+1}$的矩形。$F_0 = F_1 = 1, F_n = F_{n-1}+F_{n-2}, n≥2$</p>
<p>给出一个位置(x,y)问在这个矩形中能否拆分成n+1个正方形，且最多只有两个正方形相等，其中一个正方形长度为1，位置在(x,y)。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>一个宽度为$F_n$长度为$F_{n+1}$的矩形，我们减去一个$F_n$边长的且不含(x,y)的正方形，对于剩余的一个长度为$F_{n-1}$宽度为$F_{n}$的矩形递归处理，当最后剩余的长度为1的正方形恰好为(x,y)位置则能拆分。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">46</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, y, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> n, <span class="type">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x1 == x &amp;&amp; y1 == y;</span><br><span class="line">    <span class="keyword">if</span> (o) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y1 &lt;= y &amp;&amp; y &lt; y1 + f[n])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">check</span>(x1, y1, x2, y1 + f[n], n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y1 + f[n] &lt;= y &amp;&amp; y &lt;= y2)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">check</span>(x1, y1 + f[n], x2, y2, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x1 &lt;= x &amp;&amp; x &lt; x1 + f[n])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">check</span>(x1, y1, x1 + f[n], y2, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x1 + f[n] &lt;= x &amp;&amp; x &lt;= x2)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">check</span>(x1 + f[n], y1, x2, y2, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">45</span>; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt;= 45; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; f[i] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">check</span>(<span class="number">1</span>, <span class="number">1</span>, f[n], f[n + <span class="number">1</span>], n, <span class="number">1</span>) ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-Living-Sequence"><a href="#E-Living-Sequence" class="headerlink" title="E. Living Sequence"></a>E. Living Sequence</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>求第k个不含4的数，$k≤10^{12}$。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>我们可以用数位dp求出n以内不含4的个数，这个数显然随着n增大而增大，有单调性，所以可以二分找到第一个使得不含4的个数等于k的n即可。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> limit, <span class="type">int</span> zero)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == s.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1LL</span> - zero;</span><br><span class="line">    <span class="keyword">if</span> (dp[p][limit][zero] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[p][limit][zero];</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zero == <span class="number">1</span>)</span><br><span class="line">        res += <span class="built_in">dfs</span>(p + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (zero ? <span class="number">1</span> : <span class="number">0</span>); i &lt;= (limit ? s[p] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        res += <span class="built_in">dfs</span>(p + <span class="number">1</span>, limit &amp;&amp; (i == s[p] - <span class="string">&#x27;0&#x27;</span>), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[p][limit][zero] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cnt</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    s = <span class="built_in">to_string</span>(n);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    ll l = <span class="number">1</span>, r = <span class="number">1e17</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ll m = (r - l) / <span class="number">2</span> + l;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; cnt(m) &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cnt</span>(m) &gt;= k) &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 144 (Rated for Div. 2) 1796</title>
    <url>/2023/05/17/1976/</url>
    <content><![CDATA[<h1 id="Educational-Codeforces-Round-144-Rated-for-Div-2-1796"><a href="#Educational-Codeforces-Round-144-Rated-for-Div-2-1796" class="headerlink" title="Educational Codeforces Round 144 (Rated for Div. 2) 1796"></a>Educational Codeforces Round 144 (Rated for Div. 2) 1796</h1><p><a href="https://codeforces.com/contest/1796/problems">Complete problemset</a></p>
<h2 id="A-Typical-Interview-Problem"><a href="#A-Typical-Interview-Problem" class="headerlink" title="A. Typical Interview Problem"></a>A. Typical Interview Problem</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>fb字符串是这样构造的</p>
<p>从整数1开始递增，当前数字如果能被3整除则fb串尾部增加f，否则如果能被5整除增加b，如果都能整除那么增加fb</p>
<p>给出一个不超过10的字符串问是否是fb的子串。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们打表发现fb串是有规律的，形如FBFFBFFBFBFFBFFBFBFFBFFBFBFFBFFBFBFFBFFBFBFFBFFBFBFFB…</p>
<p>我们截取一段超过20的fb子串，那么询问串如果是fb子串必定也是属于我们截取串的子串。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;FBFFBFFBFBFFBFFBFBFFBFFBFBFFBFFBFBFFBFFBFBFFBFFBFBFFB&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string u;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">substr</span>(i - n, n) == u) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Asterisk-Minor-Template"><a href="#B-Asterisk-Minor-Template" class="headerlink" title="B. Asterisk-Minor Template"></a>B. Asterisk-Minor Template</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>匹配模板的字符串asterisk-minor包含<em>和小写字母，且</em>的个数不超过字母个数。*可以匹配任意多个连续的字母。</p>
<p>现在给出两个字符串a和b，求一个asterisk-minor字符串使得能匹配这两个字符串。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>如果a和b的首字母相同则可以用首字母+*作为模式串。</p>
<p>如果a和b的末字母相同则可以用*+末字母作为模式串。</p>
<p>否则需要找到a和b中有两个连续字符相等，然后左右各接两个*。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    <span class="keyword">if</span> (u[<span class="number">0</span>] == v[<span class="number">0</span>]) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; u[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;*\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u.<span class="built_in">back</span>() == v.<span class="built_in">back</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; u.<span class="built_in">back</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; u.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; v.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u[i - <span class="number">1</span>] == v[j - <span class="number">1</span>] &amp;&amp; u[i] == v[j]) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; u[i - <span class="number">1</span>] &lt;&lt; u[i] &lt;&lt; <span class="string">&quot;*\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Maximum-Set"><a href="#C-Maximum-Set" class="headerlink" title="C. Maximum Set"></a>C. Maximum Set</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>漂亮集合是集合中的任意两个元素存在倍数关系。</p>
<p>现在求元素值属于[l,r]的漂亮最大漂亮集合的大小以及最大漂亮集合的个数。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>任意两个数可以整除，要让集合元素数尽可能多集合元素由小到大应该呈二倍关系。也就是说有一个最大的k满足$l*2^k≤r$，这个k就是最大集合的大小。</p>
<p>接下来要求集合的个数。</p>
<p>我们知道这个集合应该为${x,x<em>2,x</em>2^2,x<em>2^3,…,x</em>2^k}$，可见x的取值应该在$[l,\lfloor\frac{r}{2^k}\rfloor]$。</p>
<p>那么集合的个数就是$\lfloor\frac{r}{2^k}\rfloor-l+1$吗？</p>
<p>并不是，我们发现有可能$x*2^{k-1}*3≤r$，对于这样的x，后缀可以含3因子，因此共有k个集合。</p>
<p>值得注意的是对于大于3的情况无需考虑，因为$x*2^{k-1}*4&gt;r$。</p>
<p>由此我们得到了集合的个数是$\lfloor\frac{r}{2^k}\rfloor-l+1 + max(0, min(\lfloor\frac{r}{2^{r-1}<em>3}\rfloor, \lfloor\frac{r}{2^k}\rfloor))</em>(k-1)$，其中$k= log_2(\lfloor\frac{r}{l}\rfloor)$</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    ll k = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b * <span class="number">2</span> * l &lt;= r) &#123;</span><br><span class="line">        k++;</span><br><span class="line">        b *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mx = r / b,</span><br><span class="line">       ans = (mx - l + <span class="number">1</span> +</span><br><span class="line">              <span class="built_in">max</span>(<span class="number">0LL</span>, <span class="built_in">min</span>(mx, r / (b / <span class="number">2</span> * <span class="number">3</span>)) - l + <span class="number">1</span>) * (k - <span class="number">1</span>) % MOD) %</span><br><span class="line">             MOD;</span><br><span class="line">    <span class="comment">// ll mx = r / b, ans = 0;</span></span><br><span class="line">    <span class="comment">// for (ll i = l; i &lt;= mx; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     ans++;</span></span><br><span class="line">    <span class="comment">//     if (i * b / 2 * 3 &lt;= r)</span></span><br><span class="line">    <span class="comment">//         ans += k - 1;</span></span><br><span class="line">    <span class="comment">//     ans %= MOD;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    cout &lt;&lt; k &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-Maximum-Subarray"><a href="#D-Maximum-Subarray" class="headerlink" title="D. Maximum Subarray"></a>D. Maximum Subarray</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个长度n的数组，现在你需要恰好给这个数组中k个不同的位置+x，其余位置-x。然后问这个数组中的最大子串和为多少。</p>
<p>其中1≤n≤2e5; 0≤k≤min(20,n);  −1e9≤x≤1e9</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我们可以预处理每个位置都-x，然后选取k个位置+2x即可，每个位置有选与不选两种选择，我们还要考虑最大子串和。</p>
<p>我的dp状态，设$f_{i,j,u}$为前i个数选取j个加上2x后第i位是否加2x（u为1则是，u为0则否）的以i结尾的最大子数组和。</p>
<p>$f_{i,j,0} = max(f_{i-1,j,0}, f_{i-1, j, 1}, 0)+a[i]$</p>
<p>$f_{i,j,1} = max(f_{i-1,j-1,0}, f_{i-1, j-1, 1}, 0)+a[i]+2x$</p>
<p>在所有状态中可能是答案的状态应该满足n-i≥k-j</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line">ll f[N][<span class="number">25</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k, x;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] -= x;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; a[i] &lt;&lt; &quot;, &quot;;</span></span><br><span class="line">        <span class="built_in">memset</span>(f[i], <span class="number">0</span>, <span class="built_in">sizeof</span>(f[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    ll ans = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(i, k); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j) &#123;</span><br><span class="line">                f[i][j][<span class="number">1</span>] =</span><br><span class="line">                    <span class="built_in">max</span>(&#123;f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>], <span class="number">0LL</span>&#125;) + a[i] +</span><br><span class="line">                    <span class="number">2</span> * x;</span><br><span class="line">                <span class="keyword">if</span> (k - j &lt;= n - i)</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, f[i][j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= j) &#123;</span><br><span class="line">                f[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(&#123;f[i - <span class="number">1</span>][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j][<span class="number">0</span>], <span class="number">0LL</span>&#125;) + a[i];</span><br><span class="line">                <span class="keyword">if</span> (k - j &lt;= n - i)</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, f[i][j][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; 1 &quot; &lt;&lt; f[i][j][1] &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; 0 &quot; &lt;&lt; f[i][j][0] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>24C Sequence of points</title>
    <url>/2023/05/28/24C/</url>
    <content><![CDATA[<h1 id="Sequence-of-points"><a href="#Sequence-of-points" class="headerlink" title="Sequence of points"></a>Sequence of points</h1><p>Created by LXC on Sat May 20 19:50:44 2023</p>
<p><a href="https://codeforces.com/problemset/problem/24/C">https://codeforces.com/problemset/problem/24/C</a></p>
<p>ranting: 1800</p>
<p>tag: geometry, implementation, math</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出n个二维平面上的点$a_0, a_1, a_2, \cdots, a_3$，现在有一个点$m_0$，<br>每个$m_i$是$m_{i-1}$关于$a_{i-1 \bmod n}$的对称点。</p>
<p>注意n为奇数。</p>
<p>求解$m_j, j&lt;1e^{18}$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$mx_i=2*mx-mx_{i-1}$</p>
<p>$my_i=2*my-my_{i-1}$</p>
<p>由于n为奇数，我们发现$mx_{2n} = mx_{0}, my_{2n} = my_{0}$</p>
<p>所以先求出前2n项m。然后$m_{j\bmod 2n}$为答案。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mx[N], my[N], ax[N], ay[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, j;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; j;</span><br><span class="line">    cin &gt;&gt; mx[<span class="number">0</span>] &gt;&gt; my[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; ax[i] &gt;&gt; ay[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        mx[i] = <span class="number">2</span> * ax[(i - <span class="number">1</span>) % n] - mx[i - <span class="number">1</span>];</span><br><span class="line">        my[i] = <span class="number">2</span> * ay[(i - <span class="number">1</span>) % n] - my[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; mx[j % (<span class="number">2</span> * n)] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; my[j % (<span class="number">2</span> * n)] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>implementation</tag>
        <tag>math</tag>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title>359C Prime Number</title>
    <url>/2023/05/17/359C/</url>
    <content><![CDATA[<h1 id="Prime-Number"><a href="#Prime-Number" class="headerlink" title="Prime Number"></a>Prime Number</h1><p>Created by LXC on Mon May  8 00:14:52 2023</p>
<p><a href="https://codeforces.com/problemset/problem/359/C">https://codeforces.com/problemset/problem/359/C</a></p>
<p>ranting: 1900</p>
<p>tag: math, number theory</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个数组$a_1, a_2, \cdots, a_n$，以及一个质数x</p>
<p>求$\frac{1}{x^{a_1}}+\frac{1}{x^{a_2}}+\cdots+\frac{1}{x^{a_n}}=\frac{p}{q}$中p和q的最大共因数</p>
<p>这个数很大，最后答案模1e9+7</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>通分后$\frac{\sum x^{s-a_i}}{x^s}, s= \sum a_i$</p>
<p>看似我们只需要找到最小的$x^{s-a_i}$作为最大公因数，但是如果这个数出现了多次，合并同类项后系数又出现了x，这个时候就产生了新的一项$x^{s-a_i+1}$</p>
<p>所以我们的算法流程就是：<br>预处理出所有$s-a_i$。<br>然后不断的找最小值v，并统计v的出现次数c<br>如果c是x的倍数那么就需要和并生成c/x项v+1<br>如果c不是x的倍数虽然可以合并生成v+1，但是仍然存在v，所以我们的最小值仍然是v，答案也就找到了，为$x^v$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll rt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            rt = rt * x % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, x;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    ll s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i, s += i;</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : a)</span><br><span class="line">        i = s - i;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">rbegin</span>(), a.<span class="built_in">rend</span>());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ll c = <span class="number">0</span>, v = a.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">while</span> (a.<span class="built_in">size</span>() &amp;&amp; v == a.<span class="built_in">back</span>())</span><br><span class="line">            a.<span class="built_in">pop_back</span>(), c++;</span><br><span class="line">        <span class="keyword">if</span> (c % x == <span class="number">0</span>) &#123;</span><br><span class="line">            c /= x;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">                a.<span class="built_in">push_back</span>(v + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v = <span class="built_in">min</span>(v, s);</span><br><span class="line">            cout &lt;&lt; <span class="built_in">fpow</span>(x, v) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
        <tag>number theory</tag>
      </tags>
  </entry>
  <entry>
    <title>3n 块披萨</title>
    <url>/2023/04/09/3n%20%E5%9D%97%E6%8A%AB%E8%90%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/pizza-with-3n-slices/">1388. 3n 块披萨</a></p>
<hr>
<p>给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：</p>
<ul>
<li>  你挑选 <strong>任意</strong> 一块披萨。</li>
<li>  Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。</li>
<li>  Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。</li>
<li>  重复上述过程直到没有披萨剩下。</li>
</ul>
<p>每一块披萨的大小按顺时针方向由循环数组 <code>slices</code> 表示。</p>
<p>请你返回你可以获得的披萨大小总和的最大值。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_3_1723.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：slices = [1,2,3,4,5,6]</span><br><span class="line">输出：10</span><br><span class="line">解释：选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_4_1723.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：slices = [8,9,8,6,1,1]</span><br><span class="line">输出：16</span><br><span class="line">解释：两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= slices.length &lt;= 500</code></li>
<li>  <code>slices.length % 3 == 0</code></li>
<li><code>1 &lt;= slices[i] &lt;= 1000</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><del>读错题，每次是可以任选的，但是每次我都是基于上次选择左右，变成了博弈问题。</del></p>
<p>问题需要转化，我们选的披萨一定是不相邻的，所有不相邻的披萨的选择方式可以是我们所选的答案</p>
<p>可以用<code>f(i, j)</code>表示前i个数中选j个不同数的最大总和。</p>
<p>现在对于i是否选择分析状态转移。</p>
<p>当选择i时，在前i-2个数中选则j个<br><code>f(i, j) = f(i-2, j-1)+1</code></p>
<p>当不选择i时，就是前i-1个数中选择j个。<br><code>f(i, j) = f(i-1, j)</code></p>
<p>选择最大值作为转移<br><code>f(i,j) = max( f(i-2,j-1)+1, f(i-1,j) )</code></p>
<p>由于第一个和最后一个数是相邻的，我们需要去掉第一个数进行一次dp，去掉最后一个数进行dp，取最大值即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSizeSlices(self, slices: List[int]) -&gt; int:</span><br><span class="line">        n = len(slices)</span><br><span class="line">        def DP(s:List[int]) -&gt; int:</span><br><span class="line">            sz = len(s)</span><br><span class="line">            f = [[0]*sz for _ in range(sz)]</span><br><span class="line">            f[0][1], f[1][1] = s[0], max(s[0], s[1])</span><br><span class="line">            for i in range(2, sz):</span><br><span class="line">                for j in range(1, n//3+1):</span><br><span class="line">                    f[i][j] = max(f[i-1][j], f[i-2][j-1]+s[i])</span><br><span class="line">            return f[sz-1][n//3]</span><br><span class="line">        return max(DP(slices[1:]), DP(slices[:-1]))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>424C Magic Formulas</title>
    <url>/2023/05/17/424C/</url>
    <content><![CDATA[<h1 id="Magic-Formulas"><a href="#Magic-Formulas" class="headerlink" title="Magic Formulas"></a>Magic Formulas</h1><p>Created by LXC on Sun May  7 11:46:36 2023</p>
<p><a href="https://codeforces.com/problemset/problem/424/C">https://codeforces.com/problemset/problem/424/C</a></p>
<p>ranting: 1600</p>
<p>tag: math</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出n个数的序列$p_1,p_2,\cdots,p_n$，求$\bigoplus \limits_{i=1}^n (p_i\bigoplus \limits_{j=1}^n i \mod j)$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>找一下规律，当n = 5时</p>
<table>
<thead>
<tr>
<th align="center">i \ j</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>对于固定的j，i%j呈现周期变化</p>
<p>根据异或的性质，对于多个出现的相同的数，出现次数为奇数相当于异或了一次，出现了偶数次则相当于没有异或。</p>
<p>当n能被i整除时，考虑$\lfloor\frac{n}{i}\rfloor$的奇偶性。如果出现奇数次则对于<code>[0,i-1]</code>都出现了一次。</p>
<p>当n不能能被i整除时，存在余数<code>[1,n%i]</code>，$\lfloor\frac{i}{j}\rfloor$ 为偶数则<code>[1,n % i]</code>出现一次，否则<code>[0] and [n%i+1, i-1]</code>出现了一次。</p>
<p>这里我们做了多次区间修改，最后需要知道每个值出现了多少次。<br>这个完全可以使用差分数组做到。</p>
<p>另一种做法可以预处理出$f_i$为0到i的异或和。</p>
<p>初始化答案为0<br>每一个i，n/i为奇数则答案异或上$p_i\oplus f_{i-1} \oplus f_{n \mod i}$；n/i为偶数则答案异或上$p_i \oplus f_{n \mod i}$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i, ans ^= i;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> o = n / i % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o) &#123;  <span class="comment">// [0, i-1]</span></span><br><span class="line">                d[<span class="number">0</span>]++;</span><br><span class="line">                d[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o) &#123;  <span class="comment">// [0] and [n%i+1, i-1]</span></span><br><span class="line">                d[<span class="number">0</span>]++;</span><br><span class="line">                d[<span class="number">1</span>]--;</span><br><span class="line">                d[n % i + <span class="number">1</span>]++;</span><br><span class="line">                d[i]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// [1, n%i]</span></span><br><span class="line">                d[<span class="number">1</span>]++;</span><br><span class="line">                d[n % i + <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        c += d[i];</span><br><span class="line">        <span class="keyword">if</span> (c % <span class="number">2</span>)</span><br><span class="line">            ans ^= i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>442B Andrey and Problem</title>
    <url>/2023/05/17/442B/</url>
    <content><![CDATA[<h1 id="Andrey-and-Problem"><a href="#Andrey-and-Problem" class="headerlink" title="Andrey and Problem"></a>Andrey and Problem</h1><p>Created by LXC on Thu Apr 27 14:02:19 2023</p>
<p><a href="https://codeforces.com/problemset/problem/442/B">https://codeforces.com/problemset/problem/442/B</a></p>
<p>ranting: 1800</p>
<p>tag: greedy, math, probabilities</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个长度为n的浮点数数组a。数组每个值在0到1之间。</p>
<p>现在你要n个人出题。</p>
<p>第i个人出题成功的概率为<code>a[i]</code></p>
<p>如果可以从n个人中选一些人出题，恰好只有一个人出题的最大概率是多少？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>假设选了k个人那么恰好有一人成功的概率是：<br>$\sum \limits_{i=1}^{k} \prod \limits_{j \neq i} (1-a_j)$和式变换，分离变量后<br>$ \sum \limits_{i=1}^{k} \frac{a_i}{1-a_i} \prod \limits_{j=1}^{k} (1-a_j)$</p>
<p>令$S=\sum \limits_{i=1}^{k} \frac{a_i}{1-a_i}, P = \prod \limits_{j=1}^{k} (1-a_j)$</p>
<p>如果我们新增一个人u，概率的变化为$(S+\frac{a_u}{1-a_u})(P(1-a_u)) - S\cdot P = P\cdot a_u (1-S)$</p>
<p>由此我们看出，新增一个人u不能决定概率的增长，而是由前k个人的S所决定，若S&lt;1则概率会增长。而对于u只能决定增长概率的大小，若$a_u$越大则增长的概率越大。</p>
<p>因此，可以采取贪心的策略解决这个问题：</p>
<p>我们将概率进行排序。每次选择概率最大的，并计算S和P，当S大于1时则停止增加；当S不大于1时，概率是不会减少的，所以可以继续增加人数。由于$a_i$越大的人增长的概率会越大。我们优先选择概率大的。</p>
<p>因此在升序排序后的a中求最长使得S&lt;=1的后缀，并计算该后缀的P，答案就是PS。</p>
<p>这样为什么是正确的呢？<br>可以用反证法。如果最后成功概率最大时选了k个人，那么一定是a中最大的k个。试想如果u是a中最大的k个中的某一个，而最后选取的k个人中没有一个是u。由于任意k-1个人的S是不大于1的，根据前面公式，这个k人中概率最小的可以替换为u，让最终成功概率更大。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">prod((1-a[i])) sum(a[i]/(1-a[i]))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="keyword">if</span> (a[n - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> P = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        S += a[i] / (<span class="number">1</span> - a[i]);</span><br><span class="line">        P *= (<span class="number">1</span> - a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; P * S &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
        <tag>greedy</tag>
        <tag>probabilities</tag>
      </tags>
  </entry>
  <entry>
    <title>451C Predict Outcome of the Game</title>
    <url>/2023/05/17/451C/</url>
    <content><![CDATA[<h1 id="Predict-Outcome-of-the-Game"><a href="#Predict-Outcome-of-the-Game" class="headerlink" title="Predict Outcome of the Game"></a>Predict Outcome of the Game</h1><p>Created by LXC on Tue May  9 10:44:46 2023</p>
<p><a href="https://codeforces.com/problemset/problem/451/C">https://codeforces.com/problemset/problem/451/C</a></p>
<p>ranting: 1700</p>
<p>tag: brute force, implementation, math</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有三只球队举行比赛</p>
<p>共计n场比赛，每场比赛选两支队伍参与，必有一方会胜利。</p>
<p>现在已经进行了k场比赛，已知第一二支队伍的胜场之差的绝对值为d1，第二三支队伍的胜场之差的绝对值为d2</p>
<p>问能否存在一种可能，在n场比赛后每支队伍的胜场一样。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>设k场比赛后三支队伍的胜场分别是x,y,z</p>
<p>那么有:<br>x+y+z = k<br>|x-y| = d1<br>|y-z| = d2</p>
<p>取绝对值后形成4个三元一次方程。<br>分别解出x,y,z。<br>只要满足0&lt;=x&lt;=n/3,0&lt;=y&lt;=n/3,0&lt;=z&lt;=n/3即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll n, k, d1, d2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll x, ll y, ll z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; z % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; <span class="number">0</span> &lt;= x / <span class="number">3</span> &amp;&amp;</span><br><span class="line">            <span class="number">0</span> &lt;= y / <span class="number">3</span> &amp;&amp; <span class="number">0</span> &lt;= z / <span class="number">3</span> &amp;&amp; x / <span class="number">3</span> &lt;= n / <span class="number">3</span> &amp;&amp; y / <span class="number">3</span> &lt;= n / <span class="number">3</span> &amp;&amp;</span><br><span class="line">            z / <span class="number">3</span> &lt;= n / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; d1 &gt;&gt; d2;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">3</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll x1 = k + <span class="number">2</span> * d1 + d2, y1 = k - d1 + d2, z1 = k - d1 - <span class="number">2</span> * d2;</span><br><span class="line">    ll x2 = k - <span class="number">2</span> * d1 + d2, y2 = k + d1 + d2, z2 = k + d1 - <span class="number">2</span> * d2;</span><br><span class="line">    ll x3 = k + <span class="number">2</span> * d1 - d2, y3 = k - d1 - d2, z3 = k - d1 + <span class="number">2</span> * d2;</span><br><span class="line">    ll x4 = k - <span class="number">2</span> * d1 - d2, y4 = k + d1 - d2, z4 = k + d1 + <span class="number">2</span> * d2;</span><br><span class="line">    cout &lt;&lt; ((<span class="built_in">check</span>(x1, y1, z1) || <span class="built_in">check</span>(x2, y2, z2) || <span class="built_in">check</span>(x3, y3, z3) ||</span><br><span class="line">              <span class="built_in">check</span>(x4, y4, z4))</span><br><span class="line">                 ? <span class="string">&quot;yes\n&quot;</span></span><br><span class="line">                 : <span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>implementation</tag>
        <tag>math</tag>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>464A No to Palindromes!</title>
    <url>/2023/05/17/464A/</url>
    <content><![CDATA[<h1 id="No-to-Palindromes"><a href="#No-to-Palindromes" class="headerlink" title="No to Palindromes!"></a>No to Palindromes!</h1><p>Created by LXC on Sat Apr 29 13:27:26 2023</p>
<p><a href="https://codeforces.com/problemset/problem/464/A">https://codeforces.com/problemset/problem/464/A</a></p>
<p>ranting: 1700</p>
<p>tag: greedy, strings</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出n和p</p>
<p>给出一个字符串，由小写字母组成。</p>
<p>这个字符串是tolerable，当字符串没有长度超过1的回文子串。且字符串中每个字母的字典序都不超过p。</p>
<p>给出的字符串是tolerable的，求按照字典序升序下一个tolerable的串</p>
<p>如果没有就输出no</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>只要任意相邻的字母不相等，且间距为1的字母不相等则这个串就是tolerable。</p>
<p>我们增长一个字母的字典序这样就可以让原字符串的字典序增长。</p>
<p>而为了保证字典序增大程度尽可能小，需要从后向前考虑找到一个字符<code>s[x]</code>，并增长字符字典序，增长字典序后的<code>s[x]</code>保证与<code>s[x-1], s[x-2]</code>不同</p>
<p>如果我们找到了一个可以增长的位置x，那么其实也就找到了答案。</p>
<p><code>s[x]</code>之后的后缀可以从<code>abc</code>中选择构造，并保证构造的字符与前两个字母不同。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, p;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;a&quot;</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;b\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;ab&quot;</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ba\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> j = s[i] + <span class="number">1</span>; j &lt; <span class="string">&#x27;a&#x27;</span> + p; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] == j)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; s[i - <span class="number">2</span>] == j)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            s[i] = j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">                <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span> (k - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[k - <span class="number">1</span>] == c ||</span><br><span class="line">                       k - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; s[k - <span class="number">2</span>] == c)</span><br><span class="line">                    c++;</span><br><span class="line">                s[k] = c;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>greedy</tag>
        <tag>strings</tag>
      </tags>
  </entry>
  <entry>
    <title>51C Three Base Stations</title>
    <url>/2023/05/17/51C/</url>
    <content><![CDATA[<h1 id="Three-Base-Stations"><a href="#Three-Base-Stations" class="headerlink" title="Three Base Stations"></a>Three Base Stations</h1><p>Created by LXC on Thu May  4 00:56:54 2023</p>
<p><a href="https://codeforces.com/problemset/problem/51/C">https://codeforces.com/problemset/problem/51/C</a></p>
<p>ranting: 1800</p>
<p>tag: binary search, greedy</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n个村庄在一条数轴上排列</p>
<p>给出n个数字代表n个村庄的位置</p>
<p>现在要建立三个基站，三个基站的信号强度都是d，当在x位置建立基站时，信号覆盖范围在<code>[x-d,x+d]</code>。</p>
<p>求最小的信号强度，以及三个基站的位置，使得所有村庄可以被信号覆盖。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们二分答案。确定信号强度。</p>
<p>然后贪心，如果所有村庄分成长度不超过2d的段数不超过3则说明当前的信号强度可行。显然大于这个信号强度的分段数也是不超过3的。所以可以二分从小到大找到第一个满足的d。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : v)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    <span class="comment">// if (n&lt;=3) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;0\n&quot;;</span></span><br><span class="line">    <span class="comment">//     for (ll i:v) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = v[n - <span class="number">1</span>] - v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt;= <span class="number">1e-7</span>) &#123;</span><br><span class="line">        <span class="type">double</span> m = (r - l) / <span class="number">2</span> + l;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] - v[p] &gt; m)</span><br><span class="line">                p = i, c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; r / <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] - v[p] &gt; r) &#123;</span><br><span class="line">            cout &lt;&lt; (v[i - <span class="number">1</span>] + v[p]) / <span class="number">2.0</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            c++;</span><br><span class="line">            p = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; (v[n - <span class="number">1</span>] + v[p]) / <span class="number">2.0</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>binary search</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>535D Tavas and Malekas</title>
    <url>/2023/06/20/535D/</url>
    <content><![CDATA[<h1 id="Tavas-and-Malekas"><a href="#Tavas-and-Malekas" class="headerlink" title="Tavas and Malekas"></a>Tavas and Malekas</h1><p>Created by LXC on Tue Jun 20 08:46:07 2023</p>
<p><a href="https://codeforces.com/problemset/problem/535/D">https://codeforces.com/problemset/problem/535/D</a></p>
<p>ranting: 1900</p>
<p>tag: greedy, hashing, string suffix structures, strings</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>有个一个长度为n的未知串s，和一个长度为p的已知串t。</p>
<p>给出m长度的非降序数组$a_1, a_2, \cdots, a_m$。</p>
<p>问满足$s[a_i,a_i+p-1] = t$的串有多少种？</p>
<p>字符串仅由小写英文字母组成。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>如果设字符串下标从0开始。</p>
<p>我们设覆盖的最右端的位置+1为r。</p>
<p>显然当前点$a_i$如果小于r，设$d=r-a_i$，当$s[0…d-1] \ne s[p-d…p-1]$，会产生覆盖的冲突，答案为0。<br>否则有$r-a_i$个自由字符，根据乘法原理答案累乘$26^{r-a_i}$。</p>
<p>现在关键在于判断字符串的前后缀是否相等。可以用很多种方法。</p>
<p>使用字符串哈希，这是个概率算法。有测试用例出现哈希冲突。使用多重哈希大大增加通过概率。</p>
<p>最后用后缀数组ac了。这个板子确实好用。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000006</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE 151</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单哈希容易被卡，封装用多重哈希</span></span><br><span class="line"><span class="comment">// 两个串的哈希相等，说明串大概率相等。</span></span><br><span class="line"><span class="comment">// struct Hash &#123;</span></span><br><span class="line"><span class="comment">// #define ull unsigned long long</span></span><br><span class="line"><span class="comment">//     // string s[] index from 0 to n-1</span></span><br><span class="line"><span class="comment">//     // B[i] = BASE^i</span></span><br><span class="line"><span class="comment">//     // s[i...j] = s[0...j] - s[0...i-1]</span></span><br><span class="line"><span class="comment">//     // hash s[0...i-1] = H[i] = s[0]*B[i-1]+s[1]*B[i-2]+...+s[i-1]*B[0]</span></span><br><span class="line"><span class="comment">//     // hash s[0...j] = H[j+1] = s[0]*B[j]+s[1]*B[j-1]+...+s[j]*B[0]</span></span><br><span class="line"><span class="comment">//     // hash s[i...j] = H[j+1] - H[i]*B[j-i+1]</span></span><br><span class="line"><span class="comment">//     // hash s[i...j-1] = H[j] - H[i]*B[j-i]</span></span><br><span class="line"><span class="comment">//     vector&lt;ull&gt; H, B;</span></span><br><span class="line"><span class="comment">//     ull len, base, mod;</span></span><br><span class="line"><span class="comment">//     Hash(string&amp; s, ull base = 131, ull mod = 998244353)</span></span><br><span class="line"><span class="comment">//         : H(s.size() + 1, 0),</span></span><br><span class="line"><span class="comment">//           B(s.size() + 1, 1),</span></span><br><span class="line"><span class="comment">//           len(s.size()),</span></span><br><span class="line"><span class="comment">//           base(base),</span></span><br><span class="line"><span class="comment">//           mod(mod) &#123;</span></span><br><span class="line"><span class="comment">//         for (int i = 1; i &lt;= len; i++) &#123;</span></span><br><span class="line"><span class="comment">//             H[i] = (H[i - 1] * base % mod + s[i - 1]) % mod;</span></span><br><span class="line"><span class="comment">//             B[i] = B[i - 1] * base % mod;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     ull hash(int l, int r) &#123;  // hash of s[l...r-1]</span></span><br><span class="line"><span class="comment">//         return (H[r] - H[l] * B[r - l] % mod + mod) % mod;</span></span><br><span class="line"><span class="comment">//     &#125;;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// struct Checker &#123;</span></span><br><span class="line"><span class="comment">//     vector&lt;Hash&gt; h;</span></span><br><span class="line"><span class="comment">//     Checker(string&amp; s) &#123;</span></span><br><span class="line"><span class="comment">//         // MOD 太大会溢出, 应在sqrt(ull)内</span></span><br><span class="line"><span class="comment">//         vector&lt;pair&lt;ull, ull&gt;&gt; param = &#123;&#123;131ull, 998244353ull&#125;,</span></span><br><span class="line"><span class="comment">//                                         &#123;151ull, 1000000007ull&#125;,</span></span><br><span class="line"><span class="comment">//                                         &#123;171ull, 998244357ull&#125;&#125;;</span></span><br><span class="line"><span class="comment">//         for (auto [i, j] : param) &#123;</span></span><br><span class="line"><span class="comment">//             h.emplace_back(s, i, j);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     // is s[l1...r1-1] == s[l2...r2-1] ? s[] index from 0</span></span><br><span class="line"><span class="comment">//     bool check(int l1, int r1, int l2, int r2) &#123;</span></span><br><span class="line"><span class="comment">//         for (auto&amp; i : h) &#123;</span></span><br><span class="line"><span class="comment">//             if (i.hash(l1, r1) != i.hash(l2, r2))</span></span><br><span class="line"><span class="comment">//                 return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return true;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void sol() &#123;</span></span><br><span class="line"><span class="comment">//     int n, m;</span></span><br><span class="line"><span class="comment">//     string s;</span></span><br><span class="line"><span class="comment">//     cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span></span><br><span class="line"><span class="comment">//     int len = s.size();</span></span><br><span class="line"><span class="comment">//     Checker ck(s);</span></span><br><span class="line"><span class="comment">//     ll ans = 1, r = 0;</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; m; i++) &#123;</span></span><br><span class="line"><span class="comment">//         int p;</span></span><br><span class="line"><span class="comment">//         cin &gt;&gt; p;</span></span><br><span class="line"><span class="comment">//         p--;</span></span><br><span class="line"><span class="comment">//         if (p &lt; r) &#123;</span></span><br><span class="line"><span class="comment">//             int d = r - p;</span></span><br><span class="line"><span class="comment">//             if (!ck.check(len - d, len, 0, d)) &#123;</span></span><br><span class="line"><span class="comment">//                 cout &lt;&lt; &quot;0\n&quot;;</span></span><br><span class="line"><span class="comment">//                 return;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//             for (int i = r; i &lt; p; i++)</span></span><br><span class="line"><span class="comment">//                 ans *= 26, ans %= MOD;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         r = p + len;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     for (; r &lt; n; r++)</span></span><br><span class="line"><span class="comment">//         ans *= 26, ans %= MOD;</span></span><br><span class="line"><span class="comment">//     cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后缀数组，生成sa，rk，height数组</span></span><br><span class="line"><span class="comment">// range应大于串的长度和串元素最大值。串中元素值应非负。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> = string, <span class="type">int</span> range = <span class="number">128</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> SuffixArray &#123;</span><br><span class="line">    T s;</span><br><span class="line">    <span class="type">int</span> n, bucketRange;</span><br><span class="line">    <span class="type">int</span> sa[range], second[range], bucket[range], mem[range], rk_mem[range + <span class="number">1</span>],</span><br><span class="line">        rk2_mem[range + <span class="number">1</span>], height[range], *rk, *rk2;</span><br><span class="line">    <span class="built_in">SuffixArray</span>(<span class="type">const</span> T&amp; _s) : <span class="built_in">s</span>(_s), <span class="built_in">n</span>(s.<span class="built_in">size</span>()), <span class="built_in">bucketRange</span>(range) &#123;</span><br><span class="line">        rk = rk_mem;</span><br><span class="line">        rk2 = rk2_mem;</span><br><span class="line">        rk[n] = rk2[n] = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(bucket, <span class="number">0</span>, <span class="built_in">sizeof</span>(bucket));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            bucket[rk[i] = s[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bucketRange; i++)</span><br><span class="line">            bucket[i] += bucket[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            sa[--bucket[rk[i]]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>;; w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n - w; i &lt; n; i++)</span><br><span class="line">                second[j++] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="keyword">if</span> (sa[i] &gt;= w)</span><br><span class="line">                    second[j++] = sa[i] - w;</span><br><span class="line">            <span class="built_in">memset</span>(bucket, <span class="number">0</span>, <span class="built_in">sizeof</span>(bucket));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                bucket[mem[i] = rk[second[i]]]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bucketRange; i++)</span><br><span class="line">                bucket[i] += bucket[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                sa[--bucket[mem[i]]] = second[i];</span><br><span class="line">            bucketRange = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                rk2[sa[i]] = !i || (rk[sa[i]] == rk[sa[i - <span class="number">1</span>]] &amp;&amp;</span><br><span class="line">                                    rk[sa[i] + w] == rk[sa[i - <span class="number">1</span>] + w])</span><br><span class="line">                                 ? bucketRange</span><br><span class="line">                                 : ++bucketRange;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(rk, rk2);</span><br><span class="line">            <span class="keyword">if</span> (++bucketRange == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(height, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(height));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, h = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h)</span><br><span class="line">                h--;</span><br><span class="line">            <span class="keyword">if</span> (rk[i])</span><br><span class="line">                <span class="keyword">while</span> (sa[rk[i] - <span class="number">1</span>] + h &lt; n &amp;&amp;</span><br><span class="line">                       s[i + h] == s[sa[rk[i] - <span class="number">1</span>] + h])</span><br><span class="line">                    h++;</span><br><span class="line">            height[rk[i]] = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    string s = <span class="string">&quot;aabaaaab&quot;</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">auto</span> SA = <span class="keyword">new</span> <span class="built_in">SuffixArray</span>&lt;string, N&gt;(s);</span><br><span class="line">    SA-&gt;<span class="built_in">getHeight</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; sa = SA-&gt;sa;</span><br><span class="line">    <span class="keyword">auto</span>&amp; rank = SA-&gt;rk;</span><br><span class="line">    <span class="keyword">auto</span>&amp; height = SA-&gt;height;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lcp</span><span class="params">(len, len)</span></span>;  <span class="comment">// 后缀i与后缀0的公共前缀长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = rank[<span class="number">0</span>], j = N; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        j = <span class="built_in">min</span>(j, height[i]);</span><br><span class="line">        lcp[sa[i - <span class="number">1</span>]] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = rank[<span class="number">0</span>] + <span class="number">1</span>, j = N; i &lt; len; i++) &#123;</span><br><span class="line">        j = <span class="built_in">min</span>(j, height[i]);</span><br><span class="line">        lcp[sa[i]] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i : lcp) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    ll ans = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        cin &gt;&gt; p;</span><br><span class="line">        p--;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> d = r - p;</span><br><span class="line">            <span class="keyword">if</span> (lcp[len - d] != d) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; p; i++)</span><br><span class="line">                ans *= <span class="number">26</span>, ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        r = p + len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; r &lt; n; r++)</span><br><span class="line">        ans *= <span class="number">26</span>, ans %= MOD;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>greedy</tag>
        <tag>strings</tag>
        <tag>hashing</tag>
        <tag>string suffix structures</tag>
      </tags>
  </entry>
  <entry>
    <title>549D Haar Features</title>
    <url>/2023/05/28/549D/</url>
    <content><![CDATA[<h1 id="Haar-Features"><a href="#Haar-Features" class="headerlink" title="Haar Features"></a>Haar Features</h1><p>Created by LXC on Sat May 27 17:15:27 2023</p>
<p><a href="https://codeforces.com/problemset/problem/549/D">https://codeforces.com/problemset/problem/549/D</a></p>
<p>ranting: 1900</p>
<p>tag: greedy, implementation</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>给定一个目标二维矩阵。</p>
<p>你有一个初始矩阵，初始矩阵元素全为0。<br>然后每次操作可以给一个二维前缀的所有元素增加任意值。</p>
<p>问能否通过最少的操作达到目标矩阵。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>我们可以求二维后缀和，当而为后缀和值不等于目标元素时，将其修改为目标元素，并增加1次操作。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (string&amp; i : s)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            a[i][j] = a[i + <span class="number">1</span>][j] + a[i][j + <span class="number">1</span>] - a[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j] != <span class="number">1</span>)</span><br><span class="line">                    a[i][j] = <span class="number">1</span>, ans++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j] != <span class="number">-1</span>)</span><br><span class="line">                    a[i][j] = <span class="number">-1</span>, ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>implementation</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>609D Gadgets for dollars and pounds</title>
    <url>/2023/06/13/609D/</url>
    <content><![CDATA[<h1 id="Gadgets-for-dollars-and-pounds"><a href="#Gadgets-for-dollars-and-pounds" class="headerlink" title="Gadgets for dollars and pounds"></a>Gadgets for dollars and pounds</h1><p>Created by LXC on Tue Jun 13 09:19:56 2023</p>
<p><a href="https://codeforces.com/problemset/problem/609/D">https://codeforces.com/problemset/problem/609/D</a></p>
<p>ranting: 2000</p>
<p>tag: binary search, greedy, two pointers</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>现在你需要买m件物品，每件物品的价格是c，种类是t。当种类为1号时，价格的单位是美元，当种类为2时，价格的单位是英镑。</p>
<p>给你接下来n天的美元和英镑的汇率，$a_i$代表第i天1美元可兑换的卢布，$b_i$代表第i天1英镑可兑换的卢布。</p>
<p>你现在有s卢布，问能够买至少k件物品（$k\le m$）的最少天数是多少。并构造一个包含购买物品的编号和日期的序列。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>看到最少天数，想到二分答案，并用贪心来验证答案。</p>
<p>对于一个指定的天数x，如果在前x天内能够买到k件物品，那么多加一天也能买到k件，显然是随着x的增长，结果由买不到k件变化到能买到k件。这其实也可看作单调非减函数。可以在这个单调函数上二分查找，找到最小的x能使得买到k件物品即可。</p>
<p>接下来是贪心验证能否买到k件。</p>
<p>对于前x天，我们分别选择美元和英镑汇率最小值，记作ma和mb，并记录这两天的日期da和db。显然买美元购买的物品要在da这样一天买最划算，英镑物品同理。<br>接下来我们需要从m个物品中选择k个物品，这k个物品有可能是用美元购买也有可能是用英镑购买。不妨设用美元买的物品个数为k1,设用英镑买的物品个数是k2。为了买到最便宜的货以买到更多的货，应该买k1件最便宜的美元商品，和k2件最便宜的英镑商品。我们可以枚举k1，进而得到k2 = k-k1。如果这种选购方法所花的钱不超过s，那么前x天是可以买到k件物品的。</p>
<p>对于贪心的实现的方法其实可以对商品排序，种类编号小的排前面，对于种类编号为1的价值降序排序，种类编号为2的升序排序。</p>
<p>随后便可以在这个序列上用滑动窗口算法，固定窗口大小为k，统计窗口内物品的价值，当价值不超过k便找到了一种选购方式。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> id, t, c;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> id, <span class="type">int</span> t, <span class="type">int</span> c) : <span class="built_in">id</span>(id), <span class="built_in">t</span>(t), <span class="built_in">c</span>(c) &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node&amp; o) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != o.t) &#123;</span><br><span class="line">            <span class="keyword">return</span> t &lt; o.t;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> c &gt; o.c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> c &lt; o.c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, m, k, s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : b)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    vector&lt;Node&gt; g;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t, c;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; c;</span><br><span class="line">        g.<span class="built_in">emplace_back</span>(i + <span class="number">1</span>, t, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; m; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; g[i].id &lt;&lt; &quot; &quot; &lt;&lt; g[i].c &lt;&lt; &quot; &quot; &lt;&lt; g[i].t &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    ll l = <span class="number">1</span>, r = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line">        ll ma = *<span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + mid);</span><br><span class="line">        ll mb = *<span class="built_in">min_element</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>() + mid);</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            cnt += (g[i].t == <span class="number">1</span> ? ma : mb) * g[i].c;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                cnt -= (g[i - k].t == <span class="number">1</span> ? ma : mb) * g[i - k].c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span> &amp;&amp; cnt &lt;= s) &#123;</span><br><span class="line">                ok = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r == n + <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; r &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        ll ma = *<span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + r);</span><br><span class="line">        ll mb = *<span class="built_in">min_element</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>() + r);</span><br><span class="line">        ll da, db;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == ma)</span><br><span class="line">                da = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (b[i] == mb)</span><br><span class="line">                db = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            cnt += (g[i].t == <span class="number">1</span> ? ma : mb) * g[i].c;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                cnt -= (g[i - k].t == <span class="number">1</span> ? ma : mb) * g[i - k].c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span> &amp;&amp; cnt &lt;= s) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i - k + <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                    cout &lt;&lt; g[j].id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (g[j].t == <span class="number">1</span> ? da : db) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>binary search</tag>
        <tag>greedy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>633D Fibonacci-ish</title>
    <url>/2023/05/17/633D/</url>
    <content><![CDATA[<h1 id="Fibonacci-ish"><a href="#Fibonacci-ish" class="headerlink" title="Fibonacci-ish"></a>Fibonacci-ish</h1><p>Created by LXC on Sun May 14 16:39:09 2023</p>
<p><a href="https://codeforces.com/problemset/problem/633/D">https://codeforces.com/problemset/problem/633/D</a></p>
<p>ranting: 2000</p>
<p>tag: brute force, dp, hashing, implementation, math</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出长度为n的数组$a_1, a_2, \cdots, a_n$，重排数组后。<br>求最大的k使得$a_i = a_{i-1}+a_{i-2}, 2&lt;i\le k$</p>
<p>n&lt;=1000</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们只需要确定前两项就行了，剩下的可以通过递推式在数组中查找是否存在。而这个类似斐波那契数列，当前两项均非0时，是指数增长的。所以数列的长度是对数数量级的O(logn)。</p>
<p>枚举前两项时间复杂度$O(n^2)$，查找后续$O(logn)$项可用平衡树$O(logn)$。<br>所以总时间复杂度$O((nlogn)^2)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    map&lt;ll, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (ll i : a)</span><br><span class="line">        mp[i]++;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mp.<span class="built_in">count</span>(<span class="number">0</span>))</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, mp[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j || a[i] == <span class="number">0</span> &amp;&amp; a[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">2</span>;</span><br><span class="line">            map&lt;ll, <span class="type">int</span>&gt; c;</span><br><span class="line">            ll p = a[i], q = a[j];</span><br><span class="line">            c[p]++;</span><br><span class="line">            c[q]++;</span><br><span class="line">            <span class="keyword">while</span> (mp.<span class="built_in">count</span>(p + q) &amp;&amp; ++c[p + q] &lt;= mp[p + q]) &#123;</span><br><span class="line">                <span class="type">int</span> t = p + q;</span><br><span class="line">                p = q;</span><br><span class="line">                q = t;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>dp</tag>
        <tag>implementation</tag>
        <tag>math</tag>
        <tag>brute force</tag>
        <tag>hashing</tag>
      </tags>
  </entry>
  <entry>
    <title>659F Polycarp and Hay</title>
    <url>/2023/06/08/659F/</url>
    <content><![CDATA[<h1 id="Polycarp-and-Hay"><a href="#Polycarp-and-Hay" class="headerlink" title="Polycarp and Hay"></a>Polycarp and Hay</h1><p>Created by LXC on Wed Jun  7 11:57:03 2023</p>
<p><a href="https://codeforces.com/problemset/problem/659/F">https://codeforces.com/problemset/problem/659/F</a></p>
<p>ranting: 2000</p>
<p>tag: dfs and similar, dsu, graphs, greedy, sortings</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>给出一个 n * m 的二维数组g，g中元素不超过1e8。</p>
<p>现在构造一个新的矩阵，矩阵中的值必须不大于原矩阵的值。且所有非0元素都等于原矩阵中的某个值，并且构造的矩阵所有元素值的和等于k。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>对原矩阵中的值按照降序排序，并逐个加入并查集中，对于当前元素值为x，如果相邻上下左右的元素值存在大于等于x，则将他们所在集合与x所在集合合并。</p>
<p>在合并后，如果x时k的因子，且k/x小于等于x所在集合的大小，那么可以从x所在集合中选取大小为k/x的连通块，将其所有值改为i，矩阵中其余值改为0，就得到了构造的合法矩阵。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>卡在第95个测试用例，焯！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[N][N];</span><br><span class="line"></span><br><span class="line">ll g[N][N];</span><br><span class="line"></span><br><span class="line">ll n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> st[N * N];</span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, ll lm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if (n == 1000 &amp;&amp; m == 1000) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; lm &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cnt--;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">        <span class="type">int</span> mx = x + (d - <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> my = y + (d - <span class="number">2</span>) % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; <span class="number">0</span> || mx &gt;= n || my &lt; <span class="number">0</span> || my &gt;= m || g[mx][my] &lt; lm ||</span><br><span class="line">            vis[mx][my])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(mx, my, lm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uf_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">-1</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">uf_find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> st[x] &lt; <span class="number">0</span> ? x : st[x] = <span class="built_in">uf_find</span>(st[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">uf_union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">uf_find</span>(x), fy = <span class="built_in">uf_find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">        st[fx] += st[fy];</span><br><span class="line">        st[fy] = fx;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">uf_init</span>();</span><br><span class="line">    map&lt;ll, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;ll&gt;&gt; mp;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">            mp[g[i][j]].<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;pair&lt;ll, ll&gt;&gt; root;  <span class="comment">// 区块大小，区块的根</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i, j] : mp) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : j) &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">uf_find</span>(x * m + y);</span><br><span class="line">            root.<span class="built_in">insert</span>(&#123;st[t], t&#125;);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">                <span class="type">int</span> mx = x + (d - <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> my = y + (d - <span class="number">2</span>) % <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mx &lt; <span class="number">0</span> || mx &gt;= n || my &lt; <span class="number">0</span> || my &gt;= m || g[mx][my] &lt; i)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> fa = <span class="built_in">uf_find</span>(mx * m + my), fb = <span class="built_in">uf_find</span>(x * m + y);</span><br><span class="line">                <span class="keyword">if</span> (root.<span class="built_in">count</span>(&#123;st[fa], fa&#125;))</span><br><span class="line">                    root.<span class="built_in">erase</span>(&#123;st[fa], fa&#125;);</span><br><span class="line">                <span class="keyword">if</span> (root.<span class="built_in">count</span>(&#123;st[fb], fb&#125;))</span><br><span class="line">                    root.<span class="built_in">erase</span>(&#123;st[fb], fb&#125;);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">uf_union</span>(mx * m + my, x * m + y)) &#123;</span><br><span class="line">                    fa = <span class="built_in">uf_find</span>(x * m + y);</span><br><span class="line">                    root.<span class="built_in">insert</span>(&#123;st[fa], fa&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    root.<span class="built_in">insert</span>(&#123;st[fa], fa&#125;);</span><br><span class="line">                    root.<span class="built_in">insert</span>(&#123;st[fb], fb&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; &#x27; &#x27; &lt;&lt; root.size() &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// for (int r : root) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; r / m &lt;&lt; &quot; &quot; &lt;&lt; r % m &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (k % i == <span class="number">0</span> &amp;&amp; -i * root.<span class="built_in">begin</span>()-&gt;first &gt;= k) &#123;</span><br><span class="line">            cnt = k / i;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// if (n == 990 &amp;&amp; m == 990) &#123;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; root.begin()-&gt;first &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dfs</span>(j[<span class="number">0</span>].first, j[<span class="number">0</span>].second, i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; m; c++) &#123;</span><br><span class="line">                    cout &lt;&lt; (vis[r][c] ? i : <span class="number">0</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>改了改实现，还是wa了，目测是continue</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[N][N];</span><br><span class="line"></span><br><span class="line">ll g[N][N];</span><br><span class="line"></span><br><span class="line">ll n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> st[N * N];</span><br><span class="line"></span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uf_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">-1</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">uf_find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> st[x] &lt; <span class="number">0</span> ? x : st[x] = <span class="built_in">uf_find</span>(st[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">uf_union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">uf_find</span>(x), fy = <span class="built_in">uf_find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">        st[fx] += st[fy];</span><br><span class="line">        st[fy] = fx;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cnt--;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">        <span class="type">int</span> mx = x + (d - <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> my = y + (d - <span class="number">2</span>) % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; <span class="number">0</span> || mx &gt;= n || my &lt; <span class="number">0</span> || my &gt;= m ||</span><br><span class="line">            <span class="built_in">uf_find</span>(mx * m + my) != id || vis[mx][my])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(mx, my, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">uf_init</span>();</span><br><span class="line">    vector&lt;pair&lt;ll, ll&gt;&gt; idx;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">            idx.<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(idx.<span class="built_in">begin</span>(), idx.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> g[a.first][a.second] &gt; g[b.first][b.second];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [ix, iy] : idx) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">            <span class="type">int</span> mx = ix + (d - <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> my = iy + (d - <span class="number">2</span>) % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mx &lt; <span class="number">0</span> || mx &gt;= n || my &lt; <span class="number">0</span> || my &gt;= m || g[mx][my] &lt; g[ix][iy])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">uf_union</span>(ix * m + iy, mx * m + my);</span><br><span class="line">            <span class="keyword">if</span> (k % g[ix][iy] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                -st[<span class="built_in">uf_find</span>(ix * m + iy)] &gt;= k / g[ix][iy]) &#123;</span><br><span class="line">                cnt = k / g[ix][iy];</span><br><span class="line">                <span class="built_in">dfs</span>(ix, iy, <span class="built_in">uf_find</span>(ix * m + iy));</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; m; c++) &#123;</span><br><span class="line">                        cout &lt;&lt; (vis[r][c] ? g[ix][iy] : <span class="number">0</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>wa了17次，终于ac了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[N][N];</span><br><span class="line"></span><br><span class="line">ll g[N][N];</span><br><span class="line"></span><br><span class="line">ll n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> st[N * N];</span><br><span class="line"></span><br><span class="line">ll cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uf_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">-1</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">uf_find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> st[x] &lt; <span class="number">0</span> ? x : st[x] = <span class="built_in">uf_find</span>(st[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">uf_union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">uf_find</span>(x), fy = <span class="built_in">uf_find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">        st[fx] += st[fy];</span><br><span class="line">        st[fy] = fx;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cnt--;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">        <span class="type">int</span> mx = x + (d - <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> my = y + (d - <span class="number">2</span>) % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; <span class="number">0</span> || mx &gt;= n || my &lt; <span class="number">0</span> || my &gt;= m ||</span><br><span class="line">            <span class="built_in">uf_find</span>(mx * m + my) != id || vis[mx][my])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(mx, my, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">uf_init</span>();</span><br><span class="line">    vector&lt;pair&lt;ll, ll&gt;&gt; idx;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">            idx.<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(idx.<span class="built_in">begin</span>(), idx.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> g[a.first][a.second] &gt; g[b.first][b.second];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [ix, iy] : idx) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">            <span class="type">int</span> mx = ix + (d - <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> my = iy + (d - <span class="number">2</span>) % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mx &lt; <span class="number">0</span> || mx &gt;= n || my &lt; <span class="number">0</span> || my &gt;= m || g[mx][my] &lt; g[ix][iy])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">uf_union</span>(ix * m + iy, mx * m + my);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k % g[ix][iy] == <span class="number">0</span> &amp;&amp; -st[<span class="built_in">uf_find</span>(ix * m + iy)] &gt;= k / g[ix][iy]) &#123;</span><br><span class="line">            cnt = k / g[ix][iy];</span><br><span class="line">            <span class="built_in">dfs</span>(ix, iy, <span class="built_in">uf_find</span>(ix * m + iy));</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; m; c++) &#123;</span><br><span class="line">                    cout &lt;&lt; (vis[r][c] ? g[ix][iy] : <span class="number">0</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>greedy</tag>
        <tag>sortings</tag>
        <tag>graphs</tag>
        <tag>dfs and similar</tag>
        <tag>dsu</tag>
      </tags>
  </entry>
  <entry>
    <title>696C PLEASE</title>
    <url>/2023/05/17/696C/</url>
    <content><![CDATA[<h1 id="PLEASE"><a href="#PLEASE" class="headerlink" title="PLEASE"></a>PLEASE</h1><p>Created by LXC on Sun Apr 30 02:23:46 2023</p>
<p><a href="https://codeforces.com/problemset/problem/696/C">https://codeforces.com/problemset/problem/696/C</a></p>
<p>ranting: 2000</p>
<p>tag: combinatorics, dp, implementation, math, matrices</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有三个杯子排成一行，中间的杯子盖住了硬币</p>
<p>然后进行n次操作，每次操作随机选取左边或者右边的杯子与中间的杯子进行交换。</p>
<p>问最后杯子在中间的概率是多少。</p>
<p>n非常大，所以用k个小于1e18的数的<strong>乘积</strong>表示n。</p>
<p>最后的概率需要表示为分数<code>p/q</code>的最简形式，也就是<code>gcd(p,q)=1</code></p>
<p>另外由于p和q巨大，所以p和q都需要模1e9+7</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们设$f_n$为第n次交换后硬币在中间的概率。</p>
<p>交换一次，硬币一定不在中间，所以$f_1 =0$</p>
<p>然后对于第i次交换，硬币一定不在中间的概率是$1-f_{i-1}$，硬币在左边或者右边的杯子里，所以有0.5的概率选中与中间交换。<br>所以$f_i = 0.5*(1-f_{i-1})$</p>
<p>即$f_i + 0.5*f_{i-1} = 0.5$<br>这个递推式不是齐次的。</p>
<p>我们化为齐次形如$a+bf_i + c(a+bf_{i-1}) = 0$，其中$a,b,c$为待定系数</p>
<p>求得$a = -\frac{2}{3}, b = 2, c = \frac{1}{2}$</p>
<p>所以$-\frac{2}{3} + 2f_i - \frac{1}{2}(-\frac{2}{3}+2f_{i-1}) = 0$</p>
<p>可令$g_i = -\frac{2}{3} + 2f_i$，则$g_1 = -\frac{2}{3}$</p>
<p>$g_i = -\frac{1}{2}g_{i-1}$，这是等比数列的递推式，其通项公式$g_i = \frac{g_i}{g_{i-1}} \cdot \frac{g_{i-1}}{g_{i-2}} \cdots\cdot \frac{g_{2}}{g_{1}}\cdot g_1 = -(-\frac{1}{2})^{i-1}\frac{2}{3}$</p>
<p>所以$f_i = -(-\frac{1}{2})^{i-1}\frac{1}{3}+\frac{1}{3} = \frac{(-2)^{i-1}-1}{(-2)^{i-1}3}$</p>
<p>当i为奇数时<br>$f_i = \frac{2^{i-1}-1}{2^{i-1}3}$</p>
<p>当i为偶数时<br>$f_i = \frac{2^{i-1}+1}{2^{i-1}3}$</p>
<p>显然$2^{i-1}\pm 1$不能被$2^{i-1}$整除，只需判断$2^{i-1}\pm 1$能否能被$3$整除，若能被3整除则需要化简分数（利用费马小定理将分子乘以3在模1e9+7下的逆元即可）。</p>
<p>实际上$\frac{2^奇+1}{3}，\frac{2^偶-1}{3}$为整数</p>
<p>通过$\frac{2^偶-1}{3} = \frac{(2^{偶/2}-1)(2^{偶/2}+1)}{3}$，$\frac{2^奇+1}{3} = \frac{2(2^{偶}-1)+3}{3}$可以将指数化小。而$\frac{2^1+1}{3}，\frac{2^2-1}{3}$为整数。</p>
<p>所以当i为奇数时$f_i = \frac{2^{i-1}-1}{3}$为整数；当i为偶数时$f_i = \frac{2^{i-1}+1}{3}$为整数</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll a, ll p, ll m)</span> </span>&#123;</span><br><span class="line">    ll rt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            rt *= a, rt %= m;</span><br><span class="line">        a = a * a % m;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="type">int</span> o = <span class="number">1</span>;</span><br><span class="line">    ll res = <span class="number">2</span>, mod3 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : v) &#123;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        res = <span class="built_in">fpow</span>(res, i, MOD);</span><br><span class="line">        mod3 = <span class="built_in">fpow</span>(mod3, i, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            o = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = res * <span class="built_in">fpow</span>(<span class="number">2</span>, MOD - <span class="number">2</span>, MOD) % MOD;</span><br><span class="line">    mod3 = mod3 * <span class="built_in">fpow</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>) % MOD;</span><br><span class="line">    <span class="keyword">if</span> (o) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mod3 + <span class="number">2</span>) % <span class="number">3</span> == <span class="number">0</span>)  <span class="comment">// p = 2^&#123;k-1&#125;-1 / 3  q = 2^&#123;k-1&#125;</span></span><br><span class="line">            cout &lt;&lt; (res - <span class="number">1</span> + MOD) % <span class="function">MOD * <span class="title">fpow</span><span class="params">(<span class="number">3</span>, MOD - <span class="number">2</span>, MOD)</span> % MOD &lt;&lt; &quot;/&quot;</span></span><br><span class="line"><span class="function">                 &lt;&lt; res &lt;&lt; &quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// p = 2^&#123;k-1&#125;-1  q = 2^&#123;k-1&#125;*3</span></span><br><span class="line">            cout &lt;&lt; (res - <span class="number">1</span> + MOD) % MOD &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; res * <span class="number">3</span> % MOD &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mod3 + <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span>)  <span class="comment">// p = 2^&#123;k-1&#125;+1 / 3  q= 2^&#123;k-1&#125;</span></span><br><span class="line">            cout &lt;&lt; (res + <span class="number">1</span>) % MOD * <span class="built_in">fpow</span>(<span class="number">3</span>, MOD - <span class="number">2</span>, MOD) % MOD &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; res</span><br><span class="line">                 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// p = 2^&#123;k-1&#125;+1  q= 2^&#123;k-1&#125;*3</span></span><br><span class="line">            cout &lt;&lt; (res + <span class="number">1</span>) % MOD &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; res * <span class="number">3</span> % MOD &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll a, ll p, ll m)</span> </span>&#123;</span><br><span class="line">    ll rt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            rt *= a, rt %= m;</span><br><span class="line">        a = a * a % m;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="type">int</span> o = <span class="number">1</span>;</span><br><span class="line">    ll res = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll&amp; i : v) &#123;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        res = <span class="built_in">fpow</span>(res, i, MOD) % MOD;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            o = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = res * <span class="built_in">fpow</span>(<span class="number">2</span>, MOD - <span class="number">2</span>, MOD) % MOD;</span><br><span class="line">    <span class="keyword">if</span> (o) &#123;</span><br><span class="line">        <span class="comment">// p = 2^&#123;n-1&#125;-1 / 3  q = 2^&#123;n-1&#125;</span></span><br><span class="line">        cout &lt;&lt; (res - <span class="number">1</span> + MOD) % <span class="function">MOD * <span class="title">fpow</span><span class="params">(<span class="number">3</span>, MOD - <span class="number">2</span>, MOD)</span> % MOD &lt;&lt; &quot;/&quot;</span></span><br><span class="line"><span class="function">             &lt;&lt; res &lt;&lt; &quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// p = 2^&#123;n-1&#125;+1 / 3  q= 2^&#123;n-1&#125;</span></span><br><span class="line">        cout &lt;&lt; (res + <span class="number">1</span>) % MOD * <span class="built_in">fpow</span>(<span class="number">3</span>, MOD - <span class="number">2</span>, MOD) % MOD &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; res</span><br><span class="line">             &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>dp</tag>
        <tag>implementation</tag>
        <tag>math</tag>
        <tag>combinatorics</tag>
        <tag>matrices</tag>
      </tags>
  </entry>
  <entry>
    <title>746C Tram</title>
    <url>/2023/05/17/746C/</url>
    <content><![CDATA[<h1 id="Tram"><a href="#Tram" class="headerlink" title="Tram"></a>Tram</h1><p>Created by LXC on Wed May 10 00:02:34 2023</p>
<p><a href="https://codeforces.com/problemset/problem/746/C">https://codeforces.com/problemset/problem/746/C</a></p>
<p>ranting: 1600</p>
<p>tag: constructive algorithms, implementation, math</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现有一条数轴，从0到s。</p>
<p>然后有一辆列车从p点以速度为每t1秒移动一米，往方向为d（d为-1向0走，d为1向s走）移动。<br>当移动到尽头时改变方向。</p>
<p>现在有个人想要从x1到x2，这个人可以移动的速度时每t2秒移动1米。中途如果与列车相遇可以立刻上车或下车。</p>
<p>求从x1到x2的最短的时间</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先如果车速比人速度慢没必要打车。</p>
<p>然后在车速大于人速度的情况下。</p>
<p>可以考虑当前p在首先经过x1的情况下再经过x2的时间u。<br>再考虑人直接从x1走到x2的时间v。<br>显然答案就是u和v的最小值。</p>
<p>这需要分类讨论，要考虑车x1和x2的大小，车与x1或x2的位置关系，以及车初始时的移动方向。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s, x1, x2, t1, t2, p, d;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; x1 &gt;&gt; x2 &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; p &gt;&gt; d;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">abs</span>(x2 - x1) * t2;</span><br><span class="line">    <span class="keyword">if</span> (t1 &gt; t2) &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; x2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &lt;= x1) &#123;</span><br><span class="line">                a = <span class="built_in">min</span>(a, (x2 - p) * t1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a = <span class="built_in">min</span>(a, (s - p + s + x2) * t1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = <span class="built_in">min</span>(a, (p + x2) * t1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &gt;= x1) &#123;</span><br><span class="line">                a = <span class="built_in">min</span>(a, (p - x2) * t1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a = <span class="built_in">min</span>(a, (p + s + s - x2) * t1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = <span class="built_in">min</span>(a, (s - p + s - x2) * t1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>implementation</tag>
        <tag>math</tag>
        <tag>constructive algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>76E Points</title>
    <url>/2023/06/14/76E/</url>
    <content><![CDATA[<h1 id="Points"><a href="#Points" class="headerlink" title="Points"></a>Points</h1><p>Created by LXC on Wed Jun 14 13:11:47 2023</p>
<p><a href="https://codeforces.com/problemset/problem/76/E">https://codeforces.com/problemset/problem/76/E</a></p>
<p>ranting: 1700</p>
<p>tag: implementation, math</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>给出二维平面上的n个整数坐标点。</p>
<p>求所有两个坐标的直线距离的平方之和。</p>
<p>$1\le n \le 10^5$</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>暴力做法是枚举任意两个点求其距离的平方，然后累加到答案中。$O(n^2)$时间复杂度会超时。</p>
<p>现在考虑优化到$O(n^2)$.</p>
<p>对于两个点$(x1,y1)$和$(x2,y2)$的距离的平方计算公式为$(x2-x1)^2 + (y2-y1)^2$，也就是说我们可以分别计算x和y的贡献。</p>
<p>举个例子来说，如果给出的坐标为$(x1,y1),(x2,y2),(x3,y3)$</p>
<p>答案应当是$(x2-x1)^2 + (y2-y1)^2 + (x3-x1)^2 + (y3-y1)^2 + (x3-x2)^2 + (y3-y2)^2$</p>
<p>可以拆分为$(x2-x1)^2 + (x3-x1)^2 + (x3-x2)^2$和$(y2-y1)^2 + (y3-y1)^2 + (y3-y2)^2$</p>
<p>可以给x以及y坐标排序再寻找相邻前缀是否存在子问题的关系。</p>
<p>设给出的n个坐标的x值排序后为$x_1, x_2, \cdot, x_n$；设给出的n个坐标的y值排序后为$y_1, y_2, \cdot, y_n$。</p>
<p>定义状态$R_i$为$x_1,x_2,\cdots,x_{i+1}$中任意两个点之间的距离平方和。</p>
<p>为方便计算$R_i$和$R_{i-1}$的递推关系，设dx是排序后相邻两个坐标的距离，$dx_i = x_{i+1}-x_{i}$。</p>
<p>我们观察一个例子$dx_1 = a, dx_2 = b, dx_3 = c, dx_4 = d$</p>
<p>$R_1 = a^2$</p>
<p>$R_2 = R_1+(a+b)^2+b^2 = R_1+2b^2+2ab+a^2$</p>
<p>$R_3 = R_2+(a+b+c)^2+(b+c)^2+c^2 = R_2+3c^2+2(a+2b)c+R_2-R_1$</p>
<p>$R_4 = R_3+(a+b+c+d)^2+(b+c+d)^2+(c+d)^2+d^2=R_3+4d^2+2(a+2b+3c)d+R_3-R_2$</p>
<p>通过观察得到递推式$R_i = 2R_{i-1}-R_{i-2}+i\cdot dx_i^2+2r_idx_i$，其中$R_0 = 0, R_1 = dx_1^2$。$r_i = \sum \limits_{j=1}^ij\cdot dx_{j}$。</p>
<p>对于n个点的y值同理可以定义状态$C_i$为$y_1,y_2,\cdots,y_{i+1}$中任意两个点之间的距离平方和。$dy_i = y_{i+1}-y_{i},c_i = \sum \limits_{j=1}^ij\cdot dy_{j}$。得到递推式$C_i = 2C_{i-1}-C_{i-2}+i\cdot dy_i^2+2c_idy_i$，其中$C_0 = 0, C_1 = dy_1^2$。</p>
<p>至此$R_{n-1}+C_{n-1}$为所求。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll x[N], y[N];</span><br><span class="line">ll dx[N], dy[N];</span><br><span class="line">ll r[N], c[N];</span><br><span class="line">ll R[N], C[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(x + <span class="number">1</span>, x + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(y + <span class="number">1</span>, y + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dx[i] = x[i + <span class="number">1</span>] - x[i];</span><br><span class="line">        dy[i] = y[i + <span class="number">1</span>] - y[i];</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; dx[i] &lt;&lt; &quot; &quot; &lt;&lt; dy[i] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        r[i] += r[i - <span class="number">1</span>] + i * dx[i];</span><br><span class="line">        c[i] += c[i - <span class="number">1</span>] + i * dy[i];</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; r[i] &lt;&lt; &quot; &quot; &lt;&lt; c[i] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    R[<span class="number">1</span>] = dx[<span class="number">1</span>] * dx[<span class="number">1</span>];</span><br><span class="line">    C[<span class="number">1</span>] = dy[<span class="number">1</span>] * dy[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        R[i] =</span><br><span class="line">            <span class="number">2</span> * R[i - <span class="number">1</span>] - R[i - <span class="number">2</span>] + i * dx[i] * dx[i] + <span class="number">2</span> * r[i - <span class="number">1</span>] * dx[i];</span><br><span class="line">        C[i] =</span><br><span class="line">            <span class="number">2</span> * C[i - <span class="number">1</span>] - C[i - <span class="number">2</span>] + i * dy[i] * dy[i] + <span class="number">2</span> * c[i - <span class="number">1</span>] * dy[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; R[n - <span class="number">1</span>] + C[n - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>implementation</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>785C Anton and Fairy Tale</title>
    <url>/2023/05/17/785C/</url>
    <content><![CDATA[<h1 id="Anton-and-Fairy-Tale"><a href="#Anton-and-Fairy-Tale" class="headerlink" title="Anton and Fairy Tale"></a>Anton and Fairy Tale</h1><p>Created by LXC on Fri Apr 28 11:56:29 2023</p>
<p><a href="https://codeforces.com/problemset/problem/785/C">https://codeforces.com/problemset/problem/785/C</a></p>
<p>ranting: 1600</p>
<p>tag: binary search, math</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出两个数n和m, (n,m&lt;=1e18)</p>
<p>有一堆谷共有n颗，</p>
<p>第i天会发生的事：</p>
<ol>
<li>给这堆谷最多加m颗，最多加到n。</li>
<li>有i只鸟会吃掉i颗，若不足i颗则吃光。</li>
</ol>
<p>问第几天会吃光。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>当m&gt;=n时，必须等到n天才能吃光</p>
<p>否则，<br>前m天后谷物仍然没有减少。<br>第m+i天开始，每天会减少m+i颗，但是第二天会增加m。<br>那么第m+i天鸟吃完后的谷子为<code>f(i) = n-(1+i)*i/2-m</code>。f(i)单调递减，二分找到第一个f(i)&lt;=0则是答案。</p>
<p>注意溢出。</p>
<p><del><code>n-(1+i)*i/2-m&lt;=0</code> 变形 <code>sqrt(2*(n-m)-i) &lt;= i</code></del>这个还是有精度问题。</p>
<p>我们注意到如果经过10^9天那么谷粒将减少大概10^18颗。<br>所以二分的上界取10^9数量级就行了，比如2e9</p>
<p>找到第一个(1+i)*i/2&lt;=n-m，i in [0, 1e9]。答案为m+i</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= n) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll l = <span class="number">0</span>, r = <span class="number">2e9</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            ll x = (r - l) / <span class="number">2</span> + l;</span><br><span class="line">            <span class="keyword">if</span> (n - m &lt;= (<span class="number">1LL</span> + x) * x / <span class="number">2</span>) &#123;</span><br><span class="line">                r = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = x + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; r + m &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>818F Level Generation</title>
    <url>/2023/05/17/818F/</url>
    <content><![CDATA[<h1 id="Level-Generation"><a href="#Level-Generation" class="headerlink" title="Level Generation"></a>Level Generation</h1><p>Created by LXC on Wed May  3 12:50:29 2023</p>
<p><a href="https://codeforces.com/problemset/problem/818/F">https://codeforces.com/problemset/problem/818/F</a></p>
<p>ranting: 2100</p>
<p>tag: binary search, math, ternary search</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个n个节点的图，至少有一半的边是桥。</p>
<p>问边数最多能是多少？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>选x个点组成完全子图，共有x(x-1)/2条边。</p>
<p>剩下n-x个点形成链连接到这个完全子图，存在n-x条桥，所以完全子图中只能保留最多n-x条边。</p>
<p>函数<br>f(x) = min(x*(x-1)/2, n-x)+n-x, (1&lt;=x&lt;=n)<br>是凸函数。</p>
<p>我们用三分法求最大值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选x个点组成完全子图，共有x(x-1)/2条边，</span></span><br><span class="line"><span class="comment">// n-x个点形成链连接到这个完全子图，存在n-x条桥，所以完全子图中只能保留最多n-x条边</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(x * (x - <span class="number">1</span>) / <span class="number">2</span>, n - x) + n - x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 至少选一个，至多选n个</span></span><br><span class="line">    ll l = <span class="number">1</span>, r = n, lans = <span class="built_in">f</span>(<span class="number">1</span>), rans = <span class="built_in">f</span>(n);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ll lmid = l + (r - l) / <span class="number">3</span>;  <span class="comment">// l + 1/3区间大小</span></span><br><span class="line">        ll rmid = r - (r - l) / <span class="number">3</span>;  <span class="comment">// r - 1/3区间大小</span></span><br><span class="line">        lans = <span class="built_in">f</span>(lmid), rans = <span class="built_in">f</span>(rmid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求凸函数的极大值</span></span><br><span class="line">        <span class="keyword">if</span> (lans &lt;= rans)</span><br><span class="line">            l = lmid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = rmid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求凸函数的极大值</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(lans, rans) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
        <tag>binary search</tag>
        <tag>ternary search</tag>
      </tags>
  </entry>
  <entry>
    <title>899D Shovel Sale</title>
    <url>/2023/06/06/899D/</url>
    <content><![CDATA[<h1 id="Shovel-Sale"><a href="#Shovel-Sale" class="headerlink" title="Shovel Sale"></a>Shovel Sale</h1><p>Created by LXC on Thu Jun  1 15:19:42 2023</p>
<p><a href="https://codeforces.com/problemset/problem/899/D">https://codeforces.com/problemset/problem/899/D</a></p>
<p>ranting: 1800</p>
<p>tag: constructive algorithms, math</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>求n以内的任意一对数，其和末尾的9在最多的情况下的个数。</p>
<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>通过打表找规律，发现</p>
<p>$[1,5)$的末尾9最多为0，</p>
<p>$[5,50)$的末尾9最多为1，</p>
<p>$[50,500)$的末尾9最多为2，</p>
<p>依次类推 $[5<em>10^i, 5</em>10^{i+1})$的末尾9最多为i+1</p>
<p>而对于 $[5<em>10^i, 5</em>10^{i+1})$ 可以分多段贡献。</p>
<p>$[5<em>10^i, 15</em>10^i)$ 中每个数贡献1，除了$10^{i+1}-1$贡献为0</p>
<p>$[15<em>10^i, 25</em>10^i)$ 中每个数贡献2，除了$2*10^{i+1}-1$贡献为1</p>
<p>$[25<em>10^i, 35</em>10^i)$ 中每个数贡献3，除了$3*10^{i+1}-1$贡献为2</p>
<p>$[35<em>10^i, 45</em>10^i)$ 中每个数贡献4，除了$4*10^{i+1}-1$贡献为3</p>
<p>$[45<em>10^i, 50</em>10^i)$ 中每个数贡献5，除了$5*10^{i+1}-1$贡献为4</p>
<p>对于$[1,5)$内n的贡献为$n*(n-1)/2$</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;  <span class="comment">// len, cnt</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s = i + n, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s % <span class="number">10</span> == <span class="number">9</span>) &#123;</span><br><span class="line">            s /= <span class="number">10</span>;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; len) &#123;</span><br><span class="line">            len = c;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == len &amp;&amp; c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;len, cnt&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1000</span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> rt = <span class="built_in">f</span>(i);</span><br><span class="line">        v.<span class="built_in">push_back</span>(rt);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; rt.first &lt;&lt; &quot; &quot; &lt;&lt; rt.second &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        p = <span class="built_in">max</span>(v[i].first, p);</span><br><span class="line">        <span class="keyword">if</span> (v[i].first == p) &#123;</span><br><span class="line">            d[p] += v[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d[p] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pt();</span></span><br><span class="line">    ll n, b = <span class="number">5</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        cout &lt;&lt; n * (n - <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (b * <span class="number">10</span> &lt;= n)</span><br><span class="line">        b *= <span class="number">10</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>, c = <span class="number">1</span>, cur = b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur + <span class="number">2</span> * b &lt; n) &#123;</span><br><span class="line">            ans += <span class="number">2</span> * b * c - <span class="number">1</span>;</span><br><span class="line">            cur += <span class="number">2</span> * b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += (n - cur) * c;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= cur + b)</span><br><span class="line">                ans--;</span><br><span class="line">            cur = n;</span><br><span class="line">        &#125;</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
        <tag>constructive algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>900C Remove Extra One</title>
    <url>/2023/05/17/900C/</url>
    <content><![CDATA[<h1 id="Remove-Extra-One"><a href="#Remove-Extra-One" class="headerlink" title="Remove Extra One"></a>Remove Extra One</h1><p>Created by LXC on Wed May 10 00:09:29 2023</p>
<p><a href="https://codeforces.com/problemset/problem/900/C">https://codeforces.com/problemset/problem/900/C</a></p>
<p>ranting: 1700</p>
<p>tag: brute force, data structures, math</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个1到n的排列a，如果<code>a[j] &lt; a[i], j&lt;i</code>，那么<code>a[i]</code>称之为record。</p>
<p>现在需要删除a中一个元素，然后使得剩余的数的record最大。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>个人思路</p>
<p>考虑删除一个数<code>a[i]</code>对后续有多少个数成为record，记为<code>rec[a[i]]</code></p>
<p>对于<code>a[j]</code>，如果前方只有一个数<code>a[i]</code>大于<code>a[j]</code>。那么<code>a[j]</code>可以为<code>rec[a[j]]</code>贡献1.</p>
<p>我们可以用树状数组找到前方有多少个数大于当前数，以及用单调栈求出前方最近的大于自己的数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; N; i += i &amp; -i) &#123;</span><br><span class="line">        A[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i = i &amp; (i - <span class="number">1</span>)) &#123;</span><br><span class="line">        rt += A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; st, <span class="built_in">c</span>(n + <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">rec</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// rec[i] i是否已经是 record</span></span><br><span class="line">    <span class="comment">// c[i] 删除i后能能产生的record数</span></span><br><span class="line">    <span class="comment">// 对于i，删掉它，record 将变为 record总数-rec[i]+c[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">add</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (st.<span class="built_in">size</span>() &amp;&amp; st.<span class="built_in">back</span>() &lt; x)</span><br><span class="line">            st.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; <span class="built_in">ask</span>(x) == i)</span><br><span class="line">            c[st.<span class="built_in">back</span>()]++;</span><br><span class="line">        st.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            sz++;</span><br><span class="line">            rec[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     if (rec[i])</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>, ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> e = sz - rec[i] + c[i];</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; e &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="keyword">if</span> (e &gt;= mx) &#123;</span><br><span class="line">            mx = e;</span><br><span class="line">            ans = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>data structures</tag>
        <tag>math</tag>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>975D Ghosts</title>
    <url>/2023/05/28/975D/</url>
    <content><![CDATA[<h1 id="Ghosts"><a href="#Ghosts" class="headerlink" title="Ghosts"></a>Ghosts</h1><p>Created by LXC on Tue May 23 00:20:54 2023</p>
<p><a href="https://codeforces.com/problemset/problem/975/D">https://codeforces.com/problemset/problem/975/D</a></p>
<p>ranting: 2000</p>
<p>tag: geometry, math</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出n个二维平面上的点，这些点在一条直线上 <code>y = a * x + b</code></p>
<p>每个点都给出了在x轴方向的速度和y轴方向的速度。</p>
<p>每个点都有一个碰撞次数，如果碰到另一个点则会增加该点的碰撞次数。</p>
<p>求所有点的碰撞次数总和。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑两个点$(x_i, y_i), (x_j, y_j)$在什么情况下会碰撞。</p>
<p>当同时满足$x_i+ v_{x_i} *t = x_j + v_{x_j} *t$以及$y_i+ v_{y_i} *t = y_j + v_{y_j} *t$时，则会碰撞。</p>
<p>已知$y_i = x_i* a+b$，所以</p>
<p>$\frac{x_i-x_j}{v_{x_j}-v_{x_i}} = t = \frac{y_i-y_j}{v_{y_j}-v_{y_i}} = \frac{a*(x_i-x_j)}{v_{y_j}-v_{y_i}} \Rightarrow \frac{1}{v_{x_j}-v_{x_i}} = \frac{a}{v_{y_j}-v_{y_i}}$</p>
<p>$a<em>v_{x_i}-v_{y_i} = a</em>v_{x_j}-v_{y_j} $</p>
<p>所有$a*v_{x_i}-v_{y_i}$相等但速度不相等（$v_{x_i} \ne v_{x_j} \wedge v_{y_i} \ne v_{y_j}$）的$(x_i, y_i)$将会相撞</p>
<p>我们统计所有相同速度的频数。</p>
<p>然后用哈希表记录所有$a*v_{x_i}-v_{y_i}$的个数。其中$i&lt;j$</p>
<p>然后对于当前速度$(v_{x_j},v_{y_j})$，哈希表中$a*v_{x_j}-v_{y_j}$的个数乘以当前$(v_{x_j},v_{y_j})$的频数再乘以2（由于两个点碰撞每个点都要增加贡献）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, a, b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    map&lt;pair&lt;ll, ll&gt;, ll&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ll x, vx, vy;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; vx &gt;&gt; vy;</span><br><span class="line">        mp[&#123;vx, vy&#125;]++;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;ll, ll&gt; cnt;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : mp) &#123;</span><br><span class="line">        ans += <span class="number">2</span> * cnt[a * i.first - i.second] * j;</span><br><span class="line">        cnt[a * i.first - i.second] += j;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
        <tag>math</tag>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title>K 次调整数组大小浪费的最小总空间</title>
    <url>/2023/04/09/K%20%E6%AC%A1%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E6%B5%AA%E8%B4%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%80%BB%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-total-space-wasted-with-k-resizing-operations/">1959. K 次调整数组大小浪费的最小总空间</a></p>
<hr>
<p>你正在设计一个动态数组。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 是 <code>i</code> 时刻数组中的元素数目。除此以外，你还有一个整数 <code>k</code> ，表示你可以 <strong>调整</strong> 数组大小的 <strong>最多</strong> 次数（每次都可以调整成 <strong>任意</strong> 大小）。</p>
<p><code>t</code> 时刻数组的大小 <code>sizet</code> 必须大于等于 <code>nums[t]</code> ，因为数组需要有足够的空间容纳所有元素。<code>t</code> 时刻 <strong>浪费的空间</strong> 为 <code>sizet - nums[t]</code> ，<strong>总</strong> 浪费空间为满足 <code>0 &lt;= t &lt; nums.length</code> 的每一个时刻 <code>t</code> 浪费的空间 <strong>之和</strong> 。</p>
<p>在调整数组大小不超过 <code>k</code> 次的前提下，请你返回 <strong>最小总浪费空间</strong> 。</p>
<p><strong>注意：</strong>数组最开始时可以为 <strong>任意大小</strong> ，且 <strong>不计入</strong> 调整大小的操作次数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,20], k = 0</span><br><span class="line">输出：10</span><br><span class="line">解释：size = [20,20].</span><br><span class="line">我们可以让数组初始大小为 20 。</span><br><span class="line">总浪费空间为 (20 - 10) + (20 - 20) = 10 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,20,30], k = 1</span><br><span class="line">输出：10</span><br><span class="line">解释：size = [20,20,30].</span><br><span class="line">我们可以让数组初始大小为 20 ，然后时刻 2 调整大小为 30 。</span><br><span class="line">总浪费空间为 (20 - 10) + (20 - 20) + (30 - 30) = 10 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,20,15,30,20], k = 2</span><br><span class="line">输出：15</span><br><span class="line">解释：size = [10,20,20,30,30].</span><br><span class="line">我们可以让数组初始大小为 10 ，时刻 1 调整大小为 20 ，时刻 3 调整大小为 30 。</span><br><span class="line">总浪费空间为 (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 200</code></li>
<li>  <code>1 &lt;= nums[i] &lt;= 10^6</code></li>
<li><code>0 &lt;= k &lt;= nums.length - 1</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>动态规划做法，设$f_{i,j}$为<code>nums[0...i]</code>中可以调整j次最最少浪费的空间和</p>
<p>初始化$f_{i,j} = \infin$</p>
<p>由于初始为位置可以任意选，所以在不允许调节的情况下，我们选择<code>nums[0...i]</code>中最大值作为初始空间。所以有$f_{i,0} = \sum \limits_{j=0}^{i} max(nums[0…i])-nums[j]$</p>
<p>此外初始化$f_{0,i}=0$对于一个数而言，无论调节多少次结果都是0.</p>
<p>状态转移$f_{i,j} = max(f_{k,j-1}+(i-k+1)*max(nums[k…i])-sum(nums[k…i]))$</p>
<p>最后答案是$f_{n-1, k}$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> f[<span class="number">202</span>][<span class="number">202</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSpaceWastedKResizing</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, INF, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k; i++) &#123;</span><br><span class="line">            f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mx=<span class="number">0</span>, sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, nums[i]);</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            f[i][<span class="number">0</span>] = (i+<span class="number">1</span>)*mx-sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=k; j++) &#123;</span><br><span class="line">                mx = sum = nums[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=i<span class="number">-1</span>; k&gt;=<span class="number">0</span>; k--) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[k][j<span class="number">-1</span>]+(i-k)*mx-sum);</span><br><span class="line">                    mx = <span class="built_in">max</span>(mx, nums[k]);</span><br><span class="line">                    sum += nums[k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// printf(&quot;[%d,%d]=%d\n&quot;,i,j,f[i][j]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n<span class="number">-1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2023/06/14/KMP/</url>
    <content><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p><code>pat[0...M]</code>为模式串,长度为$M$</p>
<p><code>txt[0...N]</code>为文本串,长度为$N$</p>
<p>我们需要从$txt$中寻找$pat$串的位置</p>
<p>kmp基本思想</p>
<p>利用最长公共前后缀确定匹配失败后的位置达到快速匹配的效果</p>
<p>算法分两部分:</p>
<ul>
<li>预处理$pat$串</li>
<li>$txt$串搜索$pat$串</li>
</ul>
<h2 id="Preprocessing-algorithm"><a href="#Preprocessing-algorithm" class="headerlink" title="Preprocessing algorithm"></a>Preprocessing algorithm</h2><p>预处理求出模式串$pat$的最长公共前后缀数组: <code>lps[]</code></p>
<blockquote>
<p>Name lps indicates longest proper frefix which is also suffix.</p>
<p>A proper prefix is prefix with whol string not allowed.</p>
<p>lps[i] = the longest proper prefix of pat[0..i] which is also a suffix of pat[0..i].</p>
<p>Examples of lps[] construction:</p>
<p>For the pattern “AAAA”,</p>
<p>lps[] is [0, 1, 2, 3]</p>
<p>For the pattern “ABCDE”,</p>
<p>lps[] is [0, 0, 0, 0, 0]</p>
<p>For the pattern “AABAACAABAA”,</p>
<p>lps[] is [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]</p>
<p>For the pattern “AAACAAAAAC”,</p>
<p>lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4]</p>
<p>For the pattern “AAABAAA”,</p>
<p>lps[] is [0, 1, 2, 0, 1, 2, 3]</p>
</blockquote>
<p>这里要注意的是:</p>
<p>前缀是包含第一个字符且不包含最后一个字符的子串.</p>
<p>后缀是包含最后字符且不包含第一个字符的子串.</p>
<p>图解<code>lps</code>的含义, 设<code>lps[i-1] = k</code>;</p>
<p>则表明在<code>pat[0...i-1]</code>存在<code>pat[0,k-1]=pat[i-k+1...i]</code>, 即<code>pat</code>开头的<code>k</code>个字符组成的字符串<code>a</code>与<code>pat</code>结尾的<code>k</code>个字符串相同<code>b</code>.</p>
<p><img src="https://cdnjson.com/images/2023/06/14/606_1.png" alt="606_1.png"></p>
<p>接下来说如何求得<code>lps</code></p>
<p>这里利用的是动态规划的思想, 逐个求出<code>lps[0]</code>到<code>lps[i]</code>.</p>
<p>显然当<code>i=0</code>时 <code>lps[0]=0</code></p>
<p>当<code>i&gt;0</code>时, 求<code>lps[i]</code>, 可利用已求出的<code>lps[0...i-1]</code></p>
<p>设<code>lps[i-1]=k1</code>, 则可知<code>pat</code>串在<code>i</code>位置前<code>k1</code>个字符与前<code>k1</code>个字符分别组成的字符串相等, 即<code>pat[0...k1-1]=pat[i-k1, k1-1]</code>, 所以要得出<code>lps[i-1]</code>只需要比较<code>pat[k1]</code>是否等于<code>pat[i]</code>即可</p>
<ul>
<li>相等, 则<code>lps[i]=k1+1</code></li>
<li>不等, 则令<code>k1=lps[k1-1]</code>, 继续以上过程</li>
</ul>
<p><img src="https://cdnjson.com/images/2023/06/14/607_1.png" alt="607_1.png"></p>
<p>例如当<code>lps[k1-1]=k2</code> 时：</p>
<p><img src="https://cdnjson.com/images/2023/06/14/608_1.png" alt="608_1.png"></p>
<p>由于黄色区域都是相等的, 所以<code>pat[0...k2]=pat[i-k2...i-1]</code>, 仅需比较<code>pat[k2]</code>与<code>pat[i]</code>是否相同, 若相同则<code>lps[i] = k2+1</code>;</p>
<p>我们在代码里写了两种求lps数组的方式，但本质上是一样的。</p>
<p>函数<code>computeLPSArray1</code> 实现了上述过程，注意到第i次外层循环<code>len</code>的变化由<code>lps[i-1]</code>变为<code>lps[i]-1</code> ,内层循环的次数不超过<code>lps[i-1]-lps[i]+1</code> ，总内循环次数$\sum \limits_{i=1}^{n-1}lps[i-1] + lps[i]+1 = n-lps[n]$，所以总时间复杂度$O(n)$</p>
<p>函数<code>computeLPSArra2</code> 则是整合了两个循环为一个，与第一种实现无本质区别。</p>
<h2 id="Searching-Algorithm"><a href="#Searching-Algorithm" class="headerlink" title="Searching Algorithm"></a>Searching Algorithm</h2><p>搜索算法就比较简单.</p>
<p>比较<code>pat[j]</code> 与 <code>txt</code>当前窗口中的字符.</p>
<ul>
<li>在<code>pat[j]</code> 与 <code>txt[i]</code>相等时同时递增i和j</li>
<li>当不相等时可知<code>pat[0...j-1]</code> 与 <code>txt[i-j...i-1]</code> 是已匹配字符串. 若此时<code>lps[j-1] = k</code> 则 可知 <code>pat[0...k] = pat[j-k...j-1] = txt[i-k...i-1]</code>, 也就是说不用再匹配<code>pat</code>的前<code>k</code>个字符了, 让<code>j</code>回到<code>k</code>即可, 代码上的实现就是<code>j=lps[j-1]</code>; 特例情况就是<code>j=0</code>时, 一开始就失配, 让<code>i++</code>即可.  <img src="https://cdnjson.com/images/2023/06/14/609_1.png" alt="609_1.png"></li>
<li>当<code>j==M</code>时, 匹配完成, 若要继续匹配, 可将j看为失配点, 令j = lps[j-1]</li>
</ul>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ program for implementation of KMP pattern searching</span></span><br><span class="line"><span class="comment">// algorithm</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computeLPSArray1</span><span class="params">(<span class="type">char</span> *pat, <span class="type">int</span> M, <span class="type">int</span> *lps)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computeLPSArray2</span><span class="params">(<span class="type">char</span> *pat, <span class="type">int</span> M, <span class="type">int</span> *lps)</span></span>;</span><br><span class="line"><span class="comment">// Prints occurrences of txt[] in pat[]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KMPSearch</span><span class="params">(<span class="type">char</span> *pat, <span class="type">char</span> *txt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M = <span class="built_in">strlen</span>(pat);</span><br><span class="line">    <span class="type">int</span> N = <span class="built_in">strlen</span>(txt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create lps[] that will hold the longest prefix suffix</span></span><br><span class="line">    <span class="comment">// values for pattern</span></span><br><span class="line">    <span class="type">int</span> lps[M];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Preprocess the pattern (calculate lps[] array)</span></span><br><span class="line">    <span class="built_in">computeLPSArray1</span>(pat, M, lps);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, lps[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">computeLPSArray2</span>(pat, M, lps);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, lps[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// index for txt[]</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// index for pat[]</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pat[j] == txt[i])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == M)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Found pattern at index %d &quot;</span>, i - j);</span><br><span class="line">            j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mismatch after j matches</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; N &amp;&amp; pat[j] != txt[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Do not match lps[0..lps[j-1]] characters,</span></span><br><span class="line">            <span class="comment">// they will match anyway</span></span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>)</span><br><span class="line">                j = lps[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fills lps[] for given patttern pat[0..M-1]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computeLPSArray1</span><span class="params">(<span class="type">char</span> *pat, <span class="type">int</span> M, <span class="type">int</span> *lps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// length of the previous longest prefix suffix</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// lps[0] is always 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// the loop calculates lps[i] for i = 1 to M-1</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; M)</span><br><span class="line">    &#123;</span><br><span class="line">        len = lps[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (len != <span class="number">0</span> &amp;&amp; pat[len] != pat[i])</span><br><span class="line">            len = lps[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> &amp;&amp; pat[len] != pat[i])</span><br><span class="line">            lps[i] = <span class="number">0</span>; <span class="comment">// just len == 0 and pat[len] != pat[i]</span></span><br><span class="line">        <span class="keyword">if</span> (pat[len] == pat[i])</span><br><span class="line">            lps[i] = len + <span class="number">1</span>; <span class="comment">// whatever value len is.</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Fills lps[] for given patttern pat[0..M-1]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computeLPSArray2</span><span class="params">(<span class="type">char</span> *pat, <span class="type">int</span> M, <span class="type">int</span> *lps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// length of the previous longest prefix suffix</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// lps[0] is always 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// the loop calculates lps[i] for i = 1 to M-1</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pat[i] == pat[len])</span><br><span class="line">        &#123;</span><br><span class="line">            len++;</span><br><span class="line">            lps[i] = len;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// (pat[i] != pat[len])</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// This is tricky. Consider the example.</span></span><br><span class="line">            <span class="comment">// AAACAAAA and i = 7. The idea is similar</span></span><br><span class="line">            <span class="comment">// to search step.</span></span><br><span class="line">            <span class="keyword">if</span> (len != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                len = lps[len - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Also, note that we do not increment</span></span><br><span class="line">                <span class="comment">// i here</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// if (len == 0)</span></span><br><span class="line">            &#123;</span><br><span class="line">                lps[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Driver program to test above function</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> txt[] = <span class="string">&quot;ABABDABACDABABCABAB&quot;</span>;</span><br><span class="line">    <span class="type">char</span> pat[] = <span class="string">&quot;ABABCABAB&quot;</span>;</span><br><span class="line">    <span class="built_in">KMPSearch</span>(pat, txt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>精简版1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getlps</span><span class="params">(string&amp; pat, <span class="type">int</span>* lps)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = pat.<span class="built_in">size</span>();</span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> len = lps[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (len != <span class="number">0</span> &amp;&amp; pat[len] != pat[i]) len = lps[len - <span class="number">1</span>];</span><br><span class="line">        lps[i] = pat[len] == pat[i] ? len + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KMPSearch</span><span class="params">(string&amp; pat, string&amp; txt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = pat.<span class="built_in">size</span>(), n = txt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> lps[m];</span><br><span class="line">    <span class="built_in">getlps</span>(pat, lps);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;txt.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j!=<span class="number">0</span> &amp;&amp; txt[i] != pat[j]) j = lps[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (txt[i] == pat[j]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Found pattern at index %d \n&quot;</span>, i+<span class="number">1</span>-j);</span><br><span class="line">            j = lps[j - <span class="number">1</span>];    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string Pat, Txt;</span><br><span class="line">    cin &gt;&gt; Txt &gt;&gt; Pat;</span><br><span class="line">    <span class="built_in">KMPSearch</span>(Pat, Txt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>精简版2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getlps</span><span class="params">(string&amp; pat, <span class="type">int</span> *lps)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = pat.<span class="built_in">size</span>();</span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pat[i] == pat[len]) lps[i++] = ++len; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (len != <span class="number">0</span>) len = lps[len - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> lps[i++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KMPSearch</span><span class="params">(string&amp; pat, string&amp; txt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = pat.<span class="built_in">size</span>(), n = txt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> lps[m];</span><br><span class="line">    <span class="built_in">getlps</span>(pat, lps);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pat[j] == txt[i]) &#123;</span><br><span class="line">            j++; i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Found pattern at index %d \n&quot;</span>, i - j);</span><br><span class="line">            j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n &amp;&amp; pat[j] != txt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) j = lps[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string Pat, Txt;</span><br><span class="line">    cin &gt;&gt; Txt &gt;&gt; Pat;</span><br><span class="line">    <span class="built_in">KMPSearch</span>(Pat, Txt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reference<br><a href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/">https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/</a></p>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>strings</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex Mathematical Symbols</title>
    <url>/2022/12/08/Latex-Mathematical-Symbols/</url>
    <content><![CDATA[<div class="pdf-container" data-target="https://www.cmor-faculty.rice.edu/~heinken/latex/symbols.pdf" data-height="500px"></div>]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>pdf</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>NEXT设置彩色标签</title>
    <url>/2022/12/07/NEXT%E8%AE%BE%E7%BD%AE%E5%BD%A9%E8%89%B2%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="标签页设置彩色标签"><a href="#标签页设置彩色标签" class="headerlink" title="标签页设置彩色标签"></a>标签页设置彩色标签</h1><p>添加代码如下</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">     <span class="keyword">var</span> alltags = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;tag-cloud-tags&#x27;</span>);</span><br><span class="line">     <span class="keyword">var</span> tags = alltags[<span class="number">0</span>].<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = tags.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">       <span class="keyword">var</span> golden_ratio = <span class="number">0.618033988749895</span>;</span><br><span class="line">       <span class="keyword">var</span> s = <span class="number">0.5</span>;</span><br><span class="line">       <span class="keyword">var</span> v = <span class="number">0.999</span>;</span><br><span class="line">       <span class="keyword">var</span> h = golden_ratio + <span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">0.8</span> - <span class="number">0.5</span>;</span><br><span class="line">       <span class="keyword">var</span> h_i = <span class="built_in">parseInt</span>(h * <span class="number">6</span>);</span><br><span class="line">       <span class="keyword">var</span> f = h * <span class="number">6</span> - h_i;</span><br><span class="line">       <span class="keyword">var</span> p = v * (<span class="number">1</span> - s);</span><br><span class="line">       <span class="keyword">var</span> q = v * (<span class="number">1</span> - f * s);</span><br><span class="line">       <span class="keyword">var</span> t = v * (<span class="number">1</span> - (<span class="number">1</span> - f) * s);</span><br><span class="line">       <span class="keyword">var</span> r, g, b;</span><br><span class="line">       <span class="keyword">switch</span> (h_i) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              r = v;</span><br><span class="line">              g = t;</span><br><span class="line">              b = p;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">              r = q;</span><br><span class="line">              g = v;</span><br><span class="line">              b = p;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">              r = p;</span><br><span class="line">              g = v;</span><br><span class="line">              b = t;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">3</span> :</span><br><span class="line">              r = p;</span><br><span class="line">              g = q;</span><br><span class="line">              b = v;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">              r = t;</span><br><span class="line">              g = p;</span><br><span class="line">              b = v;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">              r = v;</span><br><span class="line">              g = p;</span><br><span class="line">              b = q;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="attr">default</span>:</span><br><span class="line">              r = <span class="number">1</span>;</span><br><span class="line">              g = <span class="number">1</span>;</span><br><span class="line">              b = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       tags[i].<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;rgba(&quot;</span>+<span class="built_in">parseInt</span>(r*<span class="number">255</span>)+<span class="string">&quot;,&quot;</span>+<span class="built_in">parseInt</span>(g*<span class="number">255</span>)+<span class="string">&quot;,&quot;</span>+<span class="built_in">parseInt</span>(b*<span class="number">255</span>)+<span class="string">&quot;,&quot;</span>+<span class="number">0.7</span>+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-class">.tag-cloud-tags</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">text-align</span>: center;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">counter-reset</span>: tags;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-class">.tag-cloud-tags</span> <span class="selector-tag">a</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">display</span>: inline-block;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">border</span>: <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">10px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">margin</span>: <span class="number">8px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">34</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">0.8</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    </span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="comment">/* 文字前添加相应的符号，content后的Unicode可以自定义*/</span></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-class">.tag-cloud-tags</span> <span class="selector-tag">a</span><span class="selector-pseudo">:before</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">font-family</span>: <span class="string">&#x27;Font Awesome 5 Free&#x27;</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">content</span>: <span class="string">&quot;\f02b&quot;</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">font-weight</span>: <span class="number">900</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-class">.tag-cloud-tags</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">     <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">5px</span> <span class="number">15px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">4</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">     <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">     <span class="attribute">transition-duration</span>: <span class="number">0.15s</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>两种方法</p>
<ol>
<li><p>路径 <code>\node_modules\hexo-theme-next\layout</code>下新建<code>tag-color.njk</code>，并将以上代码粘贴，然后在<code>node_modules\hexo-theme-next\layout\page.njk</code>中以下位置添加<code>&#123;% include 'tag-color.njk' %&#125;</code></p>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;post-body&#123;% if page.direction and page.direction.toLowerCase() === &#x27;rtl&#x27; %&#125; rtl&#123;% endif %&#125;&quot;</span>&gt;</span><br><span class="line">  &#123;%- <span class="keyword">if</span> page.<span class="property">type</span> === <span class="string">&#x27;tags&#x27;</span> %&#125;</span><br><span class="line">    &#123;%- include <span class="string">&#x27;_partials/page/tags.njk&#x27;</span> -%&#125;</span><br><span class="line">  &#123;% elif page.<span class="property">type</span> === <span class="string">&#x27;categories&#x27;</span> %&#125;</span><br><span class="line">    &#123;%- include <span class="string">&#x27;_partials/page/categories.njk&#x27;</span> -%&#125;</span><br><span class="line">  &#123;% elif page.<span class="property">type</span> === <span class="string">&#x27;schedule&#x27;</span> %&#125;</span><br><span class="line">    &#123;%- include <span class="string">&#x27;_partials/page/schedule.njk&#x27;</span> -%&#125;</span><br><span class="line">  &#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">    &#123;&#123; page.<span class="property">content</span> &#125;&#125;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% include <span class="string">&#x27;tag-color.njk&#x27;</span> %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者不用新建文件再引入，直接将代码粘贴在<code>&lt;/div&gt;</code>后面</p>
</li>
</ol>
<h1 id="文章页面底部标签"><a href="#文章页面底部标签" class="headerlink" title="文章页面底部标签"></a>文章页面底部标签</h1><p>找到<code>node_modules\hexo-theme-next\layout\_macro\post.njk</code>，并在以下含<code>post-tags</code>类的<code>&lt;div&gt;</code>标签后添加<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>标签，另外注意标签的图标可以在<code>theme.tag_icon</code>字段设置为<code>true</code>替换<code>#</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;%- set tag_indicate = <span class="string">&#x27;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;&#x27;</span> <span class="keyword">if</span> theme.<span class="property">tag_icon</span> <span class="keyword">else</span> <span class="string">&#x27;#&#x27;</span> %&#125;</span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;post-tags&quot;</span>&gt;</span><br><span class="line">  &#123;%- <span class="keyword">for</span> tag <span class="keyword">in</span> post.<span class="property">tags</span>.<span class="title function_">toArray</span>() %&#125;</span><br><span class="line">    &lt;a href=<span class="string">&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot;</span> rel=<span class="string">&quot;tag&quot;</span>&gt;&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.<span class="property">name</span> &#125;&#125;&lt;/a&gt;</span><br><span class="line">  &#123;%- endfor %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> tagsall=<span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;post-tags&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">for</span> (<span class="keyword">var</span> i = tagsall.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> tags=tagsall[i].<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;a&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">for</span> (<span class="keyword">var</span> j = tags.<span class="property">length</span> - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">var</span> golden_ratio = <span class="number">0.618033988749895</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">var</span> s = <span class="number">0.5</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">var</span> v = <span class="number">0.999</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">var</span> h = golden_ratio + <span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">0.8</span> - <span class="number">0.5</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">var</span> h_i = <span class="built_in">parseInt</span>(h * <span class="number">6</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">var</span> f = h * <span class="number">6</span> - h_i;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">var</span> p = v * (<span class="number">1</span> - s);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">var</span> q = v * (<span class="number">1</span> - f * s);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">var</span> t = v * (<span class="number">1</span> - (<span class="number">1</span> - f) * s);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">var</span> r, g, b;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">switch</span> (h_i) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="keyword">case</span> <span class="number">0</span>:</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  r = v;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  g = t;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  b = p;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="keyword">case</span> <span class="number">1</span>:</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  r = q;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  g = v;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  b = p;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="keyword">case</span> <span class="number">2</span>:</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  r = p;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  g = v;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  b = t;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="keyword">case</span> <span class="number">3</span> :</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  r = p;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  g = q;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  b = v;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="keyword">case</span> <span class="number">4</span>:</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  r = t;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  g = p;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  b = v;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="keyword">case</span> <span class="number">5</span>:</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  r = v;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  g = p;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  b = q;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">              <span class="attr">default</span>:</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  r = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  g = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                  b = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          tags[j].<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;rgba(&quot;</span>+<span class="built_in">parseInt</span>(r*<span class="number">255</span>)+<span class="string">&quot;,&quot;</span>+<span class="built_in">parseInt</span>(g*<span class="number">255</span>)+<span class="string">&quot;,&quot;</span>+<span class="built_in">parseInt</span>(b*<span class="number">255</span>)+<span class="string">&quot;,&quot;</span>+<span class="number">0.7</span>+<span class="string">&quot;)&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.post-tags</span> <span class="selector-tag">a</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">display</span>: inline-block;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">font-size</span>: <span class="number">0.8em</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">10px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">85</span>, <span class="number">85</span>, <span class="number">85</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">border</span>: <span class="number">0px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.post-tags</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">5px</span> <span class="number">15px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">4</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">transition-duration</span>: <span class="number">0.15s</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title>NEXT设置评论区</title>
    <url>/2022/12/08/NEXT%E8%AE%BE%E7%BD%AE%E8%AF%84%E8%AE%BA%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="详细教程"><a href="#详细教程" class="headerlink" title="详细教程"></a>详细教程</h1><p><a href="https://utteranc.es/">https://utteranc.es/</a></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>原理就是将评论存在github 仓库的issue。</p>
<h1 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h1><p>部署步骤：</p>
<ol>
<li>安装 github 应用： <code>https://github.com/apps/utterances</code> ，并在安装时指定需要存储评论的仓库。</li>
<li>对于next主题已经集成了utterances，修改<strong>主题配置文件</strong> <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Utterances</span></span><br><span class="line"><span class="comment"># For more information: https://utteranc.es</span></span><br><span class="line"><span class="attr">utterances:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">grainmad/grainmad.github.io</span> <span class="comment"># Github repository owner and name</span></span><br><span class="line">  <span class="comment"># Available values: pathname | url | title | og:title</span></span><br><span class="line">  <span class="attr">issue_term:</span> <span class="string">pathname</span></span><br><span class="line">  <span class="comment"># Available values: github-light | github-dark | preferred-color-scheme | github-dark-orange | icy-dark | dark-blue | photon-dark | boxy-light</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-dark-orange</span></span><br></pre></td></tr></table></figure>
</li>
<li>修改<strong>站点配置文件</strong>的站点url <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://grainmad.github.io/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Beginner Contest 275</title>
    <url>/2023/06/08/abc275/</url>
    <content><![CDATA[<h1 id="AtCoder-Beginner-Contest-275"><a href="#AtCoder-Beginner-Contest-275" class="headerlink" title="AtCoder Beginner Contest 275"></a>AtCoder Beginner Contest 275</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>求数组最大值的下标</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>求<code>A*B*C-D*E*F</code>, 模998224353<br>每个数的大小在1e18内。<br>直接模注意溢出</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>给出<code>9*9</code>的方格，问正方形的个数。<br>枚举组成边的两个点，剩余的两个可通过两个点求得。我们只求一个方向的点就不会重复计数。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>已知$f(0) = 1, f(n) = f(\lfloor \frac{n}{2} \rfloor)+f(\lfloor \frac{n}{3} \rfloor)$<br>求$f(n)$<br>直接记忆化搜索</p>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>一个长度为n+1的道路，你在0号位置，现在开始转轮盘，你能等概率的选择向前c步，<code>0&lt;c&lt;=m</code>, 如果走的位置超过了n，那么剩余的步数会往回走。<br>，问最多不超过转k次轮盘到达n的概率。概率模M = 998224353<br>先求m的逆元invm = pow(m, M-2).<br>概率dp.</p>
]]></content>
      <categories>
        <category>atcode</category>
      </categories>
      <tags>
        <tag>contest</tag>
        <tag>atcode</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Beginner Contest 293</title>
    <url>/2023/06/08/abc293/</url>
    <content><![CDATA[<h1 id="AtCoder-Beginner-Contest-293"><a href="#AtCoder-Beginner-Contest-293" class="headerlink" title="AtCoder Beginner Contest 293"></a>AtCoder Beginner Contest 293</h1><p><a href="https://atcoder.jp/contests/abc293/tasks">Complete problemset</a></p>
<h2 id="A-Swap-Odd-and-Even"><a href="#A-Swap-Odd-and-Even" class="headerlink" title="A - Swap Odd and Even"></a>A - Swap Odd and Even</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个偶数长度的数组，交换$a_{2i-1}$和$a_{2i}$</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接实现</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Call-the-ID-Number"><a href="#B-Call-the-ID-Number" class="headerlink" title="B - Call the ID Number"></a>B - Call the ID Number</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个数组a，若i未标记则标记$a_{i}$，问最后有多少个未标记的数</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>直接实现。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span> (b[i] == <span class="number">0</span>)</span><br><span class="line">            b[a[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : ans)</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Make-Takahashi-Happy"><a href="#C-Make-Takahashi-Happy" class="headerlink" title="C - Make Takahashi Happy"></a>C - Make Takahashi Happy</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出一个10*10的矩阵，你需要从左上角走到右下角，每次只能向下或向右走。且路径中不存在重复的值。问有多少条路径满足。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>递归枚举也只有$2^{20}$数量级。可以用集合记录路径中出现的值，作为剪枝。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 55</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; n || y &gt; m || st.<span class="built_in">count</span>(g[x][y]))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == n &amp;&amp; y == m) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    st.<span class="built_in">insert</span>(g[x][y]);</span><br><span class="line">    <span class="built_in">dfs</span>(x + <span class="number">1</span>, y);</span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>);</span><br><span class="line">    st.<span class="built_in">erase</span>(g[x][y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-Tying-Rope"><a href="#D-Tying-Rope" class="headerlink" title="D - Tying Rope"></a>D - Tying Rope</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出n个绳子，两端分别为红色和蓝色。</p>
<p>然后给出m次连接。将某根绳子A的某种颜色B的一段连接另一根绳子C的某种颜色的一段D。</p>
<p>问最后形成了多少个环，以及多少个非环。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>并查集</p>
<p>将每根绳子红色端和蓝色端连接到同一集合。</p>
<p>然后对于m次连接，当遇到已经在同一集合的连接则说明形成了环。统计环的个数。</p>
<p>然后遍历并查集查看有多少个根节点，即有多少个集合。集合数-环的个数=非环的个数。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uf_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">-1</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">uf_find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> st[x] &lt; <span class="number">0</span> ? x : st[x] = <span class="built_in">uf_find</span>(st[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uf_union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">uf_find</span>(x), fy = <span class="built_in">uf_find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">        st[fx] += st[fy];</span><br><span class="line">        st[fy] = fx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; s;</span><br><span class="line">    <span class="keyword">return</span> x + (s == <span class="string">&quot;B&quot;</span> ? B : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">uf_init</span>();</span><br><span class="line">    <span class="type">int</span> n, m, cy = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">uf_union</span>(i, i + B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">getval</span>();</span><br><span class="line">        <span class="type">int</span> b = <span class="built_in">getval</span>();</span><br><span class="line">        <span class="type">int</span> fa = <span class="built_in">uf_find</span>(a), fb = <span class="built_in">uf_find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (fa == fb)</span><br><span class="line">            cy++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">uf_union</span>(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i] &lt; <span class="number">0</span>)</span><br><span class="line">            g++;</span><br><span class="line">        <span class="keyword">if</span> (st[i + B] &lt; <span class="number">0</span>)</span><br><span class="line">            g++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cy &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; g - cy &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-Geometric-Progression"><a href="#E-Geometric-Progression" class="headerlink" title="E - Geometric Progression"></a>E - Geometric Progression</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给出A，X，M。求$\sum\limits_{i=0}^{X-1}A^i%M$</p>
<p>1 ≤ A, X ≤1e9</p>
<p>1≤M≤1e18</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>矩阵快速幂</p>
<p>$a_n = A^0+A^1+\cdots+A^{n-1}$</p>
<p>$a_1 = 1$，$a_n = Aa_{n-1}+1$</p>
<p>$\left [ \begin{array}{c}<br>a_n\<br>1<br>\end{array} \right ] =<br>\left [ \begin{array}{c}<br> A &amp; 1\<br> 0 &amp; 1<br>\end{array} \right ] ^{n-1}<br>\left [ \begin{array}{c}<br>a_1\<br>1<br>\end{array} \right ]<br>$</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map&lt;ll, ll&gt; mp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ll fpow(ll x, ll p, ll m) &#123;</span></span><br><span class="line"><span class="comment">//     ll rt = 1;</span></span><br><span class="line"><span class="comment">//     while (p) &#123;</span></span><br><span class="line"><span class="comment">//         if (p &amp; 1)</span></span><br><span class="line"><span class="comment">//             rt = rt * x % m;</span></span><br><span class="line"><span class="comment">//         x = x * x % m;</span></span><br><span class="line"><span class="comment">//         p &gt;&gt;= 1;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return rt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ll f(ll a, ll x, ll m) &#123;</span></span><br><span class="line"><span class="comment">//     if (x &lt; 0)</span></span><br><span class="line"><span class="comment">//         return 0;</span></span><br><span class="line"><span class="comment">//     if (x == 0)</span></span><br><span class="line"><span class="comment">//         return 1;</span></span><br><span class="line"><span class="comment">//     if (mp.count(x))</span></span><br><span class="line"><span class="comment">//         return mp[x];</span></span><br><span class="line"><span class="comment">//     return mp[x] = (f(a, x / 2, m) +</span></span><br><span class="line"><span class="comment">//                     f(a, x - x / 2 - 1, m) * fpow(a, x / 2 + 1, m) % m) %</span></span><br><span class="line"><span class="comment">//                    m;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void sol() &#123;</span></span><br><span class="line"><span class="comment">//     ll a, x, m;</span></span><br><span class="line"><span class="comment">//     cin &gt;&gt; a &gt;&gt; x &gt;&gt; m;</span></span><br><span class="line"><span class="comment">//     cout &lt;&lt; f(a, x - 1, m) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     // ll mod = (a - 1) * m; mod &gt; 1e9 fpow会溢出</span></span><br><span class="line"><span class="comment">//     // cout &lt;&lt; (fpow(a, x, mod) - 1) / (a - 1) % m &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    ll mat[N][N];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// a: n*n b: n*n</span></span><br><span class="line"><span class="function">Matrix <span class="title">mul_matrix</span><span class="params">(Matrix a, Matrix b, <span class="type">int</span> n, ll m)</span> </span>&#123;</span><br><span class="line">    Matrix res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            res.mat[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                res.mat[i][j] += a.mat[i][k] * b.mat[k][j] % m;</span><br><span class="line">                res.mat[i][j] %= m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a^p</span></span><br><span class="line"><span class="function">Matrix <span class="title">pow_matrix</span><span class="params">(Matrix a, ll p, <span class="type">int</span> n, ll m)</span> </span>&#123;</span><br><span class="line">    Matrix res;</span><br><span class="line">    <span class="comment">// 单位矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            res.mat[i][j] = (i == j ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">            res = <span class="built_in">mul_matrix</span>(a, res, n, m);</span><br><span class="line">        a = <span class="built_in">mul_matrix</span>(a, a, n, m);</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a_x A 1 ^&#123;x-1&#125; a_1</span></span><br><span class="line"><span class="comment">        1   0 1        1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ll a, x, m;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; x &gt;&gt; m;</span><br><span class="line">    Matrix m1, m2, m3;</span><br><span class="line"></span><br><span class="line">    m1.mat[<span class="number">0</span>][<span class="number">0</span>] = a;</span><br><span class="line">    m1.mat[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    m1.mat[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    m1.mat[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    m2.mat[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    m2.mat[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    m1 = <span class="built_in">pow_matrix</span>(m1, x - <span class="number">1</span>, <span class="number">2</span>, m);</span><br><span class="line"></span><br><span class="line">    m3 = <span class="built_in">mul_matrix</span>(m1, m2, <span class="number">2</span>, m);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; m3.mat[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F-Zero-or-One"><a href="#F-Zero-or-One" class="headerlink" title="F - Zero or One"></a>F - Zero or One</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>一个数N（N≤1e18），在b进制下只有0和1组成，求这样的b的个数。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>sample</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sample</span><br></pre></td></tr></table></figure>

<h2 id="G-Triple-Index"><a href="#G-Triple-Index" class="headerlink" title="G - Triple Index"></a>G - Triple Index</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>给出一个数组a。</p>
<p>给出q次查询，每次查询一个区间$[l,r]$内三元组$(i,j,k)$的个数。</p>
<p>条件$l≤i&lt;j&lt;k≤r,a_i=a_j=a_k$</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>莫队</p>
<p>只有区间查询可以离线。</p>
<p>可以用$O(1)$时间复杂度计算相邻区间的三元组变化</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000006</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bsz;</span><br><span class="line">ll cnt[N], v[N], ans[N];</span><br><span class="line">ll cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Node&amp; o) &#123;</span><br><span class="line">        <span class="keyword">return</span> l / bsz == o.l / bsz ? r &lt; o.r : l / bsz &lt; o.l / bsz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll p = cnt[v[x]];</span><br><span class="line">    cnt[v[x]]++;</span><br><span class="line">    <span class="keyword">if</span> (cnt[v[x]] &gt;= <span class="number">3</span>)</span><br><span class="line">        cur += p * (p - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    cnt[v[x]]--;</span><br><span class="line">    ll p = cnt[v[x]];</span><br><span class="line">    <span class="keyword">if</span> (cnt[v[x]] &gt;= <span class="number">2</span>)</span><br><span class="line">        cur -= p * (p - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].l &gt;&gt; a[i].r;</span><br><span class="line">        a[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    bsz = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">sort</span>(a, a + q);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[i].l &lt; l)</span><br><span class="line">            <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (a[i].r &gt; r)</span><br><span class="line">            <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span> (a[i].l &gt; l)</span><br><span class="line">            <span class="built_in">sub</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (a[i].r &lt; r)</span><br><span class="line">            <span class="built_in">sub</span>(r--);</span><br><span class="line">        ans[a[i].id] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>atcode</category>
      </categories>
      <tags>
        <tag>contest</tag>
        <tag>atcode</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Beginner Contest 296</title>
    <url>/2023/06/08/abc296/</url>
    <content><![CDATA[<h1 id="AtCoder-Beginner-Contest-296"><a href="#AtCoder-Beginner-Contest-296" class="headerlink" title="AtCoder Beginner Contest 296"></a>AtCoder Beginner Contest 296</h1><p><a href="https://atcoder.jp/contests/abc296/tasks">Complete problemset</a></p>
<h2 id="A-Alternately"><a href="#A-Alternately" class="headerlink" title="A - Alternately"></a>A - Alternately</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>判断字符串是否<code>&#39;M&#39;&#39;F&#39;</code>交替</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接判断</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Chessboard"><a href="#B-Chessboard" class="headerlink" title="B - Chessboard"></a>B - Chessboard</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个8*8的棋盘，其中只有一个字符为<code>*</code>其余字符为<code>.</code> 。求<code>*</code>的位置。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>双重循环定位输出就行</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">char</span>(j + <span class="string">&#x27;a&#x27;</span>) &lt;&lt; <span class="number">8</span> - i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Gap-Existence"><a href="#C-Gap-Existence" class="headerlink" title="C - Gap Existence"></a>C - Gap Existence</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出一个序列，问序列中是否存在两个数的差是x</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>哈希表一边统计每个值a，一边查询a-x和a+x是否在哈希表中存在即可。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    set&lt;ll&gt; st;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ll a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        st.<span class="built_in">insert</span>(a);</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">count</span>(a - x) || st.<span class="built_in">count</span>(a + x))</span><br><span class="line">            ok = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ok ? <span class="string">&quot;Yes\n&quot;</span> : <span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-M-lt-ab"><a href="#D-M-lt-ab" class="headerlink" title="D - M&lt;=ab"></a>D - M&lt;=ab</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出n和m，范围在1到n内的a和b，使得a<em>b≥m，且最小化a</em>b-m。输出a*b</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>暴力枚举a，那么最小的使得a*b≥m的b为$\lceil \frac{m}{a} \rceil$。</p>
<p>所以就是找 $\min \limits_{1≤a≤n, 1≤\lceil \frac{m}{a} \rceil≤n, a<em>\lceil \frac{m}{a} \rceil≥m} a</em>\lceil \frac{m}{a} \rceil$</p>
<p>我们可以通过<a href="https://oi-wiki.org/math/number-theory/sqrt-decomposition/">数论分块</a>，$O(\sqrt n)$时间复杂度内找到答案。</p>
<p>对于$\min \limits_{1≤a≤n} a<em>\lfloor \frac{m+a-1}{a} \rfloor$，有多个a会使$\lfloor \frac{m+a-1}{a} \rfloor$相等，把这些相等的下取整值进行分块，我们只需找到每一块最小的下标a，在满足条件$1≤\lceil \frac{m}{a} \rceil≤n, a</em>\lceil \frac{m}{a} \rceil≥m$时，更新最小值。</p>
<p>已有结论：下一块的最小下标是$\lfloor \frac{m+a-1}{\lfloor \frac{m+a-1}{a} \rfloor} \rfloor+1$，且分块的数目是$O(\sqrt n)$的，所以时间复杂度$O(\sqrt n)$</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">min i * ceil(m/i), i in [1, min(n, m)] ceil(m/i) in [1, m]</span></span><br><span class="line"><span class="comment">min i * floor((m+i-1)/i)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">1e15</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll ans = INF;</span><br><span class="line">    ll l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// while (l &lt;= m) &#123;</span></span><br><span class="line">    <span class="comment">//     r = m / (m / l);</span></span><br><span class="line">    <span class="comment">//     if (l &lt;= n &amp;&amp; (m + l - 1) / l &lt;= n)</span></span><br><span class="line">    <span class="comment">//         ans = min(ans, (m + l - 1) / l * l);</span></span><br><span class="line">    <span class="comment">//     l = r + 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= m) &#123;</span><br><span class="line">        r = (m + l - <span class="number">1</span>) / ((m + l - <span class="number">1</span>) / l);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= n &amp;&amp; (m + l - <span class="number">1</span>) / l &lt;= n)</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, (m + l - <span class="number">1</span>) / l * l);</span><br><span class="line">        l = r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == INF)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-Transition-Game"><a href="#E-Transition-Game" class="headerlink" title="E - Transition Game"></a>E - Transition Game</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给出一个长度为n数组，且数组中每个数的值在1到n。</p>
<p>然后现在两个人a和b玩游戏。</p>
<p>首先a写下一个数x，x在1到n间。</p>
<p>然后b会执行k步，k也在1到n间，每一步就是让x变为a[x]。如果最后x变为了i，那么b就获胜。</p>
<p>请问在i等于1到n，这n种情况时，b能获胜的次数。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p><del>比赛时题目都没看懂</del></p>
<p>这个数组会形成一个图，图中最多也就一个环，如果i在环上则b必胜，否则b必败。</p>
<p>因为当i在环上时，总共有n个点，所以b可以找到一个执行的步数k使得x移动到i。</p>
<p>当i不在换上时，a只需要写下一个在环上的数，那么b永远也不能移动到i。</p>
<p>所以我们只需要拓扑排序，找到环的大小即可。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], in[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        in[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (--in[a[u]] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(a[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">count</span>(in + <span class="number">1</span>, in + n + <span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F-Simultaneous-Swap"><a href="#F-Simultaneous-Swap" class="headerlink" title="F - Simultaneous Swap"></a>F - Simultaneous Swap</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给出两个数组a和b，长度都为n，且数组中数值都在1到n间</p>
<p>现在每次操作可以选择三个不同坐标i,j,k。</p>
<p>然后交换$a_i$和$a_j$, $b_i$和$b_j$</p>
<p>问能否让a和b相等</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>首先a和b中每个数字出现的次数都应该相等。否则无论怎么操作都不能让a和b相等。</p>
<p>然后就是寻找规律。</p>
<p>对于有相同的数出现，我们发现可以通过一系列操作后只交换b中的一对数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>对于以上例子我们选择$a_0 = 1$与 $a_2 = 3$交换，$b_0 = 3$ 与 $b_3 = 1$交换。然后再次选择$a_0 = 1$与 $a_2 = 3$交换，这样a就没有动过了，然后选择$b_1= 2$ 与 $b_2 = 2$交换即可。也就是说经过这样的<strong>元操作</strong>可以使得a和b减少一个不匹配的位置。我们多次只需这样的元操作最后一定能让a和b相等。</p>
<p>对于没有相同的数出现。我们可以找到一种元操作使得a和b减少两处不匹配位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">4</span> <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>对于以上例子，我们可以让前两对匹配。让$a_0$和$a_1$交换，$b_0$和$b_3$交换。让$a_0$和$a_1$交换，$b_2$和$b_3$交换。</p>
<p>交换$a_i$与$a_j$，需要移动的步数是2(j-i)-1是奇数，每与相邻的数交换逆序数奇偶性一定会变化，现在移动奇数步交换了奇数次所以逆序数奇偶性发生了变化，交换两次那么逆序数奇偶性不变，所以我们只需判断a和b的逆序数奇偶性一致即可。</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="built_in">BIT</span>(<span class="type">int</span> n) : <span class="built_in">a</span>(n, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            rt += a[x];</span><br><span class="line">            x = x &amp; (x - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; a.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            a[x]++;</span><br><span class="line">            x += x &amp; -x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (a != b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] == a[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; i : a)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; i : b)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">check</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        BIT <span class="built_in">fw1</span>(n + <span class="number">1</span>), <span class="built_in">fw2</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">            c1 += fw1.<span class="built_in">ask</span>(i);</span><br><span class="line">            fw1.<span class="built_in">add</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : b) &#123;</span><br><span class="line">            c2 += fw2.<span class="built_in">ask</span>(i);</span><br><span class="line">            fw2.<span class="built_in">add</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((c1 - c2) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="G-Polygon-and-Points"><a href="#G-Polygon-and-Points" class="headerlink" title="G - Polygon and Points"></a>G - Polygon and Points</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>给出一个凸多边形，然后q次询问一个点是在多边形里，还是在多边形之外，或是在多边形的边上。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>扫描线。</p>
<p>将所有点（包含组成多边形和询问的点）都按照x升序，x相等的y升序，多个点相等的让多边形点优先于询问的点。另外我们需要能够在排序后区分这两种点。</p>
<p>然后就是用一根平行于y轴的扫描线从左到右扫描，当扫到多边形时，会形成两个交点（刚开始扫到的是一个交点，认为是两个相同的交点），统计上凸包最近扫到的交点$p_u$和下图包最近扫到的交点$p_d$。$p_i$是凸多边形的第i个点。</p>
<p>我们怎么样判断扫到的一个点是属于上凸包还是下凸包？可以利用给出的多边形的点是逆时针顺序给出的，我们可以给多边形每个点逆时针编号0到n-1。这个时候可以利用模运算确定下一个或上一个点的编号。</p>
<p>然后就是对于扫到的点属于询问的点q，那么我们可以判断q与向量$\vec {p_{u-1}p_{u}}$的位置关系，在左侧则是在多边形内，在右侧则在多边形外，否则判断是否在向量上（这是对于向量平行于扫描线的情况）。同理判断q与向量$\vec {p_{d}p_{d+1}}$的位置关系。</p>
<p>最后综合判断该点与凸多边形的位置关系。</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for (int i = (l); i &lt; (r); i++)</span></span><br><span class="line"><span class="keyword">using</span> point = array&lt;ll, <span class="number">3</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cross</span><span class="params">(point p, point q, point o)</span> </span>&#123;  <span class="comment">// op 叉乘 oq</span></span><br><span class="line">    ll x1 = p[<span class="number">0</span>] - o[<span class="number">0</span>];</span><br><span class="line">    ll y1 = p[<span class="number">1</span>] - o[<span class="number">1</span>];</span><br><span class="line">    ll x2 = q[<span class="number">0</span>] - o[<span class="number">0</span>];</span><br><span class="line">    ll y2 = q[<span class="number">1</span>] - o[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> x1 * y2 - y1 * x2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mult</span><span class="params">(point p, point q, point o)</span> </span>&#123;  <span class="comment">// op 点乘 oq</span></span><br><span class="line">    ll x1 = p[<span class="number">0</span>] - o[<span class="number">0</span>];</span><br><span class="line">    ll y1 = p[<span class="number">1</span>] - o[<span class="number">1</span>];</span><br><span class="line">    ll x2 = q[<span class="number">0</span>] - o[<span class="number">0</span>];</span><br><span class="line">    ll y2 = q[<span class="number">1</span>] - o[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> x1 * x2 + y1 * y2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pq 与 r 的关系， r在pq左侧返回2，r在pq右侧返回0，r在pq上返回1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(point p, point q, point r)</span> </span>&#123;</span><br><span class="line">    ll c = <span class="built_in">cross</span>(q, r, p);  <span class="comment">// 向量pq 与 向量pr的叉乘为正，则r在pq左侧</span></span><br><span class="line">    <span class="keyword">if</span> (c)</span><br><span class="line">        <span class="keyword">return</span> c &gt; <span class="number">0</span> ? <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line">    ll i = <span class="built_in">mult</span>(q, r, p);</span><br><span class="line">    ll d = <span class="built_in">mult</span>(q, q, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= i &amp;&amp;</span><br><span class="line">           i &lt;=</span><br><span class="line">               d;  <span class="comment">// 对于pq，pr都平行于扫描线，我们需要判断r在pq上的投影是否超出|pq|</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;point&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">        ll x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        p[i] = &#123;x, y, ~i&#125;;</span><br><span class="line">        <span class="comment">// 取反，便于判断该点的类型。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;point&gt; query = p;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, q) &#123;</span><br><span class="line">        ll x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;x, y, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们需要将所有点进行排序，如果检查的点和多边形的点是同一个点，由于负数，多边形的点优先排在前面</span></span><br><span class="line">    <span class="built_in">sort</span>(query.<span class="built_in">begin</span>(), query.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(q)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> u = <span class="number">-1</span>, d = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pp : query) &#123;</span><br><span class="line">        <span class="type">int</span> i = pp[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;  <span class="comment">// 多边形的点</span></span><br><span class="line">            i = ~i;</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="number">-1</span>) &#123;  <span class="comment">// 从左至右第一个扫到的点</span></span><br><span class="line">                u = i;</span><br><span class="line">                d = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 多边形的点编号为0到n-1，通过模运算可以形成循环</span></span><br><span class="line">                <span class="comment">// 在上凸包上扫到的下一个点应该是u-1，下凸包扫到的下一个点是u+1</span></span><br><span class="line">                <span class="keyword">if</span> ((u - <span class="number">1</span> + n) % n == i)</span><br><span class="line">                    u = i;</span><br><span class="line">                <span class="keyword">if</span> ((d + <span class="number">1</span>) % n == i)</span><br><span class="line">                    d = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 需检查的点</span></span><br><span class="line">            <span class="keyword">if</span> (u == <span class="number">-1</span>) &#123;  <span class="comment">// 在没有扫到多边形的点，所以在该点外面</span></span><br><span class="line">                ans[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 我们需要让pp点在多边形内部时，相对的向量都是在左侧。所以注意向量的两个点的顺序。</span></span><br><span class="line">                <span class="type">int</span> r1 = <span class="built_in">check</span>(p[(u - <span class="number">1</span> + n) % n], p[u], pp);</span><br><span class="line">                <span class="type">int</span> r2 = <span class="built_in">check</span>(p[d], p[(d + <span class="number">1</span>) % n], pp);</span><br><span class="line">                <span class="keyword">if</span> (r1 == <span class="number">1</span> || r2 == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans[i] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r1 == <span class="number">2</span> &amp;&amp; r2 == <span class="number">2</span>) &#123;</span><br><span class="line">                    ans[i] = <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">S</span><span class="params">(&#123;<span class="string">&quot;OUT&quot;</span>, <span class="string">&quot;ON&quot;</span>, <span class="string">&quot;IN&quot;</span>&#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans)</span><br><span class="line">        cout &lt;&lt; S[x] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>atcode</category>
      </categories>
      <tags>
        <tag>contest</tag>
        <tag>atcode</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Beginner Contest 302</title>
    <url>/2023/06/08/abc302/</url>
    <content><![CDATA[<h1 id="AtCoder-Beginner-Contest-302"><a href="#AtCoder-Beginner-Contest-302" class="headerlink" title="AtCoder Beginner Contest 302"></a>AtCoder Beginner Contest 302</h1><p><a href="https://atcoder.jp/contests/abc302/tasks">Complete problemset</a></p>
<h2 id="E-Isolation"><a href="#E-Isolation" class="headerlink" title="E - Isolation"></a>E - Isolation</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>现在有一个图，图中由n个节点，初始时没有任何边。</p>
<p>现在有q次操作，每次操作可以：</p>
<ul>
<li>连接两个点，保证这两个点之间没有边</li>
<li>删除一个点所连接的所有边。</li>
</ul>
<p>每次操作后都需要输出当前，没有任何边连接的点的个数。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于每次操作只会增加一条边，而删除操作顶多是把之前所有增加的边都删除。而操作次数是有限的，所以即便每次删除操作都是暴力删除所用的时间也是$O(n)$。</p>
<p>维护n个集合，集合i代表i节点所连接节点集合。</p>
<p>然后维护一个当前孤立点的变量iso，初始为n。</p>
<p>对于连接x和y，让集合x添加y，让集合y添加x。两个集合在如果在添加前是空的，那么就存在孤立点变为非孤立点。</p>
<p>对于删除x所连接的所有点，直接暴力遍历x集合，对于集合中每个点y将它们对应的集合都删除x（前提集合非空），并将x对应集合清空。在此过程中，集合若在删除前是非空的，删除后为空，非孤立点变为孤立点</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    vector&lt;set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">st</span>(n);</span><br><span class="line">    <span class="type">int</span> iso = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> o, x, y;</span><br><span class="line">        cin &gt;&gt; o;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">1</span>) &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            x--, y--;</span><br><span class="line">            st[x].<span class="built_in">insert</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (st[x].<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">                iso--;</span><br><span class="line">            st[y].<span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (st[y].<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">                iso--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            x--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u : st[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (st[u].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    st[u].<span class="built_in">erase</span>(x);</span><br><span class="line">                    <span class="keyword">if</span> (st[u].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                        iso++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st[x].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                st[x].<span class="built_in">clear</span>();</span><br><span class="line">                iso++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; iso &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; fixed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Execution time: &quot;</span></span><br><span class="line">         &lt;&lt; (end_time - start_time) * (<span class="type">int</span>)<span class="number">1e3</span> / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F-Merge-Set"><a href="#F-Merge-Set" class="headerlink" title="F - Merge Set"></a>F - Merge Set</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有n个集合。每个集合中的数的范围在1到m。现在每次可以选取两个集合合并，前提是这两个集合有公共元素，然后总集合数减少1个。问最少需要多少次合并才能合并出包含1和m的集合。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>将其转化为图论问题。</p>
<p>对于每个集合中的点之间都建立一条长度为1的边。那么从1到m的最短路-1就是答案</p>
<p>但是一种极端情况就是只有一个集合，且这个集合内元素太多，那么建图的时间复杂度达到$O(m^2)$，会导致超时。</p>
<p>我们设置虚拟节点，对于每个集合都设置一个虚拟节点，集合中的所有点都建立一条权值为1的有向边指向其虚拟节点。同时对应虚拟节点也建立一条权值为0的有向边指向对应集合内的所有点。这样同一集合内的所有点之间的距离都为1，且所有集合建图的复杂度是$O(\sum A_i)$，$A_i$为第i个集合的大小。</p>
<p>然后我们可以用dijkstra或者01bfs来求最短路。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        <span class="keyword">while</span> (c--) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            g[x].<span class="built_in">emplace_back</span>(m + i, <span class="number">1</span>);</span><br><span class="line">            g[m + i].<span class="built_in">emplace_back</span>(x, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n + m + <span class="number">1</span>, INF)</span></span>;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [v, e] : g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + e) &#123;</span><br><span class="line">                dis[v] = dis[u] + e;</span><br><span class="line">                e ? q.<span class="built_in">push_back</span>(v) : q.<span class="built_in">push_front</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[m] == INF)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; dis[m] - <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; fixed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Execution time: &quot;</span></span><br><span class="line">         &lt;&lt; (end_time - start_time) * (<span class="type">int</span>)<span class="number">1e3</span> / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="G-Sort-from-1-to-4"><a href="#G-Sort-from-1-to-4" class="headerlink" title="G - Sort from 1 to 4"></a>G - Sort from 1 to 4</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出一个只包含1到4的数组，然后你每次操作可以交换任意两个元素，问最少交换多少次可以使得数组非降序。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>设原数组为a，升序排序的数组为b。</p>
<p>现在探索规律。</p>
<p>当$a_i = b_i$时，显然这样的位置不需要交换。</p>
<p>接下来存在两、三以及四个数交换的循环。</p>
<p>对于$a_i=x,b_i=y$以及$a_j=y,b_j=x$，这样的只需要交换一次。称为两个数的循环。</p>
<p>对于$a_i=x,b_i=y; a_j=y,b_j=z; a_k=z,b_k=x$，这样的只需要交换两次。称为三个数的循环。</p>
<p>我们优先匹配较小的循环，例如如果有四个数它们既是两个数的循环又是四个数的循环，显然选则两次两个数的循环就可以让这四个数有序。选择四个数的循环需要三次。</p>
<p>那么实现也就简单了，枚举1到4所有的非空排列情况，注意要优先枚举短排列。然后将对应的排列的循环删除，统计贡献。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; i : a) &#123;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> b = a;</span><br><span class="line">    <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        g[a[i]][b[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        g[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// for (int i : c)</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="type">int</span> csz = c.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> mn = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; csz; i++) &#123;</span><br><span class="line">                mn = <span class="built_in">min</span>(mn, g[c[i]][c[(i + <span class="number">1</span>) % csz]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (csz)</span><br><span class="line">                ans += mn * (csz - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; csz; i++) &#123;</span><br><span class="line">                g[c[i]][c[(i + <span class="number">1</span>) % csz]] -= mn;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(x - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), i) == c.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                c.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="built_in">dfs</span>(x - <span class="number">1</span>);</span><br><span class="line">                c.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; fixed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Execution time: &quot;</span></span><br><span class="line">         &lt;&lt; (end_time - start_time) * (<span class="type">int</span>)<span class="number">1e3</span> / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>atcode</category>
      </categories>
      <tags>
        <tag>contest</tag>
        <tag>atcode</tag>
      </tags>
  </entry>
  <entry>
    <title>NS Solutions Corporation Programming Contest 2023（AtCoder Beginner Contest 303）</title>
    <url>/2023/06/10/abc303/</url>
    <content><![CDATA[<h1 id="NS-Solutions-Corporation-Programming-Contest-2023（AtCoder-Beginner-Contest-303）"><a href="#NS-Solutions-Corporation-Programming-Contest-2023（AtCoder-Beginner-Contest-303）" class="headerlink" title="NS Solutions Corporation Programming Contest 2023（AtCoder Beginner Contest 303）"></a>NS Solutions Corporation Programming Contest 2023（AtCoder Beginner Contest 303）</h1><p><a href="https://atcoder.jp/contests/abc303/tasks">Complete problemset</a></p>
<h2 id="A-Similar-String"><a href="#A-Similar-String" class="headerlink" title="A - Similar String"></a><a href="https://atcoder.jp/contests/abc303/tasks/abc303_a">A - Similar String</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>验证两个字符串是否相等，其中字符<code>1</code>和<code>l</code>，以及<code>0</code>和<code>o</code>视为相等。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>特殊字符特殊判断。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[i] || a[i] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; b[i] == <span class="string">&#x27;l&#x27;</span> ||</span><br><span class="line">            a[i] == <span class="string">&#x27;l&#x27;</span> &amp;&amp; b[i] == <span class="string">&#x27;1&#x27;</span> || a[i] == <span class="string">&#x27;o&#x27;</span> &amp;&amp; b[i] == <span class="string">&#x27;0&#x27;</span> ||</span><br><span class="line">            a[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; b[i] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (cnt == n ? <span class="string">&quot;Yes\n&quot;</span> : <span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Discord"><a href="#B-Discord" class="headerlink" title="B - Discord"></a><a href="https://atcoder.jp/contests/abc303/tasks/abc303_b">B - Discord</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有n个人共计拍了m张照片，每张照片的n个人都是排成一排。</p>
<p>现在所有拍摄的照片中，任意两个人如果没有相邻，那么它们不开心，问有多少人不开心。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>n和m的数量都不大，直接$O(n*m)$模拟统计即可。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 55</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> g[n][n];</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">-1</span>, x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            x--;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="number">-1</span>)</span><br><span class="line">                g[x][p] = g[p][x] = <span class="number">1</span>;</span><br><span class="line">            p = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="number">0</span>)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Dash"><a href="#C-Dash" class="headerlink" title="C - Dash"></a><a href="https://atcoder.jp/contests/abc303/tasks/abc303_c">C - Dash</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>一个人初始在(0,0)位置，现在初始生命值为H，有m个位置上有加生命的物品。每次只能上下左右移动，移动后需要消耗生命值1点，当移动前生命值是负数则不能移动，否则移动后如果有血包且生命值严格小于k则将生命值变为k。</p>
<p>给你一个移动序列，问能否移动n步。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>严格按照题意模拟。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, h, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h &gt;&gt; k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        st.<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i : s) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; h &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--h &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">count</span>(&#123;x + <span class="number">1</span>, y&#125;) &amp;&amp; h &lt; k)</span><br><span class="line">                h = k, st.<span class="built_in">erase</span>(&#123;x + <span class="number">1</span>, y&#125;);</span><br><span class="line"></span><br><span class="line">            x += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--h &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">count</span>(&#123;x - <span class="number">1</span>, y&#125;) &amp;&amp; h &lt; k)</span><br><span class="line">                h = k, st.<span class="built_in">erase</span>(&#123;x - <span class="number">1</span>, y&#125;);</span><br><span class="line">            x -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--h &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">count</span>(&#123;x, y + <span class="number">1</span>&#125;) &amp;&amp; h &lt; k)</span><br><span class="line">                h = k, st.<span class="built_in">erase</span>(&#123;x, y + <span class="number">1</span>&#125;);</span><br><span class="line">            y += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--h &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">count</span>(&#123;x, y - <span class="number">1</span>&#125;) &amp;&amp; h &lt; k)</span><br><span class="line">                h = k, st.<span class="built_in">erase</span>(&#123;x, y - <span class="number">1</span>&#125;);</span><br><span class="line">            y -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-Shift-vs-CapsLock"><a href="#D-Shift-vs-CapsLock" class="headerlink" title="D - Shift vs. CapsLock"></a><a href="https://atcoder.jp/contests/abc303/tasks/abc303_d">D - Shift vs. CapsLock</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有一个键盘，有a键，shift键，大写锁定键。现在按下a件需要时间是x，同时按下a和shift时间是y，按下大写锁定时间是z。</p>
<p>问花最少的时间使得屏幕上的字符串是S。S仅有大小写a组成。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>动态规划</p>
<p>考虑dp_{i,j}为输完第j个字符且大小写锁定的状态是i，(0没有锁定，1锁定)</p>
<p>状态转移考虑前一状态和当前状态的大小写锁定状态和所遇到的字符大小写。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 300005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x, y, z;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="built_in">min</span>(&#123;dp[<span class="number">0</span>][i], dp[<span class="number">1</span>][i - <span class="number">1</span>] + z + x,</span><br><span class="line">                            dp[<span class="number">1</span>][i - <span class="number">1</span>] + y + z&#125;);        <span class="comment">// on -&gt; off</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="built_in">min</span>(&#123;dp[<span class="number">0</span>][i], dp[<span class="number">0</span>][i - <span class="number">1</span>] + x&#125;);  <span class="comment">// off -&gt; off</span></span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="built_in">min</span>(&#123;dp[<span class="number">1</span>][i], dp[<span class="number">1</span>][i - <span class="number">1</span>] + y&#125;);  <span class="comment">// on -&gt; on</span></span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="built_in">min</span>(&#123;dp[<span class="number">1</span>][i], dp[<span class="number">0</span>][i - <span class="number">1</span>] + x + z,</span><br><span class="line">                            dp[<span class="number">0</span>][i - <span class="number">1</span>] + z + y&#125;);  <span class="comment">// off -&gt; on</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="built_in">min</span>(&#123;dp[<span class="number">0</span>][i], dp[<span class="number">1</span>][i - <span class="number">1</span>] + x + z,</span><br><span class="line">                            dp[<span class="number">1</span>][i - <span class="number">1</span>] + z + y&#125;);        <span class="comment">// on -&gt; off</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="built_in">min</span>(&#123;dp[<span class="number">0</span>][i], dp[<span class="number">0</span>][i - <span class="number">1</span>] + y&#125;);  <span class="comment">// off -&gt; off</span></span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="built_in">min</span>(&#123;dp[<span class="number">1</span>][i], dp[<span class="number">1</span>][i - <span class="number">1</span>] + x&#125;);  <span class="comment">// on -&gt; on</span></span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="built_in">min</span>(&#123;dp[<span class="number">1</span>][i], dp[<span class="number">0</span>][i - <span class="number">1</span>] + z + x,</span><br><span class="line">                            dp[<span class="number">0</span>][i - <span class="number">1</span>] + y + z&#125;);  <span class="comment">// off -&gt; on</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(dp[<span class="number">0</span>][n], dp[<span class="number">1</span>][n]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-A-Gift-From-the-Stars"><a href="#E-A-Gift-From-the-Stars" class="headerlink" title="E - A Gift From the Stars"></a><a href="https://atcoder.jp/contests/abc303/tasks/abc303_e">E - A Gift From the Stars</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给出一张有很多菊花图被连到了一起的图，现在要找到初始时的菊花图个数和各自的大小。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>从叶子节点开始每经过到3的倍数条边，就要断开一条。</p>
<p>可以递归再回溯时计数，且菊花图的中心也是到叶子的距离也存在3的周期关系。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa) &#123;</span><br><span class="line">        <span class="type">int</span> rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            rt = <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rt == <span class="number">1</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(g[u].<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (rt + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>) == <span class="number">1</span>)</span><br><span class="line">        ans.<span class="built_in">push_back</span>(g[<span class="number">1</span>].<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : ans)</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F-Damage-over-Time"><a href="#F-Damage-over-Time" class="headerlink" title="F - Damage over Time"></a><a href="https://atcoder.jp/contests/abc303/tasks/abc303_f">F - Damage over Time</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>有一个怪兽有h点生命，现在每一轮可以从n种魔法种放出一种，当在第j轮释放i种魔法，则对怪兽造成$d_i$的伤害，且持续$t_i$轮。</p>
<p>确定最早的轮数使得怪兽的生命为非正数。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="G-Bags-Game"><a href="#G-Bags-Game" class="headerlink" title="G - Bags Game"></a><a href="https://atcoder.jp/contests/abc303/tasks/abc303_g">G - Bags Game</a></h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>有两个人Takahashi 和 Aoki 在博弈，有一排物品，每个物品价值不同，现在每个人轮流做出三种选择之一：</p>
<ol>
<li>选择拿走最左边或最右边的一个物品并获取其价值。</li>
<li>支付A元，然后可以重复min(B,n)次操作1，n是剩余物品大小</li>
<li>支付C元，然后可以重复min(D,n)次操作1，n是剩余物品大小</li>
</ol>
<p>Takahashi先手，二人发挥最佳水平。</p>
<p>求Takahashi所得金额 - Aoki所得金额</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Ex-Constrained-Tree-Degree"><a href="#Ex-Constrained-Tree-Degree" class="headerlink" title="Ex - Constrained Tree Degree"></a><a href="https://atcoder.jp/contests/abc303/tasks/abc303_h">Ex - Constrained Tree Degree</a></h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>atcode</category>
      </categories>
      <tags>
        <tag>contest</tag>
        <tag>atcode</tag>
      </tags>
  </entry>
  <entry>
    <title>KYOCERA Programming Contest 2023（AtCoder Beginner Contest 305）</title>
    <url>/2023/06/13/abc305/</url>
    <content><![CDATA[<h1 id="KYOCERA-Programming-Contest-2023（AtCoder-Beginner-Contest-305）"><a href="#KYOCERA-Programming-Contest-2023（AtCoder-Beginner-Contest-305）" class="headerlink" title="KYOCERA Programming Contest 2023（AtCoder Beginner Contest 305）"></a>KYOCERA Programming Contest 2023（AtCoder Beginner Contest 305）</h1><p><a href="https://atcoder.jp/contests/abc305/tasks">Complete problemset</a></p>
<h2 id="A-Water-Station"><a href="#A-Water-Station" class="headerlink" title="A - Water Station"></a><a href="https://atcoder.jp/contests/abc305/tasks/abc305_a">A - Water Station</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个数x，求离他最近的5的倍数</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>x%5为3或4，则为$5\times \lceil\frac{x}{5}\rceil$，否则为$5\times \lfloor\frac{x}{5}\rfloor$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">3</span> || n % <span class="number">5</span> == <span class="number">4</span>) &#123;</span><br><span class="line">        cout &lt;&lt; (n + <span class="number">5</span>) / <span class="number">5</span> * <span class="number">5</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; n / <span class="number">5</span> * <span class="number">5</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-ABCDEFG"><a href="#B-ABCDEFG" class="headerlink" title="B - ABCDEFG"></a><a href="https://atcoder.jp/contests/abc305/tasks/abc305_b">B - ABCDEFG</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出ABCDEFG两两之间的距离，求任意两点的距离</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>求出前缀和，对查询的两点做差即可得到区间和。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a[<span class="string">&#x27;A&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">    a[<span class="string">&#x27;B&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">    a[<span class="string">&#x27;C&#x27;</span>] = <span class="number">4</span>;</span><br><span class="line">    a[<span class="string">&#x27;D&#x27;</span>] = <span class="number">8</span>;</span><br><span class="line">    a[<span class="string">&#x27;E&#x27;</span>] = <span class="number">9</span>;</span><br><span class="line">    a[<span class="string">&#x27;F&#x27;</span>] = <span class="number">14</span>;</span><br><span class="line">    a[<span class="string">&#x27;G&#x27;</span>] = <span class="number">23</span>;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">abs</span>(a[s1[<span class="number">0</span>]] - a[s2[<span class="number">0</span>]]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Snuke-the-Cookie-Picker"><a href="#C-Snuke-the-Cookie-Picker" class="headerlink" title="C - Snuke the Cookie Picker"></a><a href="https://atcoder.jp/contests/abc305/tasks/abc305_c">C - Snuke the Cookie Picker</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出一个二维矩阵，大小为H * W</p>
<p>求内部存在一个矩形区域（至少为2*2）有饼干，现在有人拿走了一块饼干，求拿走饼干的位置。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>先求出矩形区域，然后扫描矩形区域寻找缺失位置</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 505</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; g[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a = N, b = N, c = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                a = <span class="built_in">min</span>(a, i);</span><br><span class="line">                c = <span class="built_in">max</span>(c, i);</span><br><span class="line">                b = <span class="built_in">min</span>(b, j);</span><br><span class="line">                d = <span class="built_in">max</span>(d, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; a &lt;= i &amp;&amp; i &lt;= c &amp;&amp; b &lt;= j &amp;&amp; j &lt;= d) &#123;</span><br><span class="line">                x = i, y = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; x + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-Sleep-Log"><a href="#D-Sleep-Log" class="headerlink" title="D - Sleep Log"></a><a href="https://atcoder.jp/contests/abc305/tasks/abc305_d">D - Sleep Log</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个升序序列$A_1=0, A_2, \cdots, A_n$，n为奇数。这个序列代表某个人的睡眠日志。</p>
<p>对于$A_i$，若i为奇数则说明这个人从这一刻起床了，若i为偶数则说明这个人从这一刻进入睡眠。</p>
<p>现在有q次查询，每次查询两个时间点<code>[l,r)</code>之间有久睡眠时间。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>设$p_i$为$A_i$之前有多久睡眠时间。</p>
<p>对$A$二分查找找到最后一个小于等于$l$的$A_x$</p>
<p>对$A$二分查找找到最后一个小于等于$r$的$A_y$</p>
<p>得到一个粗糙的答案 $p_y-p_x$</p>
<p>这时候分分析x和y的奇偶性。</p>
<p>当x为奇数时，多余了$l-A_x$，当y为奇数时，缺少了$r-A_y$。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line">ll p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        p[i] += p[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            p[i] += a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; a[i] &lt;&lt; &quot; &quot; &lt;&lt; p[i] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        ll x = <span class="built_in">upper_bound</span>(a, a + n, l) - a - <span class="number">1</span>;</span><br><span class="line">        ll y = <span class="built_in">upper_bound</span>(a, a + n, r) - a - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">        ll ans = p[y] - p[x];</span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">2</span>)</span><br><span class="line">            ans -= l - a[x];</span><br><span class="line">        <span class="keyword">if</span> (y % <span class="number">2</span>)</span><br><span class="line">            ans += r - a[y];</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-Art-Gallery-on-Graph"><a href="#E-Art-Gallery-on-Graph" class="headerlink" title="E - Art Gallery on Graph"></a><a href="https://atcoder.jp/contests/abc305/tasks/abc305_e">E - Art Gallery on Graph</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给出一个图，有n个节点和m条边，其中有k个<strong>守卫节点</strong>，每个守卫节点v都有一个守卫范围h，对于所有节点u到守卫节点v的距离不超过h则u收到保护。</p>
<p>现在问有多少节点收到保护。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>dijkstra 变形</p>
<p>考虑一个点u，找到能保护到u且最近的守卫节点v，若其守卫范围为h，那么我们可以将u也作为一个守卫节点，其守卫范围为h减去u到v的距离。</p>
<p>我们设每个节点的保护范围为dis，其中有k个点的保护范围已经确定，其余为-1.</p>
<p>然后将这k个点的加入优先队列，每次从队列中优先选出dis最大的点u，并与u所连接的所有v进行松弛操作。当$dis_u - 1 &gt; dis_v$时，更新$dis_v=dis_u-1$且将$v$加入队列。</p>
<p>最后得到每个点dis，若dis&gt;-1则为受到到保护的点。</p>
<p>这里一个重要转化就是，受到保护点其实可以看作守卫节点，其守卫范围取决于相邻守卫节点中守卫最大范围减去1.</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dis[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> p, h;</span><br><span class="line">        cin &gt;&gt; p &gt;&gt; h;</span><br><span class="line">        dis[p] = h;</span><br><span class="line">        q.<span class="built_in">emplace</span>(h, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [h, u] = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] - <span class="number">1</span> &gt; dis[v]) &#123;</span><br><span class="line">                dis[v] = dis[u] - <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">emplace</span>(dis[v], v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[i] != <span class="number">-1</span>)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : ans) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F-Dungeon-Explore"><a href="#F-Dungeon-Explore" class="headerlink" title="F - Dungeon Explore"></a><a href="https://atcoder.jp/contests/abc305/tasks/abc305_f">F - Dungeon Explore</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>交互题</p>
<p>有一个n个点m条边的图。图的节点从1到n，起始时你在1位置，现在每次可以移动到相邻位置上，你需要最多移动2n次到达n号节点。</p>
<p>交互</p>
<p>每次移动后你会获得有哪些与当前所在点的相邻点，或者YES，当接收到YES时，说明到达了n号点。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>模拟dfs，每次只移动到没有访问过的点上，如果没有就回溯到上一个点。度为1的点只会访问一次，度大于1的点可能会访问多次，但是均摊到每个点上刚好是两次。</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[<span class="number">5</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">               &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">               &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">               &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">               &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getd</span><span class="params">(<span class="type">int</span> ch)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[ch][i] == <span class="number">1</span>)</span><br><span class="line">            rt.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        <span class="type">int</span> ch = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (vis[x])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ch = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i : getd(st.back())) &#123;</span></span><br><span class="line">        <span class="comment">//     if (vis[i])</span></span><br><span class="line">        <span class="comment">//         continue;</span></span><br><span class="line">        <span class="comment">//     ch = i;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="number">-1</span>) &#123;</span><br><span class="line">            vis[ch] = <span class="number">1</span>;</span><br><span class="line">            st.<span class="built_in">push_back</span>(ch);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            st.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; st.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">back</span>() == n) &#123;</span><br><span class="line">            string s;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="G-Banned-Substrings"><a href="#G-Banned-Substrings" class="headerlink" title="G - Banned Substrings"></a><a href="https://atcoder.jp/contests/abc305/tasks/abc305_g">G - Banned Substrings</a></h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>现在有m个（不超过126个）长度不超过6的字符串，求不包含这些字符串的长度为n的字符串个数。</p>
<p>n&lt;1e18</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>对给出的m个字符构建ac自动机。</p>
<p>我们直到ac自动机的fail指针是当前串的后缀集合，如果当前节点的<strong>fail指针链</strong>上有关键字节点，那么当前节点是不能构成长度为n的合法字符串的。</p>
<p>试想一个长度为n的字符串在ac自动机上跑，如果跑完都没有遇到关键字节点，那么这个字符串就是一个合法串。</p>
<p>定义$f_{i,j}$为i个字符，能与ac自动机的j节点匹配的串个数。答案就是$\sum \limits_{i=0}^c f_{n, i}$，$c$是ac自动机的节点个数。</p>
<p>转移方程<br>$f_{i,j} = \sum f_{i-1, x}$，$x$是在ac自动机上的节点，其存在有一条边指向j节点。</p>
<p>通过ac自动机我们可以得知任意两个节点之间能否转移，我们将其写成矩阵形式B。对于起始位置也就是长度为0的字符串可以用(0,0)位置为1的c*c矩阵A表示。$A\cdot B^n$的第0行i列代表着从0号节点经过n次移动后到达i节点且不经过关键字节点的路径条数。</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 705</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGMA 2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 建立字典树</span></span><br><span class="line"><span class="comment">2. 生成fail指针和字典图</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ac</span> &#123;</span><br><span class="line">    <span class="type">int</span> tr[MAXN][SIGMA];</span><br><span class="line">    <span class="type">int</span> val[MAXN];  <span class="comment">// 关键字节点 val[i] i号节点是编号为val[i]的模式串，从1开始</span></span><br><span class="line">    <span class="type">int</span> fail[MAXN];  <span class="comment">// 指向最长的后缀且是前缀树的前缀</span></span><br><span class="line">    <span class="type">int</span> last[MAXN];  <span class="comment">// 在fail链中指向离自己最近的关键字节点</span></span><br><span class="line">    <span class="type">int</span> sz;          <span class="comment">// 节点个数</span></span><br><span class="line">    <span class="built_in">Ac</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">        <span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="built_in">sizeof</span>(val));</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="built_in">sizeof</span>(fail));</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>(), u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tr[u][s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                tr[u][s[i] - <span class="string">&#x27;a&#x27;</span>] = sz++;</span><br><span class="line">            &#125;</span><br><span class="line">            u = tr[u][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立fail指针和字典图 优化：在建立fail后再建立last</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIGMA; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tr[<span class="number">0</span>][i])</span><br><span class="line">                que.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            val[u] |= val[fail[u]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIGMA; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tr[u][i]) &#123;  <span class="comment">// 存在</span></span><br><span class="line">                    fail[tr[u][i]] = tr[fail[u]][i];</span><br><span class="line">                    last[tr[u][i]] = val[fail[tr[u][i]]]</span><br><span class="line">                                         ? fail[tr[u][i]]</span><br><span class="line">                                         : last[fail[tr[u][i]]];  <span class="comment">// 优化</span></span><br><span class="line">                    que.<span class="built_in">push</span>(tr[u][i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tr[u][i] = tr[fail[u]][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ac;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 505</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    <span class="type">int</span> mat[N][N];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n) &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat)); &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span>*=(<span class="type">const</span> Matrix&amp; o) &#123;</span><br><span class="line">        <span class="type">int</span> ans[n][n] = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j])</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                        ans[i][k] =</span><br><span class="line">                            (ans[i][k] + (<span class="type">long</span> <span class="type">long</span>)(mat[i][j]) * o.mat[j][k]) %</span><br><span class="line">                            MOD;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                mat[i][j] = ans[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                cout &lt;&lt; mat[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // a *= (b^n)</span></span><br><span class="line"><span class="comment">    for (; n; n &gt;&gt;= 1, b *= b)</span></span><br><span class="line"><span class="comment">        if (n &amp; 1)</span></span><br><span class="line"><span class="comment">            a *= b;</span></span><br><span class="line"><span class="comment">    a.print();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        ac.<span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    ac.<span class="built_in">build</span>();</span><br><span class="line">    <span class="type">int</span> sz = ac.sz;</span><br><span class="line">    <span class="function">Matrix <span class="title">a</span><span class="params">(sz)</span>, <span class="title">b</span><span class="params">(sz)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ac.val[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SIGMA; j++) &#123;</span><br><span class="line">                ++b.mat[i][ac.tr[i][j]];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a.mat[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, b *= b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            a *= b;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ac.val[i])</span><br><span class="line">            ans += a.mat[<span class="number">0</span>][i], ans %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; fixed;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SINGLE_INPUT</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">sol</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sol</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Ex-Shojin"><a href="#Ex-Shojin" class="headerlink" title="Ex - Shojin"></a><a href="https://atcoder.jp/contests/abc305/tasks/abc305_h">Ex - Shojin</a></h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>atcode</category>
      </categories>
      <tags>
        <tag>contest</tag>
        <tag>atcode</tag>
      </tags>
  </entry>
  <entry>
    <title>polya计数</title>
    <url>/2023/01/06/polya%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p>六种不同颜色涂正方体，每面不同，共有多少种涂法。</p>
<p>全排列共6!</p>
<p>选一个作顶面有6种，四个侧面选一个作正面有4种，这样去重后就有6!/24 = 30种</p>
<h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><p>群的元素个数是有限的，是有限群</p>
<p>群的元素个数是无限的，是无限群</p>
<p>有限群G的元素个数叫做群的阶，记作|G|</p>
<p>设G是群，H是G的子集，若H在G原有的运算之下也是一个群，则称为G的一个子群</p>
<p>若群G的任意2元素a，b恒满足ab=ba。则称G为交换群，或Abel群。</p>
<p>单位元唯一 e1e2 = e2 = e1</p>
<p>消去律成立 ab = ac → b =c</p>
<p>每个元的逆元唯一</p>
<p>$aa^{-1} = a^{-1}a = e, ab^{-1} = ba^{-1} = e$</p>
<p>$aa^{-1} = ab^{-1}, a^{-1} = b$</p>
<p>$(abc)^{-1} = c^{-1}b^{-1}a^{-1}$</p>
<p>G有限，$a \in G$，则存在最小正整数r，使得$a^r = e$，且$a^{-1} = a^{r-1}$</p>
<h1 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h1><p>置换群是最重要的有限群，所有有限群都可以用之表示。</p>
<p>置换：[1, n]到自身的一一映射称之为n阶置换。[1, n]目标集上的置换表示为$\left( \begin{array}{c} 1&amp;2&amp;\cdots&amp;n\<br>a_1&amp;a_2&amp;\cdots&amp;a_n<br>\end{array}\right)$，$a_1,a_2,\cdots,a_n$是[1,n]的一个排列</p>
<p>置换乘法</p>
<p>$\left( \begin{array}{c} 1&amp;2&amp;3&amp;4\<br>3&amp;1&amp;2&amp;4<br>\end{array}\right)<br>\left( \begin{array}{c} 3&amp;1&amp;2&amp;4\<br>2&amp;4&amp;3&amp;1<br>\end{array}\right) =<br>\left( \begin{array}{c} 1&amp;2&amp;3&amp;4\<br>2&amp;4&amp;3&amp;1<br>\end{array}\right)$</p>
<p>[1,n]的多个置换的乘法构成一个群，称之为置换群。</p>
<p>不满足交换律</p>
<p>满足结合律</p>
<p>有单位元</p>
<p>有逆元</p>
<p>[1,n]上所有置换共n!个，构成一个群，称之为n阶对称群，记为$S_n$</p>
<hr>
<p>对于一个等边三角形的转动群</p>
<p><img src="https://i.328888.xyz/2022/12/24/Djsip.png" alt="Djsip.png"></p>
<p>$p1 = \left( \begin{array}{c} 1&amp;2&amp;3\<br>1&amp;2&amp;3<br>\end{array}\right)$</p>
<p>$p2 = \left( \begin{array}{c} 1&amp;2&amp;3\<br>2&amp;3&amp;1<br>\end{array}\right)$</p>
<p>$p3 = \left( \begin{array}{c} 1&amp;2&amp;3\<br>3&amp;1&amp;2<br>\end{array}\right)$</p>
<p>$p4 = \left( \begin{array}{c} 1&amp;2&amp;3\<br>1&amp;3&amp;2<br>\end{array}\right)$</p>
<p>$p5 = \left( \begin{array}{c} 1&amp;2&amp;3\<br>3&amp;2&amp;1<br>\end{array}\right)$</p>
<p>$p6 = \left( \begin{array}{c} 1&amp;2&amp;3\<br>2&amp;1&amp;3<br>\end{array}\right)$</p>
<h1 id="共轭类"><a href="#共轭类" class="headerlink" title="共轭类"></a>共轭类</h1><p>置换的循环表示</p>
<p>$\left( \begin{array}{c}<br>a_1 &amp; a_2 &amp; \cdots &amp; a_n<br>\end{array}\right)=<br>\left( \begin{array}{c}<br>a_1&amp;a_2&amp;\cdots&amp;a_{n-1}&amp;a_{n}\<br>a_2&amp;a_3&amp;\cdots&amp;a_{n}&amp;a_1<br>\end{array}\right)$</p>
<p>若两个循环无共同文字，称之为不相交，不相交的循环相乘可以交换。</p>
<p>$\left( \begin{array}{c}<br>1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \<br>5 &amp; 2 &amp; 3 &amp; 1 &amp; 4<br>\end{array}\right)=<br>(154)(2)(3)=(3)(154)(2)$</p>
<p>n阶循环</p>
<p>若$p = (a_1a_2\cdots a_n)$，则$p^n = (1)(2)\cdots(n)=e$</p>
<p>$p = (123)$</p>
<p>$p^2 = (321)$</p>
<p>$p^3 = (1)(2)(3)$</p>
<p>共轭类</p>
<p>一般可以把$S_n$中任意一个置换$p$分解为若干不相交的循环乘积</p>
<p>$P = (a_1a_2\cdots a_{k_1})((b_1b_2\cdots b_{k_2}))\dots(h_1h_2\cdots h_{k_u})$</p>
<p>其中$k_1+k_2+\cdots+k_u=n$，设k阶循环出现的次数是$C_k$，用$(k)^{C_k}$表示</p>
<p>则$S_n$中置换的格式为$(1)^{C_1}(2)^{C_2}\cdots (n)^{C_n}$</p>
<p>$\sum \limits _{k=1}^{n} k*C_k = n$</p>
<p>$S_n$中有相同格式的置换全体构成一个共轭类</p>
<p>$S_3= { (1)(2)(3),(12),(13),(23),(123),(132)}$</p>
<p>$(1)^3$共轭类有3个</p>
<p>$(1)(2)$共轭类有3个</p>
<p>$(3)$共轭类有2个</p>
<h1 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h1><p>任何一个循环都可以表示为<strong>对换</strong>的乘积</p>
<p>$\left( \begin{array}{c}<br>1 &amp; 2 &amp; \cdots &amp; n<br>\end{array}\right)=<br>\left( \begin{array}{c}<br>1 &amp; 2<br>\end{array}\right)<br>\left( \begin{array}{c}<br>1 &amp; 3<br>\end{array}\right)<br>\cdots<br>\left( \begin{array}{c}<br>1 &amp; n<br>\end{array}\right)$</p>
<p><strong>证明</strong></p>
<p>若$\left( \begin{array}{c}<br>1 &amp; 2 &amp; \cdots &amp; n-1<br>\end{array}\right)=<br>\left( \begin{array}{c}<br>1 &amp; 2<br>\end{array}\right)<br>\left( \begin{array}{c}<br>1 &amp; 3<br>\end{array}\right)<br>\cdots<br>\left( \begin{array}{c}<br>1 &amp; n-1<br>\end{array}\right)$</p>
<p>由于$\left( \begin{array}{c}<br>1 &amp; 2 &amp; \cdots &amp; n-1<br>\end{array}\right)\left( \begin{array}{c}<br>1 &amp; n<br>\end{array}\right)=\left( \begin{array}{c}<br>1 &amp; 2 &amp; \cdots &amp; n-1 &amp; n\<br>2 &amp; 3 &amp; \cdots &amp; 1 &amp; n<br>\end{array}\right)<br>\left( \begin{array}{c}<br>1 &amp; 2 &amp; \cdots &amp; n-1 &amp; n \<br>n &amp; 2 &amp; \cdots &amp; n-1 &amp; 1<br>\end{array}\right) =<br>\left( \begin{array}{c}<br>1 &amp; 2 &amp; \cdots &amp; n-1 &amp; n \<br>2 &amp; 3 &amp; \cdots &amp; n &amp; 1<br>\end{array}\right)=\left( \begin{array}{c}<br>1 &amp; 2 &amp; \cdots &amp; n-1 &amp; n<br>\end{array}\right)$</p>
<p>所以</p>
<p>$\left( \begin{array}{c}<br>1 &amp; 2 &amp; \cdots &amp; n-1<br>\end{array}\right)<br>\left( \begin{array}{c}<br>1 &amp; n<br>\end{array}\right)=<br>\left( \begin{array}{c}<br>1 &amp; 2 &amp; \cdots &amp; n<br>\end{array}\right)=<br>\left( \begin{array}{c}<br>1 &amp; 2<br>\end{array}\right)<br>\left( \begin{array}{c}<br>1 &amp; 3<br>\end{array}\right)<br>\cdots<br>\left( \begin{array}{c}<br>1 &amp; n<br>\end{array}\right)$</p>
<p>任何置换表示成兑换的个数的奇偶性是唯一的</p>
<h1 id="Burnside引理"><a href="#Burnside引理" class="headerlink" title="Burnside引理"></a>Burnside引理</h1><h2 id="k不动置换类（Stabilizer）"><a href="#k不动置换类（Stabilizer）" class="headerlink" title="k不动置换类（Stabilizer）"></a>k不动置换类（Stabilizer）</h2><p>设$G$是$[1,n]$上的一个置换群。$G$是$S_n$的一个子群。$k \in [1,n]$，$G$中使$k$元素保持不变的置换全体，称之为$k$不动置换类，记作$Z_k$。</p>
<p>$G={a_1,a_2,\dots,a_g} = {e, (12), (34),(12)(34)}$</p>
<p>$Z_1 = {e, (34)}$</p>
<p>$Z_2 = {e, (34)}$</p>
<p>$Z_3 = {e, (12)}$</p>
<p>$Z_3 = {e, (12)}$</p>
<h2 id="等价类（Orbit）"><a href="#等价类（Orbit）" class="headerlink" title="等价类（Orbit）"></a>等价类（Orbit）</h2><p>${1,2,\dots , n}$中的数$k$，若存在置换$p_i$使得$k$变为$l$，则称$k$和$l$属于同一个等价类，数$k$所属的等价类记为$E_k$。</p>
<p>$G={a_1,a_2,\dots,a_g} = {e, (12), (34),(12)(34)}$</p>
<p>$E_1 = {1,2}$</p>
<p>$E_2 = {1,2}$</p>
<p>$E_3 = {3,4}$</p>
<p>$E_4 = {3,4}$</p>
<h2 id="置换的k阶循环次数"><a href="#置换的k阶循环次数" class="headerlink" title="置换的k阶循环次数"></a>置换的k阶循环次数</h2><p>$G$中某个置换$a_i$的$k$阶循环出现次数记为$c_k(a_i)$。</p>
<p>$G={a_1,a_2,\dots,a_g} = {e, (12), (34),(12)(34)}$</p>
<p>$a_1=e = (1)(2)(3)(4)$，$c_1(a_1)=4$</p>
<p>$a_2=(12)(3)(4)$，$c_1(a_2) = 2$，$c_2(a_2)=1$</p>
<h2 id="轨道定理（Orbit-stabilizer-theorem）"><a href="#轨道定理（Orbit-stabilizer-theorem）" class="headerlink" title="轨道定理（Orbit-stabilizer theorem）"></a>轨道定理（Orbit-stabilizer theorem）</h2><p>设$G$是$[1,n]$上的一个置换群，$E_k$是$[1,n]$在$G$的作用下包含$k$的等价类，$Z_k$是$k$不动置换类。有$|E_k||Z_k| = |G|$。</p>
<h2 id="k不动置换类与一阶循环关系"><a href="#k不动置换类与一阶循环关系" class="headerlink" title="k不动置换类与一阶循环关系"></a>k不动置换类与一阶循环关系</h2><p>所有k不动置换类之和等于所有置换的一阶循环个数。</p>
<p>$\sum \limits _{i=1}^{n} |Z_k| = \sum \limits _{j=1}^{|G|}c_1(a_j)$</p>
<h2 id="Burnside引理-1"><a href="#Burnside引理-1" class="headerlink" title="Burnside引理"></a>Burnside引理</h2><p>设$G={a_1,a_2,\dots,a_g}$是目标集合$[1,n]$上的置换群。每个置换都写成不相交循环的乘积。$c_1(a_k)$是置换$a_k$的作用下不动点的个数，即长度为1的循环个数。$G$将$[1,n]$划分成$l$个等价类。等价类的个数为$l=\frac{1}{|G|}\sum \limits _{j=1}^{|G|}c_1(a_j)$</p>
<p><strong>证明</strong></p>
<p>将$[1,n]$分成$l$个等价类，$[1,n]=E_{a_1}+E_{a_2}+\dots+E_{a_l}$</p>
<p>若$i,j$同属一个等价类，则$E_i=E_j,|E_i|=|E_j|$</p>
<p>因$|E_i||Z_i| = |G|$，故$|Z_i|=|Z_j|$</p>
<p>每个等价类中$\sum \limits_{i \in E_{aj}}|Z_i| = |E_{aj}||Z_{aj}|$</p>
<p>共$l$个等价类中$\sum \limits <em>{k=1}^{n}|Z_k| = \sum \limits</em>{j=1}^{l} \sum \limits <em>{i \in E</em>{aj}} |Z_i|=\sum \limits <em>{j=1}^{l}|E</em>{aj}||E_{aj}|=\sum \limits_{j=1}^{l}|G|=l|G|$</p>
<p>$l = \frac{\sum \limits _{k=1}^{n}|Z_k|}{|G|}=\frac{\sum \limits _{j=1}^{|G|}c_1(a_j)}{|G|}$</p>
<hr>
<p>对于一个正方形用红蓝两种颜色对顶点涂色有多少种涂法?</p>
<p><img src="https://i.328888.xyz/2022/12/24/Dj53k.png" alt="Dj53k.png"></p>
<p>只需考虑旋转的等价类个数，涂色方案即等价类个数。</p>
<p>四种不同的旋转，构成置换群内置换个数有4个。</p>
<p>$p_1 = (1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)(14)(15)(16)$</p>
<p>$p_1=(1)\left( \begin{array}{c}2 &amp; 3 &amp; 4 &amp; 5 \end{array}\right) \left( \begin{array}{c} 6 &amp; 7 \end{array}\right)\left( \begin{array}{c}8 &amp; 9 &amp; 10 &amp; 11 \end{array}\right)\left( \begin{array}{c}12 &amp; 13 &amp; 14 &amp; 15 \end{array}\right)(16)$</p>
<p>$p_3=(1)\left( \begin{array}{c}2 &amp; 4 \end{array}\right)\left( \begin{array}{c}3 &amp; 5 \end{array}\right) (6)(7)\left( \begin{array}{c}8 &amp; 10 \end{array}\right)\left( \begin{array}{c}9 &amp; 11 \end{array}\right)\left( \begin{array}{c}12 &amp; 14\end{array}\right)\left( \begin{array}{c}13 &amp; 15\end{array}\right)(16)$</p>
<p>$p_4=(1)\left( \begin{array}{c}2 &amp; 5 &amp; 4 &amp; 3 \end{array}\right) \left( \begin{array}{c} 6 &amp; 7 \end{array}\right)\left( \begin{array}{c}8 &amp; 11 &amp; 10 &amp; 9 \end{array}\right)\left( \begin{array}{c}12 &amp; 15 &amp; 14 &amp; 13 \end{array}\right)(16)$</p>
<p>等价类的个数$\frac{16+2+4+2}{4}=6$</p>
<h1 id="Polya定理"><a href="#Polya定理" class="headerlink" title="Polya定理"></a>Polya定理</h1><p>Burnside引理对于多种着色或复杂的着色对象求解及其复杂。</p>
<p>我们可以关心着色对象结构的置换群而不是着色图像集的置换群</p>
<p>设$\bar G = {\bar p_1,\bar p_2, \dots, \bar p_g}$是n个对象的一个置换群，$C(\bar p_k)$是置换$\bar p_k$的循环个数，对m种颜色对n个对象着色，着色方案数为$l=\frac{1}{|\bar G|}\sum \limits_{i=1}^{|\bar G|} m^{C(\bar p_i)}$</p>
<p>Polya定理种的群是作用在n个对象的置换群，Burnside引理种的群是对这n个对象染色后的方案集合上的置换群。</p>
<hr>
<p>对于一个正方形用红蓝两种颜色对顶点涂色有多少种涂法?</p>
<p>给正方形四个顶点打上标号，正方形四个顶点着色结构置换群$\bar G$</p>
<p>$\bar p_1 = (1)(2)(3)(4)$</p>
<p>$\bar p_2 = (4321)$</p>
<p>$\bar p_3 = (13)(24)$</p>
<p>$\bar p_4 = (1234)$</p>
<p>着色方案数$\frac{2^4+2^1+2^2+2^1}{4}=6$</p>
<h1 id="母函数Polya"><a href="#母函数Polya" class="headerlink" title="母函数Polya"></a>母函数Polya</h1><p>设$\bar G = {\bar p_1,\bar p_2, \dots, \bar p_g}$是$n$个对象的一个置换群，$C(\bar p_k)$是置换$\bar p_k$的循环个数，对$m$种颜色对$n$个对象着色，第$i$种颜色为$b_i$，母函数为$P(G) = \frac{1}{|\bar G|} \sum \limits _{j=1}^{g} \prod \limits _{k=1}^{n} S_k^{c_k(\bar p_j)}, S_k = (b_1^k+b_2^k+\dots+b_m^k), k = 1, 2, \dots, n$</p>
<hr>
<p>Ploya只能得出着色方案数，对于这些着色方案中满足某种条件的着色方案有多少种呢？</p>
<p>例如对正方形的顶点用三种颜色（红绿蓝）着色。两红一绿一蓝有多少种？</p>
<p>给正方形四个顶点打上标号，正方形四个顶点着色结构置换群$\bar G$</p>
<p>$\bar p_1 = (1)(2)(3)(4)$，$(r+g+b)^4$</p>
<p>$\bar p_2 = (4321)$，$(r^4+g^4+b^4)$</p>
<p>$\bar p_3 = (13)(24)$，$(r^2+g^2+b^2)^2$</p>
<p>$\bar p_4 = (1234)$，$(r^4+g^4+b^4)$</p>
<p>求母函数$(r+g+b)^4+2(r^4+g^4+b^4)+(r^2+g^2+b^2)^2$中$r^2gb$的系数即为方案数。</p>
]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>polya计数</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数 III</title>
    <url>/2023/04/09/%E4%B8%91%E6%95%B0%20III/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/ugly-number-iii/">1201. 丑数 III</a></p>
<hr>
<p>给你四个整数：<code>n</code> 、<code>a</code> 、<code>b</code> 、<code>c</code> ，请你设计一个算法来找出第 <code>n</code> 个丑数。</p>
<p>丑数是可以被 <code>a</code> <strong>或</strong> <code>b</code> <strong>或</strong> <code>c</code> 整除的 <strong>正整数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 3, a = 2, b = 3, c = 5</span><br><span class="line">输出：4</span><br><span class="line">解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 4, a = 2, b = 3, c = 4</span><br><span class="line">输出：6</span><br><span class="line">解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12... 其中第 4 个是 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 5, a = 2, b = 11, c = 13</span><br><span class="line">输出：10</span><br><span class="line">解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 1000000000, a = 2, b = 217983653, c = 336916467</span><br><span class="line">输出：1999999984</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n, a, b, c &lt;= 10^9</code></li>
<li>  <code>1 &lt;= a * b * c &lt;= 10^18</code></li>
<li>本题结果在 <code>[1, 2 * 10^9]</code> 的范围内</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们令函数f(x)为不大于x的丑数个数。可见x越大丑数不会减小，f(x)是非递减的。<br>于是可以对f(x)二分查找，找到第一个大于等于n的数便是答案。</p>
<p>但是如何寻找不大于x的丑数个数呢？</p>
<p>答案是$\lfloor \frac{x}{a} \rfloor + \lfloor \frac{x}{b} \rfloor + \lfloor \frac{x}{c} \rfloor - \lfloor \frac{x}{lcm(a,b)} \rfloor - \lfloor \frac{x}{lcm(b,c} \rfloor - \lfloor \frac{x}{lcm(a,c)} \rfloor + \lfloor \frac{x}{lcm(a,b,c)} \rfloor$, 在小于x的a的倍数和b的倍数中a和b的公倍数是重复的需要减去，b和c，a和c都同理。但是对于a，b和c的公倍数实际上a，b与c的倍数之和总共是加了三次，而两两之间的公倍数又恰好减去了三次，我们需要再加一次保证每个数都只出现一次。这就是容斥原理。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> l = <span class="number">0</span>, r = <span class="number">2e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">long</span> m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (m/a+m/b+m/c-m/<span class="built_in">lcm</span>(a,b)-m/<span class="built_in">lcm</span>(a,c)-m/<span class="built_in">lcm</span>(b,c)+m/<span class="built_in">lcm</span>(a, <span class="built_in">lcm</span>(b, c)) &lt; n) &#123;</span><br><span class="line">                l = m+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>两个回文子字符串长度的最大乘积</title>
    <url>/2023/04/09/%E4%B8%A4%E4%B8%AA%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-substrings/">1960. 两个回文子字符串长度的最大乘积</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，你需要找到两个 <strong>不重叠****的回文</strong> 子字符串，它们的长度都必须为 <strong>奇数</strong> ，使得它们长度的乘积最大。</p>
<p>更正式地，你想要选择四个整数 <code>i</code> ，<code>j</code> ，<code>k</code> ，<code>l</code> ，使得 <code>0 &lt;= i &lt;= j &lt; k &lt;= l &lt; s.length</code> ，且子字符串 <code>s[i...j]</code> 和 <code>s[k...l]</code> 都是回文串且长度为奇数。<code>s[i...j]</code> 表示下标从 <code>i</code> 到 <code>j</code> 且 <strong>包含</strong> 两端下标的子字符串。</p>
<p>请你返回两个不重叠回文子字符串长度的 <strong>最大</strong> 乘积。</p>
<p><strong>回文字符串</strong> 指的是一个从前往后读和从后往前读一模一样的字符串。<strong>子字符串</strong> 指的是一个字符串中一段连续字符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ababbb&quot;</span><br><span class="line">输出：9</span><br><span class="line">解释：子字符串 &quot;aba&quot; 和 &quot;bbb&quot; 为奇数长度的回文串。乘积为 3 * 3 = 9 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;zaaaxbbby&quot;</span><br><span class="line">输出：9</span><br><span class="line">解释：子字符串 &quot;aaa&quot; 和 &quot;bbb&quot; 为奇数长度的回文串。乘积为 3 * 3 = 9 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>2 &lt;= s.length &lt;= 10^5</code></li>
<li><code>s</code> 只包含小写英文字母。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>关键思路</p>
<p>找到以<code>s[i]</code>为中心的最长回文串长度<code>span[i]</code>。</p>
<p>接下来预处理出两个数组<code>l</code>和<code>r</code>。</p>
<p><code>l[i]</code>代表<code>s[0...i]</code>内最长奇数回文串长度。</p>
<p><code>r[i]</code>代表<code>s[i...n-1]</code>内最长奇数回文串长度。</p>
<p>枚举维护最大的<code>l[i-1]*r[i], 1&lt;i&lt;n</code>即为答案。</p>
<p>首先求<code>s[i]</code>为中心的最长回文串长度。<br>我们可以用字符串哈希+二分法来做，时间复杂度$O(nlogn)$，<br>也可以用马拉车算法，时间复杂度$O(n)$。</p>
<p>接下来讲述一下字符串哈希+二分的思路。</p>
<p>对于每个<code>s[i]</code>为中心的最长回文串长度如果为m，那么m-2也是以<code>s[i]</code>为中心的回文串。也就是说具有单调性，可以二分找出由小到大最后于一个满足的长度。时间复杂度$O(logn)$，总共有n个点所以需要$O(nlogn)$的时间复杂度。</p>
<p>然后一个难点就是l和r数组。</p>
<p>对于第<code>s[i]</code>可以对<code>l[i+span[i]]</code>做贡献，让其于<code>i+span[i]</code>取最大值。</p>
<p>同理第<code>s[i]</code>可以对<code>r[i-span[i]]</code>做贡献，让其于<code>i-span[i]</code>取最大值。</p>
<p>然后从前向后遍历取l前缀最大值，从后向前遍历取r后缀最大值。</p>
<p>做这里还没有结束。这里还有一个很大的坑</p>
<p>需要由大到小让<code>l[i] = max(l[i], l[i+1]-2)</code>。如果<code>i+1</code>是一个以<code>l[i+1]</code>长度结尾的回文，那么<code>l[i]</code>在此基础上去掉首位所以长度为<code>l[i+1]-2</code></p>
<p>同理<code>r[i] = max(r[i], r[i-1]-2)</code></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="type">int</span> BASE = <span class="number">131</span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxProduct</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;ull&gt; <span class="title">H</span><span class="params">(n+<span class="number">1</span>)</span>, <span class="title">B</span><span class="params">(n+<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            H[i] = H[i<span class="number">-1</span>]*BASE + s[i<span class="number">-1</span>];</span><br><span class="line">            B[i] = B[i<span class="number">-1</span>]*BASE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// s[i...j] = H[j]-H[i]*B[j-i]</span></span><br><span class="line">        <span class="function">vector&lt;ull&gt; <span class="title">RH</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            RH[i] = RH[i+<span class="number">1</span>]*BASE + s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// s[i...j] = RH[i]-RH[j]*B[j-i]</span></span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">return</span> H[r]-H[l]*B[r-l] == RH[l]-RH[r]*B[r-l];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">span</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = <span class="built_in">min</span>(i+<span class="number">1</span>, n-i);</span><br><span class="line">            <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">                <span class="type">int</span> m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> x = i-m, y = i+m;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(x, y+<span class="number">1</span>)) &#123;</span><br><span class="line">                    l = m+<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            span[i] = r<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; span[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(n)</span>, <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            l[i+span[i]] = <span class="built_in">max</span>(l[i+span[i]], <span class="number">2</span>*span[i]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            l[i] = <span class="built_in">max</span>(l[i], l[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            l[i] = <span class="built_in">max</span>(l[i], l[i+<span class="number">1</span>]<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            r[i-span[i]] = <span class="built_in">max</span>(r[i-span[i]], <span class="number">2</span>*span[i]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            r[i] = <span class="built_in">max</span>(r[i], r[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            r[i] = <span class="built_in">max</span>(r[i], r[i<span class="number">-1</span>]<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ull ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="number">1ull</span>*l[i<span class="number">-1</span>]*r[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>关键思路同题解一。</p>
<p>不同点在于求<code>s[i]</code>为中心的最长回文串长度。用马拉车算法，时间复杂度$O(n)$。</p>
<p>设$span_i$为以i为中心的回文半径。在可以让我们知道所有以i为中心的奇数长度回文串。这个回文半径不包含中心，也就是说<code>&quot;abcba&quot;</code>，<code>&#39;c&#39;</code>的回文半径是2。</p>
<p>$d$为遍历到当前回文串最远覆盖的下标，即$d = max(span_j+j), j \in [0, i-1]$。</p>
<p>设$c$为满足$d = max(span_j+j), j \in [0, i-1]$的$j$。<br>在求$span_i$时，$span_j,j&lt;i$已经全部求出，对于求$span_i$：</p>
<p>在$i\le r$时，分两种情况：</p>
<ol>
<li>当$span_i \le r$, 这时$span_i = span_j$, $j$是$i$关于$m$对称的点。即$span_i = span_{i-2m}$</li>
<li>当$span_i &gt; r$, 对于大于$r$的部分用中心扩散法，所以可以先让$span_i = r-i$<br>由这两种情况可知让$span_i = min(r-i, span_{i-2m})$, 然后再做中心扩散法。</li>
</ol>
<p>在$i&gt;r$时，直接使用中心扩散法。</p>
<p>最后便可求得$span$数组。以下标$i$为中心的回文串为<code>[i-span[i]...span[i]+i]</code></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxProduct</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">span</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;i=%d, c=%d, d=%d\n&quot;, i, c, d);</span></span><br><span class="line">            <span class="keyword">if</span> (i&lt;=d) span[i] = <span class="built_in">min</span>(span[<span class="number">2</span>*c-i], d-i);</span><br><span class="line">            <span class="type">int</span> l = i-span[i]<span class="number">-1</span>, r = i+span[i]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l&gt;=<span class="number">0</span> &amp;&amp; r&lt;n &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">                l--, r++;</span><br><span class="line">                span[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (span[i]+i &gt; d) &#123;</span><br><span class="line">                d = span[i]+i;</span><br><span class="line">                c = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// for (int i=0; i&lt;n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; span[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n)</span>, <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="comment">// assert(i+span[i] &lt; n);</span></span><br><span class="line">            L[i+span[i]] = <span class="built_in">max</span>(L[i+span[i]], <span class="number">2</span>*span[i]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            L[i] = <span class="built_in">max</span>(L[i], L[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            L[i] = <span class="built_in">max</span>(L[i], L[i+<span class="number">1</span>]<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// assert(i-span[i] &gt;= 0);</span></span><br><span class="line">            R[i-span[i]] = <span class="built_in">max</span>(R[i-span[i]], <span class="number">2</span>*span[i]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            R[i] = <span class="built_in">max</span>(R[i], R[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            R[i] = <span class="built_in">max</span>(R[i], R[i<span class="number">-1</span>]<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="number">1LL</span>*L[i<span class="number">-1</span>]*R[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>从仓库到码头运输箱子</title>
    <url>/2023/04/09/%E4%BB%8E%E4%BB%93%E5%BA%93%E5%88%B0%E7%A0%81%E5%A4%B4%E8%BF%90%E8%BE%93%E7%AE%B1%E5%AD%90/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/">1687. 从仓库到码头运输箱子</a></p>
<hr>
<p>你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 <strong>箱子数目的限制</strong> 和 <strong>总重量的限制</strong> 。</p>
<p>给你一个箱子数组 <code>boxes</code> 和三个整数 <code>portsCount</code>, <code>maxBoxes</code> 和 <code>maxWeight</code> ，其中 <code>boxes[i] = [ports​​i​, weighti]</code> 。</p>
<ul>
<li>  <code>ports​​i</code> 表示第 <code>i</code> 个箱子需要送达的码头， <code>weightsi</code> 是第 <code>i</code> 个箱子的重量。</li>
<li>  <code>portsCount</code> 是码头的数目。</li>
<li>  <code>maxBoxes</code> 和 <code>maxWeight</code> 分别是卡车每趟运输箱子数目和重量的限制。</li>
</ul>
<p>箱子需要按照 <strong>数组顺序</strong> 运输，同时每次运输需要遵循以下步骤：</p>
<ul>
<li>  卡车从 <code>boxes</code> 队列中按顺序取出若干个箱子，但不能违反 <code>maxBoxes</code> 和 <code>maxWeight</code> 限制。</li>
<li>  对于在卡车上的箱子，我们需要 <strong>按顺序</strong> 处理它们，卡车会通过 <strong>一趟行程</strong> 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 <strong>额外行程</strong> ，箱子也会立马被卸货。</li>
<li>  卡车上所有箱子都被卸货后，卡车需要 <strong>一趟行程</strong> 回到仓库，从箱子队列里再取出一些箱子。</li>
</ul>
<p>卡车在将所有箱子运输并卸货后，最后必须回到仓库。</p>
<p>请你返回将所有箱子送到相应码头的 <strong>最少行程</strong> 次数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最优策略如下：</span><br><span class="line">- 卡车将所有箱子装上车，到达码头 1 ，然后去码头 2 ，然后再回到码头 1 ，最后回到仓库，总共需要 4 趟行程。</span><br><span class="line">所以总行程数为 4 。</span><br><span class="line">注意到第一个和第三个箱子不能同时被卸货，因为箱子需要按顺序处理（也就是第二个箱子需要先被送到码头 2 ，然后才能处理第三个箱子）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6</span><br><span class="line">输出：6</span><br><span class="line">解释：最优策略如下：</span><br><span class="line">- 卡车首先运输第一个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第二、第三、第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第五个箱子，到达码头 2 ，回到仓库，总共 2 趟行程。</span><br><span class="line">总行程数为 2 + 2 + 2 = 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7</span><br><span class="line">输出：6</span><br><span class="line">解释：最优策略如下：</span><br><span class="line">- 卡车运输第一和第二个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第三和第四个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第五和第六个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">总行程数为 2 + 2 + 2 = 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：boxes = [[2,4],[2,5],[3,1],[3,2],[3,7],[3,1],[4,4],[1,3],[5,2]], portsCount = 5, maxBoxes = 5, maxWeight = 7</span><br><span class="line">输出：14</span><br><span class="line">解释：最优策略如下：</span><br><span class="line">- 卡车运输第一个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第二个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第三和第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第五个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。</span><br><span class="line">- 卡车运输第六和第七个箱子，到达码头 3 ，然后去码头 4 ，然后回到仓库，总共 3 趟行程。</span><br><span class="line">- 卡车运输第八和第九个箱子，到达码头 1 ，然后去码头 5 ，然后回到仓库，总共 3 趟行程。</span><br><span class="line">总行程数为 2 + 2 + 2 + 2 + 3 + 3 = 14 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= boxes.length &lt;= 10^5</code></li>
<li>  <code>1 &lt;= portsCount, maxBoxes, maxWeight &lt;= 10^5</code></li>
<li>  <code>1 &lt;= ports​​i &lt;= portsCount</code></li>
<li><code>1 &lt;= weightsi &lt;= maxWeight</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>单调队列优化dp</p>
<p>我们用$p_i$表示前i个箱子港口编号相邻不相同的个数。对于单独的第一个数$p_1=0$，在第一个箱子前设置与第一个箱子港口相同的哨兵，$p_{0} = p_{1}$。对于前i个到前j个箱子（i&lt;=j）相邻不同编号的个数是$p_{j}-p_{i}$。通过观察测试用例可以看出这与以往的前缀和不同。</p>
<p>$w_i$为前i个箱子的重量和，$w_0 = 0$。</p>
<p>$P$是车载箱子最大个数。</p>
<p>$W$是车载最大重量。</p>
<p>令<code>f_i</code>为前i个箱子的最小移动次数。初始化<code>f_0 = 0</code>。</p>
<p>容易想到$f_i = \min \limits_{i-P \le j&lt;i, w_i-w_j \le W} {  f_j+p_i-p_{j+1}+2 }$</p>
<p>现在将式子转化为$f_i = \min \limits_{i-P \le j &lt; i, w_i-w_j \le W} {  f_j-p_{j+1} }+p_i+2$，对于求$\min \limits_{i-P \le j&lt;i, w_i-w_j \le W} {  f_j-p_{j+1} }$可以维护单调递减队列，每次O(1)求得状态转移。总时间复杂度O(n)。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">boxDelivering</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; boxes, <span class="type">int</span> portsCount, <span class="type">int</span> maxBoxes, <span class="type">int</span> maxWeight)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = boxes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">p</span><span class="params">(n+<span class="number">1</span>)</span>, <span class="title">w</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            p[i] = p[i<span class="number">-1</span>] + (boxes[i<span class="number">-1</span>][<span class="number">0</span>] != boxes[i<span class="number">-2</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            w[i] = w[i<span class="number">-1</span>] + boxes[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// vector&lt;int&gt; q(n+5);//队列存储箱子编号</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">            <span class="keyword">return</span> f[a]-p[a+<span class="number">1</span>] &gt; (f[b]-p[b+<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q</span>(cmp);<span class="comment">//小根堆，f[i]-p[i+1]</span></span><br><span class="line">        <span class="comment">// int s = 0, e = 1;</span></span><br><span class="line">        q.<span class="built_in">emplace</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="comment">// while (q[s]+maxBoxes&lt;i || w[i]-w[q[s]]&gt;maxWeight) s++;</span></span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">top</span>()+maxBoxes&lt;i || w[i]-w[q.<span class="built_in">top</span>()]&gt;maxWeight) q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// f[i] = f[q[s]]+p[i]-p[q[s]+1]+2;</span></span><br><span class="line">            f[i] = f[q.<span class="built_in">top</span>()]+p[i]-p[q.<span class="built_in">top</span>()+<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// while (s&lt;e &amp;&amp; i&lt;n &amp;&amp; f[q[e-1]]-p[q[e-1]+1] &gt; f[i]-p[i+1]) e--;</span></span><br><span class="line">            <span class="comment">// q[e++] = i;</span></span><br><span class="line">            <span class="keyword">if</span> (i&lt;n) q.<span class="built_in">emplace</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i=1; i&lt;=n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; f[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>使字符串总不同字符的数目相等</title>
    <url>/2023/04/09/%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%95%B0%E7%9B%AE%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/make-number-of-distinct-characters-equal/">2531. 使字符串总不同字符的数目相等</a></p>
<hr>
<p>给你两个下标从 <strong>0</strong> 开始的字符串 <code>word1</code> 和 <code>word2</code> 。</p>
<p>一次 <strong>移动</strong> 由以下两个步骤组成：</p>
<ul>
<li>  选中两个下标 <code>i</code> 和 <code>j</code> ，分别满足 <code>0 &lt;= i &lt; word1.length</code> 和 <code>0 &lt;= j &lt; word2.length</code> ，</li>
<li>  交换 <code>word1[i]</code> 和 <code>word2[j]</code> 。</li>
</ul>
<p>如果可以通过 <strong>恰好一次</strong> 移动，使 <code>word1</code> 和 <code>word2</code> 中不同字符的数目相等，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;ac&quot;, word2 = &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：交换任何一组下标都会导致第一个字符串中有 2 个不同的字符，而在第二个字符串中只有 1 个不同字符。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;abcc&quot;, word2 = &quot;aab&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：交换第一个字符串的下标 2 和第二个字符串的下标 0 。之后得到 word1 = &quot;abac&quot; 和 word2 = &quot;cab&quot; ，各有 3 个不同字符。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;abcde&quot;, word2 = &quot;fghij&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：无论交换哪一组下标，两个字符串中都会有 5 个不同字符。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= word1.length, word2.length &lt;= 10^5</code></li>
<li><code>word1</code> 和 <code>word2</code> 仅由小写英文字母组成。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>暴力模拟是最简洁的。<br>如果对给出的字符串分类讨论，我们可以无法一次性全面的想到所有的特殊情况，不如暴力模拟。<br>就考虑所有可能的交换情况看是否存在可行解即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isItPossible</span><span class="params">(string w1, string w2)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; a, b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i:w1) a[i]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i:w2) b[i]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [i,j]:a) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [x,y]:b) &#123;</span><br><span class="line">                map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; c = a, d = b;</span><br><span class="line">                c[x]++, d[x]--;</span><br><span class="line">                c[i]--, d[i]++;</span><br><span class="line">                <span class="type">int</span> u=<span class="number">0</span>, v=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> t=<span class="string">&#x27;a&#x27;</span>; t&lt;<span class="string">&#x27;z&#x27;</span>; t++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c[t] &amp;&amp; !d[t]) u++;</span><br><span class="line">                    <span class="keyword">if</span> (!c[t] &amp;&amp; d[t]) v++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (u==v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>暴力模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>使数组严格递增</title>
    <url>/2023/04/09/%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/make-array-strictly-increasing/">1187. 使数组严格递增</a></p>
<hr>
<p>给你两个整数数组 <code>arr1</code> 和 <code>arr2</code>，返回使 <code>arr1</code> 严格递增所需要的最小「操作」数（可能为 0）。</p>
<p>每一步「操作」中，你可以分别从 <code>arr1</code> 和 <code>arr2</code> 中各选出一个索引，分别为 <code>i</code> 和 <code>j</code>，<code>0 &lt;= i &lt; arr1.length</code> 和 <code>0 &lt;= j &lt; arr2.length</code>，然后进行赋值运算 <code>arr1[i] = arr2[j]</code>。</p>
<p>如果无法让 <code>arr1</code> 严格递增，请返回 <code>-1</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]</span><br><span class="line">输出：1</span><br><span class="line">解释：用 2 来替换 5，之后 arr1 = [1, 2, 3, 6, 7]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：arr1 = [1,5,3,6,7], arr2 = [4,3,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：用 3 来替换 5，然后用 4 来替换 3，得到 arr1 = [1, 3, 4, 6, 7]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：无法使 arr1 严格递增。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= arr1.length, arr2.length &lt;= 2000</code></li>
<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们令<code>dp[i][j]</code>为将第i个数改为<code>arr2[j]</code>使得序列升序的代价（j&lt;m）,令<code>dp[i][m]</code>是不改变第i个数使得序列升序的代价。所求答案是<code>min&#123;dp[i-1][]&#125;</code></p>
<p>对于每次状态转移需维护最小值，所以初始化所有状态为无穷大，再预先计算初始状态<code>dp[0][]</code>，即只有一个数的序列改变需要一次操作，不改变不需要操作，<code>dp[0][j] = 1, 0&lt;=j&lt;m，dp[0][m] = 0</code>。</p>
<p>对于状态的转移有四种情况。</p>
<p>在改变第i个时，需要一次操作次数。</p>
<ul>
<li><code>dp[i][j]</code>由<code>dp[i-1][m]+1</code>转移而来，条件是<code>arr2[j] &gt; arr1[m]</code></li>
<li><code>dp[i][j]</code>由<code>dp[i-1][c]+1, 0&lt;=c&lt;j</code>转移而来，实际上是由<code>dp[i][j-1]</code>与<code>dp[i-1][j-1]+1</code>转移, (<code>dp[i][j] = min&#123;dp[i-1][0...j-1]+1&#125; = min&#123;dp[i-1][0...j-2]+1, dp[i-1][j-1]+1&#125; = min&#123;dp[i][j-1], dp[i-1][j-1]+1&#125;</code>)</li>
</ul>
<p>在不改变第i个时，不需要操作次数。</p>
<ul>
<li><code>dp[i][m]</code>由<code>dp[i-1][m]</code>转移而来，条件是<code>arr1[i] &gt; arr1[i-1]</code></li>
<li><code>dp[i][m]</code>由<code>dp[i-1][j]</code>转移而来, 条件是<code>arr1[i] &gt; arr2[j]</code></li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">2005</span>][<span class="number">2005</span>]; <span class="comment">// dp[i][j] 第i个数改为j变成升序的代价，dp[i][m]不改第i个数变升序的代价。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">makeArrayIncreasing</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">sort</span>(arr2.<span class="built_in">begin</span>(), arr2.<span class="built_in">end</span>());</span><br><span class="line">        arr2.<span class="built_in">erase</span>(<span class="built_in">unique</span>(arr2.<span class="built_in">begin</span>(), arr2.<span class="built_in">end</span>()), arr2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// for (int i:arr2) cout &lt;&lt; i &lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="type">int</span> n = arr1.<span class="built_in">size</span>(), m = arr2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][m] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="comment">//i不变由i-1不变 转移</span></span><br><span class="line">            <span class="keyword">if</span> (arr1[i]&gt;arr1[i<span class="number">-1</span>]) dp[i][m] = <span class="built_in">min</span>(dp[i][m], dp[i<span class="number">-1</span>][m]);</span><br><span class="line">            <span class="comment">//i不变由i-1变 转移</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr2[j] &lt; arr1[i]) dp[i][m] = <span class="built_in">min</span>(dp[i][m], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i变由i-1不变 转移</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr2[j] &gt; arr1[i<span class="number">-1</span>]) dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i<span class="number">-1</span>][m]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i变由i-1变 转移</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;m; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(&#123;dp[i][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// for (int j=0; j&lt;=m; j++) &#123;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            <span class="comment">// &#125; cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int ans = INF;</span></span><br><span class="line">        <span class="comment">// for (int i=0; i&lt;=m; i++) ans = min(ans, dp[n-1][i]);</span></span><br><span class="line">        <span class="comment">// return ans == INF ? -1 : ans;</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">min</span>(dp[n<span class="number">-1</span>][m<span class="number">-1</span>], dp[n<span class="number">-1</span>][m]);</span><br><span class="line">        <span class="keyword">return</span> ans==INF?<span class="number">-1</span>:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>使数组所有元素变成 1 的最少操作次数</title>
    <url>/2023/04/23/%E4%BD%BF%E6%95%B0%E7%BB%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%8F%98%E6%88%90%201%20%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/">6392. 使数组所有元素变成 1 的最少操作次数</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始的 <strong>正</strong> 整数数组 <code>nums</code> 。你可以对数组执行以下操作 <strong>任意</strong> 次：</p>
<ul>
<li>  选择一个满足 <code>0 &lt;= i &lt; n - 1</code> 的下标 <code>i</code> ，将 <code>nums[i]</code> 或者 <code>nums[i+1]</code> 两者之一替换成它们的最大公约数。</li>
</ul>
<p>请你返回使数组 <code>nums</code> 中所有元素都等于 <code>1</code> 的 <strong>最少</strong> 操作次数。如果无法让数组全部变成 <code>1</code> ，请你返回 <code>-1</code> 。</p>
<p>两个正整数的最大公约数指的是能整除这两个数的最大正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,6,3,4]</span><br><span class="line">输出：4</span><br><span class="line">解释：我们可以执行以下操作：</span><br><span class="line">- 选择下标 i = 2 ，将 nums[2] 替换为 gcd(3,4) = 1 ，得到 nums = [2,6,1,4] 。</span><br><span class="line">- 选择下标 i = 1 ，将 nums[1] 替换为 gcd(6,1) = 1 ，得到 nums = [2,1,1,4] 。</span><br><span class="line">- 选择下标 i = 0 ，将 nums[0] 替换为 gcd(2,1) = 1 ，得到 nums = [1,1,1,4] 。</span><br><span class="line">- 选择下标 i = 2 ，将 nums[3] 替换为 gcd(1,4) = 1 ，得到 nums = [1,1,1,1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,10,6,14]</span><br><span class="line">输出：-1</span><br><span class="line">解释：无法将所有元素都变成 1 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>2 &lt;= nums.length &lt;= 50</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这是一个思维题。</p>
<p>当出现1的时候，相邻非1的数可以和1求最大公约数然后变为1. 所以<code>出现1的时候，非1的个数</code>就是需要操作的最少次数。</p>
<p>当没有出现1的时候，这个时候我们需要通过求一段区间的gcd为1。这段区间的长度-1就是操作的次数。当出现1的时候就转化为上一种情况。<br>所以<code>区间gcd为1的最短的区间长度+n-2</code>就是需要操作的最少次数。</p>
<p>本题数组长度最多n=50，所以可以用$O(n^2logn)$通过。</p>
<p>直接双重for循环枚举所有区间即可。然后在枚举时可以求出其中gcd=1的最短区间长度。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> o = <span class="built_in">count</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (o) &#123;</span><br><span class="line">            <span class="keyword">return</span> n-o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> c = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> g = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&lt;n; j++) &#123;</span><br><span class="line">                g = <span class="built_in">gcd</span>(g, nums[j]);</span><br><span class="line">                <span class="keyword">if</span> (g == <span class="number">1</span>) &#123;</span><br><span class="line">                    c = <span class="built_in">min</span>(c, j-i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (c == n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> c+n<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>我们还可以优化时间复杂度，理论上可以优化到O(nlogn)</p>
<p>我们观察一下区间gcd的性质。</p>
<p>当区间长度增加时，gcd不会减小。所以如果我们固定区间右端点r，随着区间左端点l增大，区间<code>[l,r]</code>的gcd是非递减的。</p>
<p>我们试想一个区间的gcd<strong>不</strong>为1最多能有多少个不同的值在这个区间内？如果区间内的数由大到小排列成$[a_1, a_2, a_3,\cdots, a_n]$，$a_1$必须是其他数的倍数，$a_2$必须是$a_i,i&gt;2$的倍数。。。我们发现能让区间最长且gcd不为1的情况是这样的$[2,4,8,16,\cdots,2^n]$。因此区间内不同的gcd值就不超过log(n)个。</p>
<p>通过以上两个性质，发现在确定右端点r的情况下，左端点l增长区间[l,r]的gcd不会减少，且存在大量重复，不同的个数就log(n)个。</p>
<p>我们可以去除重复，且对于相同的gcd只记录下标最大的一个。</p>
<p>定义<code>f[r][g]</code>为以r为右端点的区间中区间gcd为g的最大下标l。这样以r为右端点的gcd为g的最小区间就是<code>[l,r]</code>。</p>
<p>由于我们要求gcd为1的最小区间长度。因此对于每个r，求出最小的<code>r-f[r][1]+1</code>即可。</p>
<p>那么以r+1为右端点怎么求呢？<br>从小到大枚举<code>f[r]</code>中的g，g的个数是对数数量级的，并不会超时。<code>f[r][g]</code>随<code>g</code>增大而增大。所以有转移式 <code>f[r+1][gcd(g,nums[r+1])] = f[r][g]</code></p>
<p><code>f[r+1]</code>转移只与<code>f[r]</code>有关因此可以用<code>滚动集合</code>。减少空间复杂度。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> o = <span class="built_in">count</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (o) <span class="keyword">return</span> n-o;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp; <span class="comment">// mp[i] gcd 为i的最右侧下标</span></span><br><span class="line">        <span class="type">int</span> min_len = n+<span class="number">5</span>; <span class="comment">// inf</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [k,v]:mp) &#123;</span><br><span class="line">                t[<span class="built_in">gcd</span>(k, nums[i])] = v;</span><br><span class="line">            &#125;</span><br><span class="line">            t[nums[i]] = i;</span><br><span class="line">            mp = t;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">begin</span>()-&gt;first  == <span class="number">1</span>) &#123;</span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, i-mp.<span class="built_in">begin</span>()-&gt;second+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min_len == n+<span class="number">5</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> min_len+n<span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>区间计数</tag>
      </tags>
  </entry>
  <entry>
    <title>使数组连续的最少操作数</title>
    <url>/2023/04/09/%E4%BD%BF%E6%95%B0%E7%BB%84%E8%BF%9E%E7%BB%AD%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/">2009. 使数组连续的最少操作数</a></p>
<hr>
<p>给你一个整数数组 <code>nums</code> 。每一次操作中，你可以将 <code>nums</code> 中 <strong>任意</strong> 一个元素替换成 <strong>任意</strong> 整数。</p>
<p>如果 <code>nums</code> 满足以下条件，那么它是 <strong>连续的</strong> ：</p>
<ul>
<li>  <code>nums</code> 中所有元素都是 <strong>互不相同</strong> 的。</li>
<li>  <code>nums</code> 中 <strong>最大</strong> 元素与 <strong>最小</strong> 元素的差等于 <code>nums.length - 1</code> 。</li>
</ul>
<p>比方说，<code>nums = [4, 2, 5, 3]</code> 是 <strong>连续的</strong> ，但是 <code>nums = [1, 2, 3, 5, 6]</code> <strong>不是连续的</strong> 。</p>
<p>请你返回使 <code>nums</code> <strong>连续</strong> 的 <strong>最少</strong> 操作次数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,2,5,3]</span><br><span class="line">输出：0</span><br><span class="line">解释：nums 已经是连续的了。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,5,6]</span><br><span class="line">输出：1</span><br><span class="line">解释：一个可能的解是将最后一个元素变为 4 。</span><br><span class="line">结果数组为 [1,2,3,5,4] ，是连续数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,10,100,1000]</span><br><span class="line">输出：3</span><br><span class="line">解释：一个可能的解是：</span><br><span class="line">- 将第二个元素变为 2 。</span><br><span class="line">- 将第三个元素变为 3 。</span><br><span class="line">- 将第四个元素变为 4 。</span><br><span class="line">结果数组为 [1,2,3,4] ，是连续数组。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>二分+滑动窗口</p>
<p>在排序去重后的数组<code>v</code>中，在范围<code>[l，r]</code>内若需要从<code>v[l]</code>到<code>v[r]</code>连续，则需要<code>v[r]-v[l]-1 - (r-l-1)</code>个数填充，而在现在能够填充的数是<code>n-(r-l+1)</code>, 所以当<code>n-1&gt;=v[r]-v[l]</code>便可以填充，为此可以扩大<code>r-l</code>的范围直到找到最后一个满足的便是最大不需要移动的个数，n减去这个数便是最小移动次数。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) st.<span class="built_in">insert</span>(i);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(st.begin(), st.end())</span></span>;</span><br><span class="line">        <span class="comment">// for (int i:v) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sz = v.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = sz+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">int</span> m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=m<span class="number">-1</span>; i&lt;sz; i++) &#123;</span><br><span class="line">                <span class="type">int</span> x = i-m+<span class="number">1</span>, y = i;</span><br><span class="line">                <span class="keyword">if</span> (n<span class="number">-1</span>&gt;=v[y]-v[x]) &#123;</span><br><span class="line">                    ok = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                l = m+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; r-1 &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> n-(r<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>使整数变为 0 的最少操作次数</title>
    <url>/2023/04/09/%E4%BD%BF%E6%95%B4%E6%95%B0%E5%8F%98%E4%B8%BA%200%20%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/">1611. 使整数变为 0 的最少操作次数</a></p>
<hr>
<p>给你一个整数 <code>n</code>，你需要重复执行多次下述操作将其转换为 <code>0</code> ：</p>
<ul>
<li>  翻转 <code>n</code> 的二进制表示中最右侧位（第 <code>0</code> 位）。</li>
<li>  如果第 <code>(i-1)</code> 位为 <code>1</code> 且从第 <code>(i-2)</code> 位到第 <code>0</code> 位都为 <code>0</code>，则翻转 <code>n</code> 的二进制表示中的第 <code>i</code> 位。</li>
</ul>
<p>返回将 <code>n</code> 转换为 <code>0</code> 的最小操作次数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：3 的二进制表示为 &quot;11&quot;</span><br><span class="line">&quot;11&quot; -&gt; &quot;01&quot; ，执行的是第 2 种操作，因为第 0 位为 1 。</span><br><span class="line">&quot;01&quot; -&gt; &quot;00&quot; ，执行的是第 1 种操作。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 6</span><br><span class="line">输出：4</span><br><span class="line">解释：6 的二进制表示为 &quot;110&quot;.</span><br><span class="line">&quot;110&quot; -&gt; &quot;010&quot; ，执行的是第 2 种操作，因为第 1 位为 1 ，第 0 到 0 位为 0 。</span><br><span class="line">&quot;010&quot; -&gt; &quot;011&quot; ，执行的是第 1 种操作。</span><br><span class="line">&quot;011&quot; -&gt; &quot;001&quot; ，执行的是第 2 种操作，因为第 0 位为 1 。</span><br><span class="line">&quot;001&quot; -&gt; &quot;000&quot; ，执行的是第 1 种操作。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>九连环解法</p>
<p>我们知道解九连环第<code>1</code>环可以在杆上任意上下，第<code>i</code>环的上下需要保证<code>i-1</code>环在杆上，<code>1</code>到<code>i-2</code>环都在杆下。如果将题目给出的数字转为二进制，可以将<code>0</code>看作在拆下的环，<code>1</code>看作上好的环。</p>
<p>先推一下九连环的状态转移方程。现在给出长度为<code>n</code>的全<code>1</code>字符串，也就是一个<code>n</code>连环。设<code>dp[n]</code>是解开这个<code>n</code>连环的步数。显然需要解开前<code>n-2</code>个环才能使得第<code>n</code>个环解下，在解下第<code>n</code>个环后再将前<code>n-2</code>个环上好那么问题就转换成了解<code>n-1</code>连环了。所以<code>dp[n] = dp[n-2]*2+dp[n-1]+1</code>。可以初始化<code>dp[1] = 1,dp[2]= 2</code>，剩余对于<code>n&gt;2</code>的<code>dp[n]</code>可以通过递推式得到。</p>
<p>但是题目给出的是一个解了一部分的<code>n</code>连环。在我一番思考后发现：</p>
<p>如果第<code>i</code>个环上好的，假设从<code>1</code>到<code>i-1</code>个环都是取下的，那么我要拆下这个环就要上好前<code>i-1</code>个环然后解一个<code>i</code>连环，就是所需要的步数是<code>dp[i]+dp[i-1]</code>，然而假设可能不成立，前<code>i-1</code>个环可能有没取下的环。但前面的环实际上是为我们解开第<code>i</code>个环节省了步数。</p>
<p>想到这里可以定义<code>d[i]</code> 为解开前<code>i</code>个环的最小步数</p>
<p>如果第<code>i</code>个环是上好的，<code>d[i] = dp[i]+dp[i-1]-d[i-1]</code></p>
<p>如果第<code>i</code>个环是拆下的，<code>d[i] = d[i-1]</code></p>
<p>答案就是<code>dp[sz]</code>, <code>sz</code>是给出数字的二进制长度。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> ring[<span class="number">32</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[p<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span> ring[p]+ring[p<span class="number">-1</span>]-<span class="built_in">dfs</span>(p<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(p<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOneBitOperations</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ring[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        ring[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;<span class="number">32</span>; i++) &#123;</span><br><span class="line">            ring[i] = ring[i<span class="number">-1</span>]+ring[i<span class="number">-2</span>]*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i=0; i&lt;32; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; ring[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; n%2 &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            s.<span class="built_in">push_back</span>(n%<span class="number">2</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(s.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>使网格图至少有一条有效路径的最小代价</title>
    <url>/2023/04/09/%E4%BD%BF%E7%BD%91%E6%A0%BC%E5%9B%BE%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%80%E6%9D%A1%E6%9C%89%E6%95%88%E8%B7%AF%E5%BE%84%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/">1368. 使网格图至少有一条有效路径的最小代价</a></p>
<hr>
<p>给你一个 m x n 的网格图 <code>grid</code> 。 <code>grid</code> 中每个格子都有一个数字，对应着从该格子出发下一步走的方向。 <code>grid[i][j]</code> 中的数字可能为以下几种情况：</p>
<ul>
<li>  <strong>1</strong> ，下一步往右走，也就是你会从 <code>grid[i][j]</code> 走到 <code>grid[i][j + 1]</code></li>
<li>  <strong>2</strong> ，下一步往左走，也就是你会从 <code>grid[i][j]</code> 走到 <code>grid[i][j - 1]</code></li>
<li>  <strong>3</strong> ，下一步往下走，也就是你会从 <code>grid[i][j]</code> 走到 <code>grid[i + 1][j]</code></li>
<li>  <strong>4</strong> ，下一步往上走，也就是你会从 <code>grid[i][j]</code> 走到 <code>grid[i - 1][j]</code></li>
</ul>
<p>注意网格图中可能会有 <strong>无效数字</strong> ，因为它们可能指向 <code>grid</code> 以外的区域。</p>
<p>一开始，你会从最左上角的格子 <code>(0,0)</code> 出发。我们定义一条 <strong>有效路径</strong> 为从格子 <code>(0,0)</code> 出发，每一步都顺着数字对应方向走，最终在最右下角的格子 <code>(m - 1, n - 1)</code> 结束的路径。有效路径 <strong>不需要是最短路径</strong> 。</p>
<p>你可以花费 <code>cost = 1</code> 的代价修改一个格子中的数字，但每个格子中的数字 <strong>只能修改一次</strong> 。</p>
<p>请你返回让网格图至少有一条有效路径的最小代价。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid1.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]</span><br><span class="line">输出：3</span><br><span class="line">解释：你将从点 (0, 0) 出发。</span><br><span class="line">到达 (3, 3) 的路径为： (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) 花费代价 cost = 1 使方向向下 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) 花费代价 cost = 1 使方向向下 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) 花费代价 cost = 1 使方向向下 --&gt; (3, 3)</span><br><span class="line">总花费为 cost = 3.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid2.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,1,3],[3,2,2],[1,1,4]]</span><br><span class="line">输出：0</span><br><span class="line">解释：不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid3.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2],[4,3]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[2,2,2],[2,2,2]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[4]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>m == grid.length</code></li>
<li>  <code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>dijkstra</p>
<p>每个格子对于指向的格子连接一条边权为0的边，对于其他方向的格子连接一条边权为1的边，那么就是求(0,0)到(n-1,m-1)的最短路径。</p>
<p>题中说每个点只能修改一次也就是只能向非指向方向移动一次。但是对于最短路上每个点也只会经过一次，所以直接套最短路dijkstra即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node&amp; o) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> val &gt; o.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> dis[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">    <span class="type">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">        dis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;Node&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = que.<span class="built_in">top</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (u.x == n<span class="number">-1</span> &amp;&amp; u.y == m<span class="number">-1</span>) <span class="keyword">return</span> u.val;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> x = u.x+d[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> y = u.y+d[i][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> v = i+<span class="number">1</span> != grid[u.x][u.y];</span><br><span class="line">                <span class="keyword">if</span> (x&lt;<span class="number">0</span> || x&gt;=n || y&lt;<span class="number">0</span> || y&gt;=m || dis[x][y] &lt;= dis[u.x][u.y]+v) <span class="keyword">continue</span>;</span><br><span class="line">                dis[x][y] = dis[u.x][u.y]+v;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;x, y, dis[x][y]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>图中边权值为0或1</p>
<p>可用01BFS，求最短路</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dis[n][m];</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">        dis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        deque&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">        que.<span class="built_in">emplace_back</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [u,v] = que.<span class="built_in">front</span>(); que.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span> (u == n<span class="number">-1</span> &amp;&amp; v == m<span class="number">-1</span>) <span class="keyword">return</span> dis[u][v];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> x = u+d[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> y = v+d[i][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> val = i+<span class="number">1</span> != grid[u][v];</span><br><span class="line">                <span class="keyword">if</span> (x&lt;<span class="number">0</span> || x&gt;=n || y&lt;<span class="number">0</span> || y&gt;=m || dis[x][y] &lt;= dis[u][v]+val) <span class="keyword">continue</span>;</span><br><span class="line">                dis[x][y] = dis[u][v]+val;</span><br><span class="line">                <span class="keyword">if</span> (val) que.<span class="built_in">emplace_back</span>(x, y);</span><br><span class="line">                <span class="keyword">else</span> que.<span class="built_in">emplace_front</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>修改图中的边权</title>
    <url>/2023/06/08/%E4%BF%AE%E6%94%B9%E5%9B%BE%E4%B8%AD%E7%9A%84%E8%BE%B9%E6%9D%83/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/modify-graph-edge-weights/">2699. 修改图中的边权</a></p>
<hr>
<p>给你一个 <code>n</code> 个节点的 <strong>无向带权连通</strong> 图，节点编号为 <code>0</code> 到 <code>n - 1</code> ，再给你一个整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi, wi]</code> 表示节点 <code>ai</code> 和 <code>bi</code> 之间有一条边权为 <code>wi</code> 的边。</p>
<p>部分边的边权为 <code>-1</code>（<code>wi = -1</code>），其他边的边权都为 <strong>正</strong> 数（<code>wi &gt; 0</code>）。</p>
<p>你需要将所有边权为 <code>-1</code> 的边都修改为范围 <code>[1, 2 * 10^9]</code> 中的 <strong>正整数</strong> ，使得从节点 <code>source</code> 到节点 <code>destination</code> 的 <strong>最短距离</strong> 为整数 <code>target</code> 。如果有 <strong>多种</strong> 修改方案可以使 <code>source</code> 和 <code>destination</code> 之间的最短距离等于 <code>target</code> ，你可以返回任意一种方案。</p>
<p>如果存在使 <code>source</code> 到 <code>destination</code> 最短距离为 <code>target</code> 的方案，请你按任意顺序返回包含所有边的数组（包括未修改边权的边）。如果不存在这样的方案，请你返回一个 <strong>空数组</strong> 。</p>
<p><strong>注意：</strong>你不能修改一开始边权为正数的边。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2023/04/18/graph.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5</span><br><span class="line">输出：[[4,1,1],[2,0,1],[0,3,3],[4,3,1]]</span><br><span class="line">解释：上图展示了一个满足题意的修改方案，从 0 到 1 的最短距离为 5 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2023/04/18/graph-2.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6</span><br><span class="line">输出：[]</span><br><span class="line">解释：上图是一开始的图。没有办法通过修改边权为 -1 的边，使得 0 到 2 的最短距离等于 6 ，所以返回一个空数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2023/04/19/graph-3.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6</span><br><span class="line">输出：[[1,0,4],[1,2,3],[2,3,5],[0,3,1]]</span><br><span class="line">解释：上图展示了一个满足题意的修改方案，从 0 到 2 的最短距离为 6 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 100</code></li>
<li>  <code>1 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
<li>  <code>edges[i].length == 3</code></li>
<li>  <code>0 &lt;= ai, bi &lt; n</code></li>
<li>  <code>wi = -1</code> 或者 <code>1 &lt;= wi &lt;= 10^7</code></li>
<li>  <code>ai != bi</code></li>
<li>  <code>0 &lt;= source, destination &lt; n</code></li>
<li>  <code>source != destination</code></li>
<li>  <code>1 &lt;= target &lt;= 10^9</code></li>
<li>输入的图是连通图，且没有自环和重边。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>dijkstra的高级应用</p>
<p>对于答案不可能的情况有两种，修改边权全为1，但是最短路却大于target，修改边权全为无穷，但是最短路小于target。<br>这两种情况可以通过dijkstra来判断。</p>
<p>若起点为s，终点为e。</p>
<p>先求出所有可修改边修改为1的以s为源点的单源最短路径dis，$dis_i$为点i到点s的最短路径。</p>
<p>随后再次dijkstra，求s为源点的单源最短路径dis2。本次dijkstra需要动态修改边权使得s到e的最短路径为target。</p>
<p>如何动态修改边权？</p>
<p>设点x和y之间的边权为-1，若其边权需要动态修改为w。则w满足$dis2_x + w + dis_e - dis_y = target$。<br>此外由于边权修改最小值为1，所以$w = max(1,target-dis_e+dis_y-dis2_x)$</p>
<p>在第二次dijkstra后对于没有修改的-1边权显然是不会参与最短路的，所以修改为任意正值即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// memset(g, 0x3f, sizeof(g));</span></span><br><span class="line"><span class="type">int</span> dis[N], vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>, mind = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; mind)</span><br><span class="line">                u = j, mind = dis[j];</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == u) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + g[u][v])</span><br><span class="line">                dis[v] = dis[u] + g[u][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">modifiedGraphEdges</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            g[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = g[i[<span class="number">1</span>]][i[<span class="number">0</span>]] = i[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">2</span>] == <span class="number">-1</span>) g[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = g[i[<span class="number">1</span>]][i[<span class="number">0</span>]] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dijkstra</span>(n, src);</span><br><span class="line">        <span class="keyword">if</span> (dis[dst] &lt; target) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            g[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = g[i[<span class="number">1</span>]][i[<span class="number">0</span>]] = i[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">2</span>] == <span class="number">-1</span>) g[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = g[i[<span class="number">1</span>]][i[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dijkstra</span>(n, src);</span><br><span class="line">        <span class="keyword">if</span> (dis[dst] &gt; target) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            g[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = g[i[<span class="number">1</span>]][i[<span class="number">0</span>]] = i[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis2</span><span class="params">(n, INF)</span></span>;</span><br><span class="line">        dis2[src] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="number">0</span>, mind = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (!vis[j] &amp;&amp; dis2[j] &lt; mind)</span><br><span class="line">                    u = j, mind = dis2[j];</span><br><span class="line">            vis[u] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v == u) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (g[u][v] == <span class="number">-1</span>)</span><br><span class="line">                    g[v][u] = g[u][v] = <span class="built_in">max</span>(<span class="number">1</span>, target - dis2[u] - dis[dst] + dis[v]);</span><br><span class="line">                <span class="keyword">if</span> (dis2[v] &gt; dis2[u] + g[u][v])</span><br><span class="line">                    dis2[v] = dis2[u] + g[u][v];</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            i[<span class="number">2</span>] = g[i[<span class="number">0</span>]][i[<span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">2</span>] == <span class="number">-1</span>) i[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>二分+dijstra。</p>
<p>首先排除答案不可能的情况。</p>
<p>对于最短路径上需要修改的边权，修改后的所有边权的任意两条的差值可以不超过1。</p>
<p>而不在最短路径上却需要修改的边权，其实可以任意取值（只要取值后不在最短路上）。</p>
<p>假设给出的图中有ncnt条-1权的边。若所有修改权值后的边的权值和为m，我们可以按照固定顺序给<code>m%ncnt</code>条边权修改为<code>m/ncnt+1</code>,剩余的边权修改为<code>m/ncnt</code>。</p>
<p>然后通过djkstra求最短路径dis。</p>
<p>显然会发现随着m的增大dis也会增大。于是在单调函数上用二分法求出使得dis等于target的m，然后再模拟分配一下需要修改的边权便可得到答案。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="type">long</span> g[N][N]; <span class="comment">// memset(g, 0x3f, sizeof(g));</span></span><br><span class="line"><span class="type">long</span> dis[N], vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">long</span> u = <span class="number">0</span>, mind = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; mind)</span><br><span class="line">                u = j, mind = dis[j];</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == u) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + g[u][v])</span><br><span class="line">                dis[v] = dis[u] + g[u][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">modifiedGraphEdges</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            g[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = g[i[<span class="number">1</span>]][i[<span class="number">0</span>]] = i[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">2</span>] == <span class="number">-1</span>) g[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = g[i[<span class="number">1</span>]][i[<span class="number">0</span>]] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dijkstra</span>(n, src);</span><br><span class="line">        <span class="keyword">if</span> (dis[dst] &lt; target) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            g[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = g[i[<span class="number">1</span>]][i[<span class="number">0</span>]] = i[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">2</span>] == <span class="number">-1</span>) g[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = g[i[<span class="number">1</span>]][i[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dijkstra</span>(n, src);</span><br><span class="line">        <span class="keyword">if</span> (dis[dst] &gt; target) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> dj = [&amp;](<span class="type">long</span> a, <span class="type">long</span> b) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">                g[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = g[i[<span class="number">1</span>]][i[<span class="number">0</span>]] = i[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">            <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">            dis[src] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">long</span> u = <span class="number">0</span>, mind = INF;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                    <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; mind)</span><br><span class="line">                        u = j, mind = dis[j];</span><br><span class="line">                vis[u] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v == u) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (g[u][v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                        g[u][v] = g[v][u] = a;</span><br><span class="line">                        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                            g[u][v] = g[v][u] = a+<span class="number">1</span>;</span><br><span class="line">                            b--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (dis[v] &gt; dis[u] + g[u][v])</span><br><span class="line">                        dis[v] = dis[u] + g[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ncnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">2</span>] == <span class="number">-1</span>) ncnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> l = ncnt, r = ncnt*<span class="number">1e10</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">long</span> m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> a = m/ncnt, b = m%ncnt;</span><br><span class="line">            <span class="built_in">dj</span>(a, b);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; dis[dst] &lt;&lt; &quot; &quot; &lt;&lt; target &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="keyword">if</span> (dis[dst] &gt;= target) r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ncnt) <span class="built_in">dj</span>(r/ncnt, r%ncnt);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; dis[dst] &lt;&lt; &quot; &quot; &lt;&lt; target &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            i[<span class="number">2</span>] = g[i[<span class="number">0</span>]][i[<span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">2</span>] == <span class="number">-1</span>) i[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>分割数组使乘积互质</title>
    <url>/2023/04/09/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E4%BD%BF%E4%B9%98%E7%A7%AF%E4%BA%92%E8%B4%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/split-the-array-to-make-coprime-products/">2584. 分割数组使乘积互质</a></p>
<hr>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，下标从 <strong>0</strong> 开始。</p>
<p>如果在下标 <code>i</code> 处 <strong>分割</strong> 数组，其中 <code>0 &lt;= i &lt;= n - 2</code> ，使前 <code>i + 1</code> 个元素的乘积和剩余元素的乘积互质，则认为该分割 <strong>有效</strong> 。</p>
<ul>
<li>  例如，如果 <code>nums = [2, 3, 3]</code> ，那么在下标 <code>i = 0</code> 处的分割有效，因为 <code>2</code> 和 <code>9</code> 互质，而在下标 <code>i = 1</code> 处的分割无效，因为 <code>6</code> 和 <code>3</code> 不互质。在下标 <code>i = 2</code> 处的分割也无效，因为 <code>i == n - 1</code> 。</li>
</ul>
<p>返回可以有效分割数组的最小下标 <code>i</code> ，如果不存在有效分割，则返回 <code>-1</code> 。</p>
<p>当且仅当 <code>gcd(val1, val2) == 1</code> 成立时，<code>val1</code> 和 <code>val2</code> 这两个值才是互质的，其中 <code>gcd(val1, val2)</code> 表示 <code>val1</code> 和 <code>val2</code> 的最大公约数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/12/14/second.PNG"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,7,8,15,3,5]</span><br><span class="line">输出：2</span><br><span class="line">解释：上表展示了每个下标 i 处的前 i + 1 个元素的乘积、剩余元素的乘积和它们的最大公约数的值。</span><br><span class="line">唯一一个有效分割位于下标 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/12/14/capture.PNG"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,7,15,8,3,5]</span><br><span class="line">输出：-1</span><br><span class="line">解释：上表展示了每个下标 i 处的前 i + 1 个元素的乘积、剩余元素的乘积和它们的最大公约数的值。</span><br><span class="line">不存在有效分割。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>n == nums.length</code></li>
<li>  <code>1 &lt;= n &lt;= 10^4</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对于某个质因子在nums中出现的最早的位置l和最晚的位置r。<br>我们的答案不能出现在<code>[l,r)</code>间。</p>
<p>我们找出所有质因子的分布区间，找到最早的一个不在这些区间的点即可。可以用差分数组做区间修改，最后统计每个点覆盖的次数即可，当出现没有覆盖的位置则存在答案。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> N 1000005</span></span><br><span class="line">    <span class="type">int</span> mpf[N];<span class="comment">//mpf[i] i的 min prime factor</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getmpf</span><span class="params">()</span> </span>&#123;<span class="comment">//获取N以内所有数的最小质因子</span></span><br><span class="line">        <span class="built_in">memset</span>(mpf, <span class="number">0</span>, <span class="built_in">sizeof</span>(mpf));</span><br><span class="line">        <span class="type">int</span> sz = <span class="built_in">sqrt</span>(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mpf[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i*i; j&lt;N; j+=i) &#123;</span><br><span class="line">                mpf[j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mpf[i] == <span class="number">0</span>) mpf[i] = i;<span class="comment">//质数的最小质因子是本身</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i=0; i&lt;N; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot;=&quot; &lt;&lt; mpf[i] &lt;&lt; &quot;, &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findValidSplit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">getmpf</span>();</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        map&lt;<span class="type">int</span>,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=x; i&gt;<span class="number">1</span>; i = i/mpf[i]) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; mpf[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                <span class="keyword">if</span> (!mp.<span class="built_in">count</span>(mpf[i])) mp[mpf[i]] = &#123;n+<span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">                mp[mpf[i]].first = <span class="built_in">min</span>(mp[mpf[i]].first, j);</span><br><span class="line">                mp[mpf[i]].second = <span class="built_in">max</span>(mp[mpf[i]].second, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [i,j]:mp) &#123;</span><br><span class="line">            d[j.first]++;</span><br><span class="line">            d[j.second]--;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; j.first &lt;&lt; &quot; &quot; &lt;&lt; j.second &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            p += d[i];</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>判断一个点是否可以到达</title>
    <url>/2023/04/09/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/check-if-point-is-reachable/">2543. 判断一个点是否可以到达</a></p>
<hr>
<p>给你一个无穷大的网格图。一开始你在 <code>(1, 1)</code> ，你需要通过有限步移动到达点 <code>(targetX, targetY)</code> 。</p>
<p><strong>每一步</strong> ，你可以从点 <code>(x, y)</code> 移动到以下点之一：</p>
<ul>
<li>  <code>(x, y - x)</code></li>
<li>  <code>(x - y, y)</code></li>
<li>  <code>(2 * x, y)</code></li>
<li>  <code>(x, 2 * y)</code></li>
</ul>
<p>给你两个整数 <code>targetX</code> 和 <code>targetY</code> ，分别表示你最后需要到达点的 X 和 Y 坐标。如果你可以从 <code>(1, 1)</code> 出发到达这个点，请你返回<code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：targetX = 6, targetY = 9</span><br><span class="line">输出：false</span><br><span class="line">解释：没法从 (1,1) 出发到达 (6,9) ，所以返回 false 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：targetX = 4, targetY = 7</span><br><span class="line">输出：true</span><br><span class="line">解释：你可以按照以下路径到达：(1,1) -&gt; (1,2) -&gt; (1,4) -&gt; (1,8) -&gt; (1,7) -&gt; (2,7) -&gt; (4,7) 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= targetX, targetY &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们逆向考虑从(x,y)到(1,1)。</p>
<p>如果只用前两种走法能让(x,y)成为(1,1)，说明x和y是互质的。</p>
<p>增加后两种走法后，x和y分别移除若干2因子后会互质，x和y在32位整数内，2因子个数在30左右</p>
<p>因此枚举即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReachable</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">        <span class="keyword">while</span> (x%<span class="number">2</span>==<span class="number">0</span>) v1.<span class="built_in">push_back</span>(x), x/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (y%<span class="number">2</span>==<span class="number">0</span>) v2.<span class="built_in">push_back</span>(y), y/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span> || y == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(x), v2.<span class="built_in">push_back</span>(y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:v1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j:v2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">gcd</span>(i,j) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>x和y的最大公约数是2的幂次。</p>
<p>若最大公约数是2的幂次，可以通过3，4种操作的逆操作，使得x和y互质。接下来用1，2种操作的逆操作，变为(1,1)</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReachable</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">gcd</span>(x, y);</span><br><span class="line">        <span class="keyword">while</span> (t%<span class="number">2</span> == <span class="number">0</span>) t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> t == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>到达角落需要移除障碍物的最小数目</title>
    <url>/2023/04/09/%E5%88%B0%E8%BE%BE%E8%A7%92%E8%90%BD%E9%9C%80%E8%A6%81%E7%A7%BB%E9%99%A4%E9%9A%9C%E7%A2%8D%E7%89%A9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/">2290. 到达角落需要移除障碍物的最小数目</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>grid</code> ，数组大小为 <code>m x n</code> 。每个单元格都是两个值之一：</p>
<ul>
<li>  <code>0</code> 表示一个 <strong>空</strong> 单元格，</li>
<li>  <code>1</code> 表示一个可以移除的 <strong>障碍物</strong> 。</li>
</ul>
<p>你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。</p>
<p>现在你需要从左上角 <code>(0, 0)</code> 移动到右下角 <code>(m - 1, n - 1)</code> ，返回需要移除的障碍物的 <strong>最小</strong> 数目。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,1,1],[1,1,0],[1,1,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：可以移除位于 (0, 1) 和 (0, 2) 的障碍物来创建从 (0, 0) 到 (2, 2) 的路径。</span><br><span class="line">可以证明我们至少需要移除两个障碍物，所以返回 2 。</span><br><span class="line">注意，可能存在其他方式来移除 2 个障碍物，创建出可行的路径。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]</span><br><span class="line">输出：0</span><br><span class="line">解释：不移除任何障碍物就能从 (0, 0) 到 (2, 4) ，所以返回 0 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>m == grid.length</code></li>
<li>  <code>n == grid[i].length</code></li>
<li>  <code>1 &lt;= m, n &lt;= 10^5</code></li>
<li>  <code>2 &lt;= m * n &lt;= 10^5</code></li>
<li>  <code>grid[i][j]</code> 为 <code>0</code> <strong>或</strong> <code>1</code></li>
<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>建图</p>
<p>对于从当前点走向障碍物，则建立一条边权为1的边。</p>
<p>对于从当前点走向空单元格，则建立一条边权为0的边。</p>
<p>然后求最短路径即可。</p>
<p>可用01dfs或dijkstra。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>01bfs</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        deque&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; que; </span><br><span class="line">        que.<span class="built_in">emplace_back</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> dis[n][m]; </span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">        dis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = que.<span class="built_in">front</span>(); que.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> mx = (i<span class="number">-1</span>)%<span class="number">2</span>+x;</span><br><span class="line">                <span class="type">int</span> my = (i<span class="number">-2</span>)%<span class="number">2</span>+y;</span><br><span class="line">                <span class="keyword">if</span> (mx&lt;<span class="number">0</span> || mx&gt;=n || my&lt;<span class="number">0</span> || my&gt;=m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> val = grid[mx][my] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (dis[mx][my] &gt; dis[x][y]+val) &#123;</span><br><span class="line">                    dis[mx][my] = dis[x][y]+val;</span><br><span class="line">                    <span class="keyword">if</span> (val) que.<span class="built_in">emplace_back</span>(mx, my);</span><br><span class="line">                    <span class="keyword">else</span> que.<span class="built_in">emplace_front</span>(mx, my);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>dijkstra</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">int</span> dis;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node&amp; o) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dis &gt; o.dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        priority_queue&lt;Node&gt; que; </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dis</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, INF));</span><br><span class="line">        que.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        dis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = que.<span class="built_in">top</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> x = node.x;</span><br><span class="line">            <span class="type">int</span> y = node.y;</span><br><span class="line">            <span class="type">int</span> d = node.dis;</span><br><span class="line">            <span class="comment">// if (x == n-1 &amp;&amp; y == m-1) return d;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> mx = dx[i]+x;</span><br><span class="line">                <span class="type">int</span> my = dy[i]+y;</span><br><span class="line">                <span class="keyword">if</span> (mx&lt;<span class="number">0</span> || mx&gt;=n || my&lt;<span class="number">0</span> || my&gt;=m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> val = grid[mx][my] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (dis[mx][my] &gt; dis[x][y]+val) &#123;</span><br><span class="line">                    dis[mx][my] = dis[x][y]+val;</span><br><span class="line">                    que.<span class="built_in">push</span>(&#123;mx,my,dis[mx][my]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>制作 m 束花所需的最少天数</title>
    <url>/2023/04/09/%E5%88%B6%E4%BD%9C%20m%20%E6%9D%9F%E8%8A%B1%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/">1482. 制作 m 束花所需的最少天数</a></p>
<hr>
<p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code> 。</p>
<p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 <strong>相邻的 <code>k</code> 朵花</strong> 。</p>
<p>花园中有 <code>n</code> 朵花，第 <code>i</code> 朵花会在 <code>bloomDay[i]</code> 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p>
<p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 <strong>-1</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [1,10,3,10,2], m = 3, k = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。</span><br><span class="line">现在需要制作 3 束花，每束只需要 1 朵。</span><br><span class="line">1 天后：[x, _, _, _, _]   // 只能制作 1 束花</span><br><span class="line">2 天后：[x, _, _, _, x]   // 只能制作 2 束花</span><br><span class="line">3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [1,10,3,10,2], m = 3, k = 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3</span><br><span class="line">输出：12</span><br><span class="line">解释：要制作 2 束花，每束需要 3 朵。</span><br><span class="line">花园在 7 天后和 12 天后的情况如下：</span><br><span class="line">7 天后：[x, x, x, x, _, x, x]</span><br><span class="line">可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。</span><br><span class="line">12 天后：[x, x, x, x, x, x, x]</span><br><span class="line">显然，我们可以用不同的方式制作两束花。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [1000000000,1000000000], m = 1, k = 1</span><br><span class="line">输出：1000000000</span><br><span class="line">解释：需要等 1000000000 天才能采到花来制作花束</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>bloomDay.length == n</code></li>
<li>  <code>1 &lt;= n &lt;= 10^5</code></li>
<li>  <code>1 &lt;= bloomDay[i] &lt;= 10^9</code></li>
<li>  <code>1 &lt;= m &lt;= 10^6</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果给出一个期限，问是否能在期限内完成，期限小无法完成，期限大总能完成。那就要找到最小的能完成的期限</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bloomDay, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = bloomDay.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1L</span>*m*k&gt;n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">long</span> l = <span class="number">0</span>, r = *<span class="built_in">max_element</span>(bloomDay.<span class="built_in">begin</span>(), bloomDay.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">long</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>, flower = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bloomDay[i]&gt;mid) cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((cnt = (++cnt)%k) == <span class="number">0</span>) &#123;</span><br><span class="line">                    flower++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flower&gt;=m) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>包含每个查询的最小区间</title>
    <url>/2023/04/09/%E5%8C%85%E5%90%AB%E6%AF%8F%E4%B8%AA%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-interval-to-include-each-query/">1851. 包含每个查询的最小区间</a></p>
<hr>
<p>给你一个二维整数数组 <code>intervals</code> ，其中 <code>intervals[i] = [lefti, righti]</code> 表示第 <code>i</code> 个区间开始于 <code>lefti</code> 、结束于 <code>righti</code>（包含两侧取值，<strong>闭区间</strong>）。区间的 <strong>长度</strong> 定义为区间中包含的整数数目，更正式地表达是 <code>righti - lefti + 1</code> 。</p>
<p>再给你一个整数数组 <code>queries</code> 。第 <code>j</code> 个查询的答案是满足 <code>lefti &lt;= queries[j] &lt;= righti</code> 的 <strong>长度最小区间 <code>i</code> 的长度</strong> 。如果不存在这样的区间，那么答案是 <code>-1</code> 。</p>
<p>以数组形式返回对应查询的所有答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]</span><br><span class="line">输出：[3,3,1,4]</span><br><span class="line">解释：查询处理如下：</span><br><span class="line">- Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。</span><br><span class="line">- Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。</span><br><span class="line">- Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。</span><br><span class="line">- Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]</span><br><span class="line">输出：[2,-1,4,6]</span><br><span class="line">解释：查询处理如下：</span><br><span class="line">- Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。</span><br><span class="line">- Query = 19：不存在包含 19 的区间，答案为 -1 。</span><br><span class="line">- Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。</span><br><span class="line">- Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= intervals.length &lt;= 10^5</code></li>
<li>  <code>1 &lt;= queries.length &lt;= 10^5</code></li>
<li>  <code>queries[i].length == 2</code></li>
<li>  <code>1 &lt;= lefti &lt;= righti &lt;= 10^7</code></li>
<li><code>1 &lt;= queries[j] &lt;= 10^7</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>直接离散化所有出现过的值，不超过3e5个。</p>
<p>区间修改，单点求最小值</p>
<p>线段树模板题，直接使用线段树维护即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> N 300005</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        ll val, tag;</span><br><span class="line">    &#125; seg[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(Seg&amp; u, <span class="type">const</span> Seg&amp; l, <span class="type">const</span> Seg&amp; r)</span> </span>&#123;</span><br><span class="line">        u.val = <span class="built_in">min</span>(l.val, r.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(Seg&amp; u, Seg&amp; l, Seg&amp; r)</span> </span>&#123;</span><br><span class="line">        l.val = <span class="built_in">min</span>(l.val, u.tag);</span><br><span class="line">        l.tag = <span class="built_in">min</span>(l.tag, u.tag);</span><br><span class="line">        r.val = <span class="built_in">min</span>(r.val, u.tag);</span><br><span class="line">        r.tag = <span class="built_in">min</span>(r.tag, u.tag);</span><br><span class="line">        u.tag = INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">seg_build</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        seg[id].l = l; seg[id].r = r;</span><br><span class="line">        seg[id].val = seg[id].tag = INF;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">seg_build</span>(id&lt;&lt;<span class="number">1</span>, l, m);</span><br><span class="line">        <span class="built_in">seg_build</span>(id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, m+<span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">push_up</span>(seg[id], seg[id&lt;&lt;<span class="number">1</span>], seg[id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">seg_update</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, ll val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= seg[id].l &amp;&amp; seg[id].r &lt;= r) &#123;</span><br><span class="line">            seg[id].val = <span class="built_in">min</span>(seg[id].val, val);</span><br><span class="line">            seg[id].tag = <span class="built_in">min</span>(seg[id].tag, val);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(seg[id], seg[id&lt;&lt;<span class="number">1</span>], seg[id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> m = seg[id].l + seg[id].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) <span class="built_in">seg_update</span>(id&lt;&lt;<span class="number">1</span>, l, r, val);</span><br><span class="line">        <span class="keyword">if</span> (m &lt; r) <span class="built_in">seg_update</span>(id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, l, r, val);</span><br><span class="line">        <span class="built_in">push_up</span>(seg[id], seg[id&lt;&lt;<span class="number">1</span>], seg[id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">seg_query</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= seg[id].l &amp;&amp; seg[id].r &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> seg[id].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(seg[id], seg[id&lt;&lt;<span class="number">1</span>], seg[id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">        ll rt = INF;</span><br><span class="line">        <span class="type">int</span> m = seg[id].l + seg[id].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) rt = <span class="built_in">min</span>(rt, <span class="built_in">seg_query</span>(id&lt;&lt;<span class="number">1</span>, l, r));</span><br><span class="line">        <span class="keyword">if</span> (m &lt; r) rt = <span class="built_in">min</span>(rt, <span class="built_in">seg_query</span>(id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, l, r));</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minInterval</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; q)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>(), qsz = q.<span class="built_in">size</span>();</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:q) mp[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:intervals) mp[i[<span class="number">0</span>]], mp[i[<span class="number">1</span>]];</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i,j]:mp) j = ++sz;</span><br><span class="line">        <span class="built_in">seg_build</span>(<span class="number">1</span>, <span class="number">1</span>, sz);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:intervals) &#123;</span><br><span class="line">            <span class="built_in">seg_update</span>(<span class="number">1</span>, mp[i[<span class="number">0</span>]], mp[i[<span class="number">1</span>]], i[<span class="number">1</span>]-i[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:q) &#123;</span><br><span class="line">            rt.<span class="built_in">push_back</span>((<span class="built_in">seg_query</span>(<span class="number">1</span>, mp[i], mp[i])+<span class="number">1</span>)%(INF+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>动态开点，不用离散化<br>区间修改，单点查询</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        ll l, r, mn, tag;</span><br><span class="line">        Node* ls, *rs;</span><br><span class="line">        <span class="built_in">Node</span>(ll _l, ll _r):<span class="built_in">l</span>(_l), <span class="built_in">r</span>(_r), <span class="built_in">mn</span>(INF), <span class="built_in">tag</span>(INF), <span class="built_in">ls</span>(<span class="literal">NULL</span>), <span class="built_in">rs</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125; *root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(Node* u)</span> </span>&#123;</span><br><span class="line">        ll l = u-&gt;l, r = u-&gt;r, m = (r-l)/<span class="number">2</span>+l;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;ls == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            u-&gt;ls = <span class="keyword">new</span> <span class="built_in">Node</span>(l, m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;rs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            u-&gt;rs = <span class="keyword">new</span> <span class="built_in">Node</span>(m+<span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;tag != INF) &#123;</span><br><span class="line">            u-&gt;ls-&gt;mn = <span class="built_in">min</span>(u-&gt;ls-&gt;mn, u-&gt;tag);</span><br><span class="line">            u-&gt;ls-&gt;tag = <span class="built_in">min</span>(u-&gt;ls-&gt;tag, u-&gt;tag);</span><br><span class="line">            u-&gt;rs-&gt;mn = <span class="built_in">min</span>(u-&gt;rs-&gt;mn, u-&gt;tag);</span><br><span class="line">            u-&gt;rs-&gt;tag = <span class="built_in">min</span>(u-&gt;rs-&gt;tag, u-&gt;tag);</span><br><span class="line">            u-&gt;tag = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">seg_update</span><span class="params">(Node* u, ll l, ll r, ll val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= u-&gt;l &amp;&amp; u-&gt;r &lt;= r) &#123;</span><br><span class="line">            u-&gt;mn = <span class="built_in">min</span>(u-&gt;mn, val);</span><br><span class="line">            u-&gt;tag = <span class="built_in">min</span>(u-&gt;tag, val);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(u);</span><br><span class="line">        ll m = (u-&gt;r-u-&gt;l)/<span class="number">2</span>+u-&gt;l;</span><br><span class="line">        <span class="keyword">if</span> (l&lt;=m) <span class="built_in">seg_update</span>(u-&gt;ls, l, r, val);</span><br><span class="line">        <span class="keyword">if</span> (m&lt;r) <span class="built_in">seg_update</span>(u-&gt;rs, l, r, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">seg_query</span><span class="params">(Node* u, ll l, ll r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= u-&gt;l &amp;&amp; u-&gt;r &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> u-&gt;mn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(u);</span><br><span class="line">        ll rt = INF;</span><br><span class="line">        ll m = (u-&gt;r-u-&gt;l)/<span class="number">2</span>+u-&gt;l;</span><br><span class="line">        <span class="keyword">if</span> (l&lt;=m) rt = <span class="built_in">min</span>(rt, <span class="built_in">seg_query</span>(u-&gt;ls, l, r));</span><br><span class="line">        <span class="keyword">if</span> (m&lt;r) rt = <span class="built_in">min</span>(rt, <span class="built_in">seg_query</span>(u-&gt;rs, l, r));</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minInterval</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">1e9</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:intervals) &#123;</span><br><span class="line">            <span class="built_in">seg_update</span>(root, i[<span class="number">0</span>], i[<span class="number">1</span>], i[<span class="number">1</span>]-i[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:queries) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>((<span class="built_in">seg_query</span>(root, i, i)+<span class="number">1</span>)%(INF+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>离线操作，对查询升序排序。</p>
<p>对所有区间左端点升序排序</p>
<p>对于查询位置i，将左端点比i小的区间加入到优先队列中，优先队列优先以区间长度小的排前面。</p>
<p>所以查询点i所处最小区间长度，可以通过优先队列队首得到。</p>
<p>但是由于有失效的区间（队列中右端点小于i的区间）存在，可以采用延迟删除的技巧——不断删除队首右端点小于i的区间。</p>
<p>这样做保证了时间复杂度仍然是$O(nlogn)$,因为每个区间只会进队和出队一次，进队出队时间复杂度$O(logn)$</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minInterval</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>(), m = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">idx</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="built_in">iota</span>(idx.<span class="built_in">begin</span>(), idx.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sort</span>(idx.<span class="built_in">begin</span>(), idx.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> a, <span class="type">int</span> b)&#123;<span class="keyword">return</span> queries[a] &lt; queries[b];&#125;);</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q; <span class="comment">// -lenght, right</span></span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:idx) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p&lt;n &amp;&amp; intervals[p][<span class="number">0</span>]&lt;=queries[i]) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(-(intervals[p][<span class="number">1</span>]-intervals[p][<span class="number">0</span>]+<span class="number">1</span>), intervals[p][<span class="number">1</span>]);</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">top</span>().second &lt; queries[i]) q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>()) ans[i] = -q.<span class="built_in">top</span>().first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树状数组线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2022/11/30/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h1 id="单调栈的”一栈两用“"><a href="#单调栈的”一栈两用“" class="headerlink" title="单调栈的”一栈两用“"></a>单调栈的”一栈两用“</h1><p>对数组<strong>从左至右</strong>维护<strong>严格单调递增</strong>栈需要不断移除栈顶元素直到栈顶元素小于待入栈元素。在这个过程中待入栈元素是移除元素右侧第一个小于等于自身的元素。在移除过程结束后，栈顶元素是待入栈元素的左侧第一个小于自身的元素。这样一个<strong>从左至右严格单调递增栈</strong>可以获得每个元素左侧第一个小于自身的元素以及每个元素右侧第一个小于等于自身的元素。</p>
<h1 id="不同单调栈的作用"><a href="#不同单调栈的作用" class="headerlink" title="不同单调栈的作用"></a>不同单调栈的作用</h1><p><strong>从左至右严格单调递增栈</strong>可以获得每个元素<strong>左侧</strong>第一个<strong>小于</strong>自身的元素以及每个元素<strong>右侧</strong>第一个<strong>小于等于</strong>自身的元素。</p>
<p><strong>从左至右单调非减栈</strong>可以获得每个元素<strong>左侧</strong>第一个<strong>小于等于</strong>自身的元素以及每个元素<strong>右侧</strong>第一个<strong>小于</strong>自身的元素。</p>
<p><strong>从左至右严格单调递减栈</strong>可以获得每个元素<strong>左侧</strong>第一个<strong>大于</strong>自身的元素以及每个元素<strong>右侧</strong>第一个<strong>大于等于</strong>自身的元素。</p>
<p><strong>从左至右单调非增栈</strong>可以获得每个元素<strong>左侧</strong>第一个<strong>大于等于</strong>自身的元素以及每个元素<strong>右侧</strong>第一个<strong>大于</strong>自身的元素。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从左至右维护单调栈可以解决所有需求，然后跟增有关的栈得到左右小于或小于等于自身的值，而减有关的栈得到左右大于/大于等于自身的值。总之在从左至右前提下，<strong>增小减大</strong>。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = v.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;index &quot;</span>; <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val &quot;</span>; <span class="keyword">for</span> (<span class="type">int</span> i:v) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l_g</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">r_ge</span><span class="params">(n, n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (st.<span class="built_in">size</span>() &amp;&amp; v[st.<span class="built_in">back</span>()] &lt;= v[i]) &#123;<span class="comment">//严减</span></span><br><span class="line">            r_ge[st.<span class="built_in">back</span>()] = i;</span><br><span class="line">            st.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">size</span>()) l_g[i] = st.<span class="built_in">back</span>();</span><br><span class="line">        st.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l_g &quot;</span>; <span class="keyword">for</span> (<span class="type">int</span> i:l_g) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r_ge &quot;</span>; <span class="keyword">for</span> (<span class="type">int</span> i:r_ge) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    st.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l_ge</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">r_g</span><span class="params">(n, n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (st.<span class="built_in">size</span>() &amp;&amp; v[st.<span class="built_in">back</span>()] &lt; v[i]) &#123;<span class="comment">//非增</span></span><br><span class="line">            r_g[st.<span class="built_in">back</span>()] = i;</span><br><span class="line">            st.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">size</span>()) l_ge[i] = st.<span class="built_in">back</span>();</span><br><span class="line">        st.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l_ge &quot;</span>; <span class="keyword">for</span> (<span class="type">int</span> i:l_ge) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r_g &quot;</span>; <span class="keyword">for</span> (<span class="type">int</span> i:r_g) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    st.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l_l</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">r_le</span><span class="params">(n, n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (st.<span class="built_in">size</span>() &amp;&amp; v[st.<span class="built_in">back</span>()] &gt;= v[i]) &#123;<span class="comment">//严增</span></span><br><span class="line">            r_le[st.<span class="built_in">back</span>()] = i;</span><br><span class="line">            st.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">size</span>()) l_l[i] = st.<span class="built_in">back</span>();</span><br><span class="line">        st.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l_l &quot;</span>; <span class="keyword">for</span> (<span class="type">int</span> i:l_l) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r_le &quot;</span>; <span class="keyword">for</span> (<span class="type">int</span> i:r_le) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    st.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l_le</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">r_l</span><span class="params">(n, n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (st.<span class="built_in">size</span>() &amp;&amp; v[st.<span class="built_in">back</span>()] &gt; v[i]) &#123;<span class="comment">//非减</span></span><br><span class="line">            r_l[st.<span class="built_in">back</span>()] = i;</span><br><span class="line">            st.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">size</span>()) l_le[i] = st.<span class="built_in">back</span>();</span><br><span class="line">        st.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l_le &quot;</span>; <span class="keyword">for</span> (<span class="type">int</span> i:l_le) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r_l &quot;</span>; <span class="keyword">for</span> (<span class="type">int</span> i:r_l) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出情况"><a href="#输出情况" class="headerlink" title="输出情况"></a>输出情况</h2><table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>val</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>l_g</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>4</td>
<td>5</td>
<td>5</td>
<td>4</td>
<td>4</td>
<td>-1</td>
</tr>
<tr>
<td>r_ge</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>10</td>
<td>8</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>
<tr>
<td>l_ge</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
<td>-1</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>5</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>r_g</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>11</td>
<td>11</td>
<td>10</td>
<td>8</td>
<td>8</td>
<td>10</td>
<td>10</td>
<td>11</td>
</tr>
<tr>
<td>l_l</td>
<td>-1</td>
<td>-1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>-1</td>
<td>-1</td>
<td>7</td>
<td>7</td>
<td>9</td>
</tr>
<tr>
<td>r_le</td>
<td>1</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>11</td>
<td>9</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>l_le</td>
<td>-1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td>r_l</td>
<td>11</td>
<td>11</td>
<td>6</td>
<td>5</td>
<td>5</td>
<td>6</td>
<td>11</td>
<td>11</td>
<td>11</td>
<td>11</td>
<td>11</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组</title>
    <url>/2023/06/20/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>非常好用的模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后缀数组，生成sa，rk，height数组</span></span><br><span class="line"><span class="comment">// range应大于串的长度和串元素最大值。串中元素值应非负。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> = string, <span class="type">int</span> range = <span class="number">128</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> SuffixArray &#123;</span><br><span class="line">    T s;</span><br><span class="line">    <span class="type">int</span> n, bucketRange;</span><br><span class="line">    <span class="type">int</span> sa[range], second[range], bucket[range], mem[range], rk_mem[range + <span class="number">1</span>],</span><br><span class="line">        rk2_mem[range + <span class="number">1</span>], height[range], *rk, *rk2;</span><br><span class="line">    <span class="built_in">SuffixArray</span>(<span class="type">const</span> T&amp; _s) : <span class="built_in">s</span>(_s), <span class="built_in">n</span>(s.<span class="built_in">size</span>()), <span class="built_in">bucketRange</span>(range) &#123;</span><br><span class="line">        rk = rk_mem;</span><br><span class="line">        rk2 = rk2_mem;</span><br><span class="line">        rk[n] = rk2[n] = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(bucket, <span class="number">0</span>, <span class="built_in">sizeof</span>(bucket));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            bucket[rk[i] = s[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bucketRange; i++)</span><br><span class="line">            bucket[i] += bucket[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            sa[--bucket[rk[i]]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">1</span>;; w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n - w; i &lt; n; i++)</span><br><span class="line">                second[j++] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="keyword">if</span> (sa[i] &gt;= w)</span><br><span class="line">                    second[j++] = sa[i] - w;</span><br><span class="line">            <span class="built_in">memset</span>(bucket, <span class="number">0</span>, <span class="built_in">sizeof</span>(bucket));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                bucket[mem[i] = rk[second[i]]]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bucketRange; i++)</span><br><span class="line">                bucket[i] += bucket[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                sa[--bucket[mem[i]]] = second[i];</span><br><span class="line">            bucketRange = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                rk2[sa[i]] = !i || (rk[sa[i]] == rk[sa[i - <span class="number">1</span>]] &amp;&amp;</span><br><span class="line">                                    rk[sa[i] + w] == rk[sa[i - <span class="number">1</span>] + w])</span><br><span class="line">                                 ? bucketRange</span><br><span class="line">                                 : ++bucketRange;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(rk, rk2);</span><br><span class="line">            <span class="keyword">if</span> (++bucketRange == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// height[i] 为sa[i-1]与sa[i]的公共前缀长度。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(height, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(height));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, h = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h)</span><br><span class="line">                h--;</span><br><span class="line">            <span class="keyword">if</span> (rk[i])</span><br><span class="line">                <span class="keyword">while</span> (sa[rk[i] - <span class="number">1</span>] + h &lt; n &amp;&amp;</span><br><span class="line">                       s[i + h] == s[sa[rk[i] - <span class="number">1</span>] + h])</span><br><span class="line">                    h++;</span><br><span class="line">            height[rk[i]] = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取后缀x与任意后缀的最长公共前缀长度。x in [0,n-1]</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLcp</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;  <span class="comment">// 注意先要获取height</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lcp</span><span class="params">(n, n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = rk[x], j = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            j = <span class="built_in">min</span>(j, height[i]);</span><br><span class="line">            lcp[sa[i - <span class="number">1</span>]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = rk[x] + <span class="number">1</span>, j = n; i &lt; n; i++) &#123;</span><br><span class="line">            j = <span class="built_in">min</span>(j, height[i]);</span><br><span class="line">            lcp[sa[i]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">suf</span><span class="params">(T&amp; x, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; x.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; x[p++] &lt;&lt; <span class="string">&quot;,&quot;</span>[p == x.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// string s = &quot;aabaaaab&quot;;</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    SuffixArray&lt;vector&lt;<span class="type">int</span>&gt;, <span class="number">8</span>&gt; <span class="built_in">SA</span>(s);</span><br><span class="line">    SA.<span class="built_in">getHeight</span>();</span><br><span class="line">    <span class="keyword">auto</span> sa = SA.sa, rank = SA.rk, height = SA.height;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sa&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;排名:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 后缀:&quot;</span> &lt;&lt; sa[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">suf</span>(s, sa[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rank&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;排名:&quot;</span> &lt;&lt; rank[i] &lt;&lt; <span class="string">&quot; 后缀 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">suf</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;height&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;后缀&quot;</span> &lt;&lt; sa[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;与&quot;</span> &lt;&lt; sa[i] &lt;&lt; <span class="string">&quot; lcp:&quot;</span> &lt;&lt; height[i]</span><br><span class="line">             &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lcp for suffix 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> lcp = SA.<span class="built_in">getLcp</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;后缀:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; lcp:&quot;</span> &lt;&lt; lcp[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lcp for suffix 3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    lcp = SA.<span class="built_in">getLcp</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;后缀:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; lcp:&quot;</span> &lt;&lt; lcp[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lcp for suffix 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    lcp = SA.<span class="built_in">getLcp</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;后缀:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; lcp:&quot;</span> &lt;&lt; lcp[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sa</span></span><br><span class="line"><span class="comment">排名:0 后缀:3 [1,1,1,1,2]</span></span><br><span class="line"><span class="comment">排名:1 后缀:4 [1,1,1,2]</span></span><br><span class="line"><span class="comment">排名:2 后缀:5 [1,1,2]</span></span><br><span class="line"><span class="comment">排名:3 后缀:0 [1,1,2,1,1,1,1,2]</span></span><br><span class="line"><span class="comment">排名:4 后缀:6 [1,2]</span></span><br><span class="line"><span class="comment">排名:5 后缀:1 [1,2,1,1,1,1,2]</span></span><br><span class="line"><span class="comment">排名:6 后缀:7 [2]</span></span><br><span class="line"><span class="comment">排名:7 后缀:2 [2,1,1,1,1,2]</span></span><br><span class="line"><span class="comment">rank</span></span><br><span class="line"><span class="comment">排名:3 后缀 0 [1,1,2,1,1,1,1,2]</span></span><br><span class="line"><span class="comment">排名:5 后缀 1 [1,2,1,1,1,1,2]</span></span><br><span class="line"><span class="comment">排名:7 后缀 2 [2,1,1,1,1,2]</span></span><br><span class="line"><span class="comment">排名:0 后缀 3 [1,1,1,1,2]</span></span><br><span class="line"><span class="comment">排名:1 后缀 4 [1,1,1,2]</span></span><br><span class="line"><span class="comment">排名:2 后缀 5 [1,1,2]</span></span><br><span class="line"><span class="comment">排名:4 后缀 6 [1,2]</span></span><br><span class="line"><span class="comment">排名:6 后缀 7 [2]</span></span><br><span class="line"><span class="comment">height</span></span><br><span class="line"><span class="comment">后缀3与4 lcp:3</span></span><br><span class="line"><span class="comment">后缀4与5 lcp:2</span></span><br><span class="line"><span class="comment">后缀5与0 lcp:3</span></span><br><span class="line"><span class="comment">后缀0与6 lcp:1</span></span><br><span class="line"><span class="comment">后缀6与1 lcp:2</span></span><br><span class="line"><span class="comment">后缀1与7 lcp:0</span></span><br><span class="line"><span class="comment">后缀7与2 lcp:1</span></span><br><span class="line"><span class="comment">lcp for suffix 0</span></span><br><span class="line"><span class="comment">后缀:0 lcp:8</span></span><br><span class="line"><span class="comment">后缀:1 lcp:1</span></span><br><span class="line"><span class="comment">后缀:2 lcp:0</span></span><br><span class="line"><span class="comment">后缀:3 lcp:2</span></span><br><span class="line"><span class="comment">后缀:4 lcp:2</span></span><br><span class="line"><span class="comment">后缀:5 lcp:3</span></span><br><span class="line"><span class="comment">后缀:6 lcp:1</span></span><br><span class="line"><span class="comment">后缀:7 lcp:0</span></span><br><span class="line"><span class="comment">lcp for suffix 3</span></span><br><span class="line"><span class="comment">后缀:0 lcp:2</span></span><br><span class="line"><span class="comment">后缀:1 lcp:1</span></span><br><span class="line"><span class="comment">后缀:2 lcp:0</span></span><br><span class="line"><span class="comment">后缀:3 lcp:8</span></span><br><span class="line"><span class="comment">后缀:4 lcp:3</span></span><br><span class="line"><span class="comment">后缀:5 lcp:2</span></span><br><span class="line"><span class="comment">后缀:6 lcp:1</span></span><br><span class="line"><span class="comment">后缀:7 lcp:0</span></span><br><span class="line"><span class="comment">lcp for suffix 2</span></span><br><span class="line"><span class="comment">后缀:0 lcp:0</span></span><br><span class="line"><span class="comment">后缀:1 lcp:0</span></span><br><span class="line"><span class="comment">后缀:2 lcp:8</span></span><br><span class="line"><span class="comment">后缀:3 lcp:0</span></span><br><span class="line"><span class="comment">后缀:4 lcp:0</span></span><br><span class="line"><span class="comment">后缀:5 lcp:0</span></span><br><span class="line"><span class="comment">后缀:6 lcp:0</span></span><br><span class="line"><span class="comment">后缀:7 lcp:1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>不太好用的模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortCharacters</span><span class="params">(<span class="type">const</span> string &amp; text)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">128</span>)</span>, <span class="title">order</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : text) &#123;</span><br><span class="line">        count[c]++;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        count[text[i]]--;</span><br><span class="line">        order[count[text[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">computeCharClasses</span><span class="params">(<span class="type">const</span> string &amp; text, vector&lt;<span class="type">int</span>&gt; &amp; order)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    res[order[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (text[order[i]] != text[order[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">            res[order[i]] = res[order[i - <span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[order[i]] = res[order[i - <span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortDoubled</span><span class="params">(<span class="type">const</span> string &amp; text, <span class="type">int</span> len, vector&lt;<span class="type">int</span>&gt; &amp; order, vector&lt;<span class="type">int</span>&gt; &amp; classfiy)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(n)</span>, <span class="title">newOrder</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count[classfiy[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> start = (order[i] - len + n) % n;</span><br><span class="line">        <span class="type">int</span> cl = classfiy[start];</span><br><span class="line">        count[cl]--;</span><br><span class="line">        newOrder[count[cl]] = start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newOrder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">updateClasses</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; newOrder, vector&lt;<span class="type">int</span>&gt; &amp; classfiy, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = newOrder.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newClassfiy</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    newClassfiy[newOrder[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> curr = newOrder[i];</span><br><span class="line">        <span class="type">int</span> prev = newOrder[i - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> mid = curr + len;</span><br><span class="line">        <span class="type">int</span> midPrev = (prev + len) % n;</span><br><span class="line">        <span class="keyword">if</span> (classfiy[curr] != classfiy[prev] || classfiy[mid] != classfiy[midPrev]) &#123;</span><br><span class="line">             newClassfiy[curr] = newClassfiy[prev] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             newClassfiy[curr] = newClassfiy[prev];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newClassfiy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sa[i]表示将所有后缀排序后第i小的后缀的编号</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buildSuffixArray</span><span class="params">(<span class="type">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; order = <span class="built_in">sortCharacters</span>(text);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; classfiy = <span class="built_in">computeCharClasses</span>(text, order);</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        order = <span class="built_in">sortDoubled</span>(text, i, order, classfiy);</span><br><span class="line">        classfiy = <span class="built_in">updateClasses</span>(order, classfiy, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rank[i]表示后缀i的排名。 sa[rank[i]] = rank[sa[i]] = i;</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buildRank</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; sa)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rank</span><span class="params">(sa.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sa.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        rank[sa[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rank;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// height[i] = lcp(sa[i-1], sa[i])</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buildHeight</span><span class="params">(<span class="type">const</span> string&amp; text, vector&lt;<span class="type">int</span>&gt;&amp; sa, vector&lt;<span class="type">int</span>&gt;&amp; rank)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = sa.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">height</span><span class="params">(n)</span></span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, k=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&gt;<span class="number">0</span>) k--;</span><br><span class="line">        <span class="type">int</span> j = sa[rank[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span> (text[i+k] == text[j+k]) k++;</span><br><span class="line">        height[rank[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;aabaaaab*&quot;</span>;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">auto</span> sa = <span class="built_in">buildSuffixArray</span>(s);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sa&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;后缀&quot;</span> &lt;&lt; sa[i] &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; s.<span class="built_in">substr</span>(sa[i]) &lt;&lt; <span class="string">&quot; 排名:&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> rank = <span class="built_in">buildRank</span>(sa);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rank&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;后缀&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; s.<span class="built_in">substr</span>(i) &lt;&lt; <span class="string">&quot; 排名:&quot;</span> &lt;&lt; rank[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> height = <span class="built_in">buildHeight</span>(s, sa, rank);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;height&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;后缀&quot;</span> &lt;&lt; (sa[i<span class="number">-1</span>]) &lt;&lt; <span class="string">&quot;与&quot;</span> &lt;&lt; sa[i] &lt;&lt; <span class="string">&quot; lcp:&quot;</span>&lt;&lt; height[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sa</span></span><br><span class="line"><span class="comment">后缀8: * 排名:0</span></span><br><span class="line"><span class="comment">后缀3: aaaab* 排名:1</span></span><br><span class="line"><span class="comment">后缀4: aaab* 排名:2</span></span><br><span class="line"><span class="comment">后缀5: aab* 排名:3</span></span><br><span class="line"><span class="comment">后缀0: aabaaaab* 排名:4</span></span><br><span class="line"><span class="comment">后缀6: ab* 排名:5</span></span><br><span class="line"><span class="comment">后缀1: abaaaab* 排名:6</span></span><br><span class="line"><span class="comment">后缀7: b* 排名:7</span></span><br><span class="line"><span class="comment">后缀2: baaaab* 排名:8</span></span><br><span class="line"><span class="comment">rank</span></span><br><span class="line"><span class="comment">后缀0: aabaaaab* 排名:4</span></span><br><span class="line"><span class="comment">后缀1: abaaaab* 排名:6</span></span><br><span class="line"><span class="comment">后缀2: baaaab* 排名:8</span></span><br><span class="line"><span class="comment">后缀3: aaaab* 排名:1</span></span><br><span class="line"><span class="comment">后缀4: aaab* 排名:2</span></span><br><span class="line"><span class="comment">后缀5: aab* 排名:3</span></span><br><span class="line"><span class="comment">后缀6: ab* 排名:5</span></span><br><span class="line"><span class="comment">后缀7: b* 排名:7</span></span><br><span class="line"><span class="comment">后缀8: * 排名:0</span></span><br><span class="line"><span class="comment">height</span></span><br><span class="line"><span class="comment">后缀8与3 lcp:0</span></span><br><span class="line"><span class="comment">后缀3与4 lcp:3</span></span><br><span class="line"><span class="comment">后缀4与5 lcp:2</span></span><br><span class="line"><span class="comment">后缀5与0 lcp:3</span></span><br><span class="line"><span class="comment">后缀0与6 lcp:1</span></span><br><span class="line"><span class="comment">后缀6与1 lcp:2</span></span><br><span class="line"><span class="comment">后缀1与7 lcp:0</span></span><br><span class="line"><span class="comment">后缀7与2 lcp:1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>字符串末尾需要添加一字符，该字符字典序小于所有字符。</p>
<p>ascii码表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dec  Char                           Dec  Char     Dec  Char     Dec  Char</span><br><span class="line">---------                           ---------     ---------     ----------</span><br><span class="line">  0  NUL (null)                      32  SPACE     64  @         96  `</span><br><span class="line">  1  SOH (start of heading)          33  !         65  A         97  a</span><br><span class="line">  2  STX (start of text)             34  &quot;         66  B         98  b</span><br><span class="line">  3  ETX (end of text)               35  #         67  C         99  c</span><br><span class="line">  4  EOT (end of transmission)       36  $         68  D        100  d</span><br><span class="line">  5  ENQ (enquiry)                   37  %         69  E        101  e</span><br><span class="line">  6  ACK (acknowledge)               38  &amp;         70  F        102  f</span><br><span class="line">  7  BEL (bell)                      39  &#x27;         71  G        103  g</span><br><span class="line">  8  BS  (backspace)                 40  (         72  H        104  h</span><br><span class="line">  9  TAB (horizontal tab)            41  )         73  I        105  i</span><br><span class="line"> 10  LF  (NL line feed, new line)    42  *         74  J        106  j</span><br><span class="line"> 11  VT  (vertical tab)              43  +         75  K        107  k</span><br><span class="line"> 12  FF  (NP form feed, new page)    44  ,         76  L        108  l</span><br><span class="line"> 13  CR  (carriage return)           45  -         77  M        109  m</span><br><span class="line"> 14  SO  (shift out)                 46  .         78  N        110  n</span><br><span class="line"> 15  SI  (shift in)                  47  /         79  O        111  o</span><br><span class="line"> 16  DLE (data link escape)          48  0         80  P        112  p</span><br><span class="line"> 17  DC1 (device control 1)          49  1         81  Q        113  q</span><br><span class="line"> 18  DC2 (device control 2)          50  2         82  R        114  r</span><br><span class="line"> 19  DC3 (device control 3)          51  3         83  S        115  s</span><br><span class="line"> 20  DC4 (device control 4)          52  4         84  T        116  t</span><br><span class="line"> 21  NAK (negative acknowledge)      53  5         85  U        117  u</span><br><span class="line"> 22  SYN (synchronous idle)          54  6         86  V        118  v</span><br><span class="line"> 23  ETB (end of trans. block)       55  7         87  W        119  w</span><br><span class="line"> 24  CAN (cancel)                    56  8         88  X        120  x</span><br><span class="line"> 25  EM  (end of medium)             57  9         89  Y        121  y</span><br><span class="line"> 26  SUB (substitute)                58  :         90  Z        122  z</span><br><span class="line"> 27  ESC (escape)                    59  ;         91  [        123  &#123;</span><br><span class="line"> 28  FS  (file separator)            60  &lt;         92  \        124  |</span><br><span class="line"> 29  GS  (group separator)           61  =         93  ]        125  &#125;</span><br><span class="line"> 30  RS  (record separator)          62  &gt;         94  ^        126  ~</span><br><span class="line"> 31  US  (unit separator)            63  ?         95  _        127  DEL</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>和至少为 K 的最短子数组</title>
    <url>/2023/04/09/%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA%20K%20%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/">862. 和至少为 K 的最短子数组</a></p>
<hr>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，找出 <code>nums</code> 中和至少为 <code>k</code> 的 <strong>最短非空子数组</strong> ，并返回该子数组的长度。如果不存在这样的 <strong>子数组</strong> ，返回 <code>-1</code> 。</p>
<p><strong>子数组</strong> 是数组中 <strong>连续</strong> 的一部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2], k = 4</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,-1,2], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li>  <code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= k &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><a href="https://leetcode.cn/problems/longest-well-performing-interval/">1124. 表现良好的最长时间段</a>求最大区间。<br>本题求最小区间。</p>
<p>同样用前缀和<code>p[i]</code>表示前i个数的和，<code>p[0] = 0, p[i] = p[i-1] + nums[i-1]</code></p>
<p>考虑区间右端点j的最优左端点i是满足<code>p[j]-k&gt;=p[i]</code>最大的i。</p>
<p>将离散化的前缀和作为树状数组的下标，前缀数组的下标作为树状数组的值，维护最大值。即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        map&lt;ll,<span class="type">int</span>&gt; id;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">p</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            p[i] = p[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            id[p[i]];</span><br><span class="line">            id[p[i]-k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i,j]:id) j = sz++;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(sz, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> ask = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="type">int</span> rt = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=x; i; i-=i&amp;-i) &#123;</span><br><span class="line">                rt = <span class="built_in">max</span>(rt, a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rt;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> x, <span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=x; i&lt;sz; i+=i&amp;-i) &#123;</span><br><span class="line">                a[i] = <span class="built_in">max</span>(a[i], val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">add</span>(id[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> ans = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="built_in">ask</span>(id[p[i]-k]);</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">-1</span>) ans = <span class="built_in">min</span>(ans, i-j);</span><br><span class="line">            <span class="built_in">add</span>(id[p[i]], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans==n+<span class="number">1</span>?<span class="number">-1</span>:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>单调队列</p>
<p>设$s_i$是<code>s[0...i]</code>的和。</p>
<p>我们需要对每个<code>i</code>找到最大的j使得$s_i-s_j\ge k$，然后维护最小的<code>i-j</code>作为答案。</p>
<p>对于前缀和的选择，肯定需要选择较长的且值较小的。</p>
<p>那么不大于前缀和$s_i$的$s_j, j &lt; i$ 可以直接排除。这类似于一个递增单调栈，接下来需要在这个有序的栈内找到最大的<code>j</code>使得$s_j \le s_i-k$, 理论上每次可以用二分法找到这个$s_j$, 但是此后的$s_j’$一定不会比$s_j$小，所以可以用滑动窗口移除满足$s_j \le s_i-k$的$s_j$并维护最小的<code>i-j</code>.</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;pair&lt;<span class="type">long</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace_back</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), ans = n+<span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            p += nums[i];</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">back</span>().first&gt;=p) q.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">emplace_back</span>(p, i);</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">front</span>().first + k &lt;= p) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, i-q.<span class="built_in">front</span>().second);</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans==n+<span class="number">1</span>?<span class="number">-1</span>:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈队列堆</tag>
      </tags>
  </entry>
  <entry>
    <title>圆形靶内的最大飞镖数量</title>
    <url>/2023/04/09/%E5%9C%86%E5%BD%A2%E9%9D%B6%E5%86%85%E7%9A%84%E6%9C%80%E5%A4%A7%E9%A3%9E%E9%95%96%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/">1453. 圆形靶内的最大飞镖数量</a></p>
<hr>
<p>墙壁上挂着一个圆形的飞镖靶。现在请你蒙着眼睛向靶上投掷飞镖。</p>
<p>投掷到墙上的飞镖用二维平面上的点坐标数组表示。飞镖靶的半径为 <code>r</code> 。</p>
<p>请返回能够落在 <strong>任意</strong> 半径为 <code>r</code> 的圆形靶内或靶上的最大飞镖数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/sample_1_1806.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：points = [[-2,0],[2,0],[0,2],[0,-2]], r = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：如果圆形的飞镖靶的圆心为 (0,0) ，半径为 2 ，所有的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/sample_2_1806.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：points = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5</span><br><span class="line">输出：5</span><br><span class="line">解释：如果圆形的飞镖靶的圆心为 (0,4) ，半径为 5 ，则除了 (7,8) 之外的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 5 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：points = [[-2,0],[2,0],[0,2],[0,-2]], r = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：points = [[1,2],[3,5],[1,-1],[2,3],[4,1],[1,3]], r = 2</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= points.length &lt;= 100</code></li>
<li>  <code>points[i].length == 2</code></li>
<li>  <code>-10^4 &lt;= points[i][0], points[i][1] &lt;= 10^4</code></li>
<li><code>1 &lt;= r &lt;= 5000</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>枚举两个点在半径为r的圆上，求出圆心，然后统计每个点是否在圆内或圆上数目，维护一个最大值。时间复杂度O(n^3)</p>
<p>如何求圆心</p>
<p>设枚举的两个点为$A=(x_1, y_1), B=(x_2, y_2)$，两点的中点为$M = (\frac{x_1+x_2}{2}, \frac{y_1+y_2}{2})$，圆心为$O=(x_0, y_0)$，$\vec{AM} = (\frac{x_2-x_1}{2}, \frac{y_2-y_1}{2})$，显然$\vec{AM} \cdot \vec{MO} = 0$，由此可以求出$\vec{MO} =  (-\frac{y_2-y_1}{2}, \frac{2_2-2_1}{2}) \frac{|\vec{MO}|}{|\vec{AM}|}$，M已知可求出O</p>
<p>如何判断点没有在圆外</p>
<p>由于圆心可能是浮点数，如果点到圆心的距离大于半径，但是大的距离非常小可以认为是在点上。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">    <span class="function">ll <span class="title">qdis</span><span class="params">(ll x1, ll y1, ll x2, ll y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">isle</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;=y || x&gt;y&amp;&amp;x-y&lt;=<span class="number">1e-9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; darts, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = darts.<span class="built_in">size</span>(), ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                ll x1 = darts[i][<span class="number">0</span>], y1 = darts[i][<span class="number">1</span>], x2 = darts[j][<span class="number">0</span>], y2 = darts[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">qdis</span>(x1, y1, x2, y2) &gt; <span class="number">4</span>*r*r) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">double</span> x = (x2-x1)/<span class="number">2.0</span>, y = (y2-y1)/<span class="number">2.0</span>;</span><br><span class="line">                <span class="type">double</span> m = <span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">                <span class="type">double</span> len = <span class="built_in">sqrt</span>(r*r-x*x-y*y)/m;</span><br><span class="line">                <span class="type">double</span> x0 = x+x1-y*len, y0 = y+y1+x*len;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; x0 &lt;&lt; &quot; &quot; &lt;&lt; y0 &lt;&lt; endl;</span></span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; k:darts) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isle</span>((k[<span class="number">0</span>]-x0)*(k[<span class="number">0</span>]-x0) + (k[<span class="number">1</span>]-y0)*(k[<span class="number">1</span>]-y0), r*r)) cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>在线选举</title>
    <url>/2023/04/09/%E5%9C%A8%E7%BA%BF%E9%80%89%E4%B8%BE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/online-election/">911. 在线选举</a></p>
<hr>
<p>给你两个整数数组 <code>persons</code> 和 <code>times</code> 。在选举中，第 <code>i</code> 张票是在时刻为 <code>times[i]</code> 时投给候选人 <code>persons[i]</code> 的。</p>
<p>对于发生在时刻 <code>t</code> 的每个查询，需要找出在 <code>t</code> 时刻在选举中领先的候选人的编号。</p>
<p>在 <code>t</code> 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。</p>
<p>实现 <code>TopVotedCandidate</code> 类：</p>
<ul>
<li>  <code>TopVotedCandidate(int[] persons, int[] times)</code> 使用 <code>persons</code> 和 <code>times</code> 数组初始化对象。</li>
<li>  <code>int q(int t)</code> 根据前面描述的规则，返回在时刻 <code>t</code> 在选举中领先的候选人的编号。</li>
</ul>
<p> </p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;TopVotedCandidate&quot;, &quot;q&quot;, &quot;q&quot;, &quot;q&quot;, &quot;q&quot;, &quot;q&quot;, &quot;q&quot;]</span><br><span class="line">[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]</span><br><span class="line">输出：</span><br><span class="line">[null, 0, 1, 1, 0, 0, 1]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">TopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);</span><br><span class="line">topVotedCandidate.q(3); // 返回 0 ，在时刻 3 ，票数分布为 [0] ，编号为 0 的候选人领先。</span><br><span class="line">topVotedCandidate.q(12); // 返回 1 ，在时刻 12 ，票数分布为 [0,1,1] ，编号为 1 的候选人领先。</span><br><span class="line">topVotedCandidate.q(25); // 返回 1 ，在时刻 25 ，票数分布为 [0,1,1,0,0,1] ，编号为 1 的候选人领先。（在平局的情况下，1 是最近获得投票的候选人）。</span><br><span class="line">topVotedCandidate.q(15); // 返回 0</span><br><span class="line">topVotedCandidate.q(24); // 返回 0</span><br><span class="line">topVotedCandidate.q(8); // 返回 1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= persons.length &lt;= 5000</code></li>
<li>  <code>times.length == persons.length</code></li>
<li>  <code>0 &lt;= persons[i] &lt; persons.length</code></li>
<li>  <code>0 &lt;= times[i] &lt;= 10^9</code></li>
<li>  <code>times</code> 是一个严格递增的有序数组</li>
<li>  <code>times[0] &lt;= t &lt;= 10^9</code></li>
<li>每个测试用例最多调用 <code>10^4</code> 次 <code>q</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>预处理每个投票时刻的胜出者。<br>对于查询时刻t的胜出者，只需二分找到最后一个小于等于t的投票时刻对应的胜出者即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TopVotedCandidate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">5005</span>], mxp = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; tm;</span><br><span class="line">    <span class="built_in">TopVotedCandidate</span>(vector&lt;<span class="type">int</span>&gt;&amp; persons, vector&lt;<span class="type">int</span>&gt;&amp; times) &#123;</span><br><span class="line">        <span class="type">int</span> n = persons.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            cnt[persons[i]]++;</span><br><span class="line">            <span class="keyword">if</span> (cnt[mxp] &lt;= cnt[persons[i]]) mxp = persons[i];</span><br><span class="line">            tm[times[i]] = mxp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">q</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (--tm.<span class="built_in">upper_bound</span>(t))-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TopVotedCandidate object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TopVotedCandidate* obj = new TopVotedCandidate(persons, times);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;q(t);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>在网格图中访问一个格子的最少时间</title>
    <url>/2023/04/09/%E5%9C%A8%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E6%A0%BC%E5%AD%90%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/">6366. 在网格图中访问一个格子的最少时间</a></p>
<hr>
<p>给你一个 <code>m x n</code> 的矩阵 <code>grid</code> ，每个元素都为 <strong>非负</strong> 整数，其中 <code>grid[row][col]</code> 表示可以访问格子 <code>(row, col)</code> 的 <strong>最早</strong> 时间。也就是说当你访问格子 <code>(row, col)</code> 时，最少已经经过的时间为 <code>grid[row][col]</code> 。</p>
<p>你从 <strong>最左上角</strong> 出发，出发时刻为 <code>0</code> ，你必须一直移动到上下左右相邻四个格子中的 <strong>任意</strong> 一个格子（即不能停留在格子上）。每次移动都需要花费 1 单位时间。</p>
<p>请你返回 <strong>最早</strong> 到达右下角格子的时间，如果你无法到达右下角的格子，请你返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]</span><br><span class="line">输出：7</span><br><span class="line">解释：一条可行的路径为：</span><br><span class="line">- 时刻 t = 0 ，我们在格子 (0,0) 。</span><br><span class="line">- 时刻 t = 1 ，我们移动到格子 (0,1) ，可以移动的原因是 grid[0][1] &lt;= 1 。</span><br><span class="line">- 时刻 t = 2 ，我们移动到格子 (1,1) ，可以移动的原因是 grid[1][1] &lt;= 2 。</span><br><span class="line">- 时刻 t = 3 ，我们移动到格子 (1,2) ，可以移动的原因是 grid[1][2] &lt;= 3 。</span><br><span class="line">- 时刻 t = 4 ，我们移动到格子 (1,1) ，可以移动的原因是 grid[1][1] &lt;= 4 。</span><br><span class="line">- 时刻 t = 5 ，我们移动到格子 (1,2) ，可以移动的原因是 grid[1][2] &lt;= 5 。</span><br><span class="line">- 时刻 t = 6 ，我们移动到格子 (1,3) ，可以移动的原因是 grid[1][3] &lt;= 6 。</span><br><span class="line">- 时刻 t = 7 ，我们移动到格子 (2,3) ，可以移动的原因是 grid[2][3] &lt;= 7 。</span><br><span class="line">最终到达时刻为 7 。这是最早可以到达的时间。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,2,4],[3,2,1],[1,0,4]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：没法从左上角按题目规定走到右下角。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>m == grid.length</code></li>
<li>  <code>n == grid[i].length</code></li>
<li>  <code>2 &lt;= m, n &lt;= 1000</code></li>
<li>  <code>4 &lt;= m * n &lt;= 10^5</code></li>
<li>  <code>0 &lt;= grid[i][j] &lt;= 10^5</code></li>
<li><code>grid[0][0] == 0</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>最短路径问题</p>
<p>我们可以认为从一个格子走向另一个格子所花的时间不同。</p>
<p>如果走到当前格子最短的时间为t，需要前往的目标格子最早时间为x。</p>
<p>如果说<code>t+1&gt;=x</code>则需要时间为1，否则由于不能一直待在同一个格子，所以需要在已走的格子间来回移动。</p>
<p>当再次来到当前格子时，所花的时间为<code>t+2*k, k&gt;=0</code>。</p>
<p>所以满足<code>t+2*k+1&gt;=x</code>才能移动，可求出最小的<code>k=ceil((x-t-1)/2)</code></p>
<p>可以认为这是一个有权图，求最短路径即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="type">int</span> s;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node&amp; o) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s &gt; o.s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y),<span class="built_in">s</span>(s)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTime</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (g[<span class="number">0</span>][<span class="number">1</span>]&gt;<span class="number">1</span> &amp;&amp; g[<span class="number">1</span>][<span class="number">0</span>]&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> n = g.<span class="built_in">size</span>(), m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">stp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, INF));</span><br><span class="line">        stp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;Node&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> x = u.x, y = u.y, s = u.s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> mx = x+(i<span class="number">-1</span>)%<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> my = y+(i<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (mx&lt;<span class="number">0</span> || mx&gt;=n || my&lt;<span class="number">0</span> || my&gt;=m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> k = <span class="built_in">max</span>(<span class="number">0</span>, (g[mx][my]-stp[x][y])/<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (stp[mx][my] &gt; stp[x][y]+k*<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">                    stp[mx][my] = stp[x][y]+k*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(mx, my, stp[mx][my]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stp[n<span class="number">-1</span>][m<span class="number">-1</span>] == INF ? <span class="number">-1</span> : stp[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>多边形三角剖分的最低得分</title>
    <url>/2023/04/09/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/">1039. 多边形三角剖分的最低得分</a></p>
<hr>
<p>你有一个凸的 <code>n</code> 边形，其每个顶点都有一个整数值。给定一个整数数组 <code>values</code> ，其中 <code>values[i]</code> 是第 <code>i</code> 个顶点的值（即 <strong>顺时针顺序</strong> ）。</p>
<p>假设将多边形 <strong>剖分</strong> 为 <code>n - 2</code> 个三角形。对于每个三角形，该三角形的值是顶点标记的<strong>乘积</strong>，三角剖分的分数是进行三角剖分后所有 <code>n - 2</code> 个三角形的值之和。</p>
<p>返回 <em>多边形进行三角剖分后可以得到的最低分</em> 。  
 </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/25/shape1.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：values = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：多边形已经三角化，唯一三角形的分数为 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/25/shape2.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：values = [3,7,4,5]</span><br><span class="line">输出：144</span><br><span class="line">解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/25/shape3.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：values = [1,3,1,4,1,5]</span><br><span class="line">输出：13</span><br><span class="line">解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>n == values.length</code></li>
<li>  <code>3 &lt;= n &lt;= 50</code></li>
<li><code>1 &lt;= values[i] &lt;= 100</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>容易想到拆分多边形成为更小的多边形，答案是所有拆分方式中的分数的最小值。</p>
<p>拆分的方法也有很多，比如对于当前多边形，找任意两个不相邻的点然后拆分成两个多边形，这两个子多边形的贡献之和作为当前拆分的分数，对于所有拆分方式中最小的分数作为当前多边形的答案。当在拆分成三角形时就不能再拆分了（递归时的终止条件）。<br>但是这样的的拆分方式并不好实现且不高效，拆分出的多边形的点不是连续的，比如<code>1 2 3 4 5</code>拆成了<code>2 3 4</code>和<code>4 5 1 2</code>。我们需要知道当前多边形所选的点，也就是一个集合作为状态的存储的数据结构。实现起来比较麻烦且状态数是n个数的子集，高达$2^n$。</p>
<p>现在试想一种拆分方式，对于连续的l到r的点形成的多边形形成的最小分数，记为$f_{l,r}$，最后拆分后l和r一定会与i（l&lt;i&lt;r）形成一个三角形，所以问题转为了求$f_{l,i}+f_{i,r}+values[l]*values[i]*values[r]$的最小值</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minScoreTriangulation(self, values: List[int]) -&gt; int:</span><br><span class="line">        n = len(values)</span><br><span class="line">        @cache</span><br><span class="line">        def dfs(l, r):</span><br><span class="line">            if l+1==r: return 0</span><br><span class="line">            return min(values[l]*values[r]*values[i]+dfs(l,i)+dfs(i,r) for i in range(l+1, r))</span><br><span class="line">        return dfs(0, n-1)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title>大小为 K 的不重叠线段的数目</title>
    <url>/2023/04/09/%E5%A4%A7%E5%B0%8F%E4%B8%BA%20K%20%E7%9A%84%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/number-of-sets-of-k-non-overlapping-line-segments/">1621. 大小为 K 的不重叠线段的数目</a></p>
<hr>
<p>给你一维空间的 <code>n</code> 个点，其中第 <code>i</code> 个点（编号从 <code>0</code> 到 <code>n-1</code>）位于 <code>x = i</code> 处，请你找到 <strong>恰好</strong> <code>k</code> <strong>个不重叠</strong> 线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是 <strong>整数坐标</strong> 。这 <code>k</code> 个线段不需要全部覆盖全部 <code>n</code> 个点，且它们的端点 <strong>可以</strong> 重合。</p>
<p>请你返回 <code>k</code> 个不重叠线段的方案数。由于答案可能很大，请将结果对 <code>10^9 + 7</code> <strong>取余</strong> 后返回。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/17/ex1.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">如图所示，两个线段分别用红色和蓝色标出。</span><br><span class="line">上图展示了 5 种不同的方案 &#123;(0,2),(2,3)&#125;，&#123;(0,1),(1,3)&#125;，&#123;(0,1),(2,3)&#125;，&#123;(1,2),(2,3)&#125;，&#123;(0,1),(1,2)&#125; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 3, k = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：总共有 3 种不同的方案 &#123;(0,1)&#125;, &#123;(0,2)&#125;, &#123;(1,2)&#125; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 30, k = 7</span><br><span class="line">输出：796297179</span><br><span class="line">解释：画 7 条线段的总方案数为 3796297200 种。将这个数对 109 + 7 取余得到 796297179 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 5, k = 3</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 3, k = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>2 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= k &lt;= n-1</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>组合数$C_{n+k-1}^{2k}$，在除法时模mod需要求逆元</p>
<p>由于选取k条线段不覆盖，但是相邻线段共用一个端点，处理起来比较麻烦。</p>
<p>如果是选取k条线段不覆盖且相邻线段不能共用一个端点。那么答案就是在n个点里选2k个点的选取方式，即$C_{n}^{2 * k}$。</p>
<p>现在首位可以相接。最多有k-1个相交点，可以增加k-1个节点，问题转化为在n+k-1个节点中选取k条首位不相接线段。为什么可以转化？</p>
<p>令第$i$个根线段的左端为$l_i$，右端为$r_i$</p>
<p>于是有$0 \le l_1&lt;r_1 \le l_2&lt;r_2 \le \cdots \le l_k &lt; r_k &lt; n$</p>
<p>令$l_i’=l_i+(i-1), r_i’=r_i+(i-1)$</p>
<p>此时$0 \le l_1’&lt;r_1’ &lt; l_2’&lt;r_2’ &lt; \cdots &lt; l_k’ &lt; r_k’&lt; n+k-1$。</p>
<p>此时可以用n+k-1中选取2k个数作为答案。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="type">const</span> ll MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123; <span class="comment">//n个里选m个</span></span><br><span class="line">        ll inv[n+<span class="number">1</span>];</span><br><span class="line">        inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">                inv[i] = (MOD-MOD/i)*inv[MOD%i]%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        ll rt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=m; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">            rt = rt*(n-i+<span class="number">1</span>)%MOD*inv[i]%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSets</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">C</span>(n+k<span class="number">-1</span>, <span class="number">2</span>*k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>定义状态<code>dp[i][j][0]</code>为前i个线放在0…j个点且第i条线右端不在j上。</p>
<p>定义状态<code>dp[i][j][1]</code>为前i个线放在0…j个点且第i条线右端在j上。</p>
<p>状态转移</p>
<p>考虑第i条线段如果右端不在j上，可认为是0…j-1上分配j个点，那么<code>dp[i][j][0] = dp[i][j-1][0]+dp[i][j-1][1]</code><br>第i条线段如果右端在j上，有分两种情况讨论：</p>
<ul>
<li>如果第i条线长度是1，那么可认为是0…j-1分配i-1个点，即<code>dp[i-1][j-1][0]+dp[i-1][j-1][1]</code></li>
<li>如果第i条线长度超过1，那么将第i条线从右端长度为1的地方分为两段。仍然可以认为前面0…j-1上分配i条线且右端一定在j-1上。即<code>dp[i][j-1][1]</code><br>所以<code>dp[i][j][1] = dp[i-1][j-1][0]+dp[i-1][j-1][1]+dp[i][j-1][1]</code></li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">long</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="type">long</span> dp[<span class="number">1005</span>][<span class="number">1005</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSets</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=k; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = dp[i][j<span class="number">-1</span>][<span class="number">0</span>] + dp[i][j<span class="number">-1</span>][<span class="number">1</span>];<span class="comment">//第i条线不在j上</span></span><br><span class="line">                dp[i][j][<span class="number">0</span>] %= MOD;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = (i&gt;<span class="number">0</span>?dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>]:<span class="number">0</span>) + dp[i][j<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">                dp[i][j][<span class="number">1</span>] %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dp[k][n<span class="number">-1</span>][<span class="number">0</span>]+dp[k][n<span class="number">-1</span>][<span class="number">1</span>])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>好分区的数目</title>
    <url>/2023/04/09/%E5%A5%BD%E5%88%86%E5%8C%BA%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/number-of-great-partitions/">2518. 好分区的数目</a></p>
<hr>
<p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>
<p><strong>分区</strong> 的定义是：将数组划分成两个有序的 <strong>组</strong> ，并满足每个元素 <strong>恰好</strong> 存在于 <strong>某一个</strong> 组中。如果分区中每个组的元素和都大于等于 <code>k</code> ，则认为分区是一个好分区。</p>
<p>返回 <strong>不同</strong> 的好分区的数目。由于答案可能很大，请返回对 <code>10^9 + 7</code> <strong>取余</strong> 后的结果。</p>
<p>如果在两个分区中，存在某个元素 <code>nums[i]</code> 被分在不同的组中，则认为这两个分区不同。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4], k = 4</span><br><span class="line">输出：6</span><br><span class="line">解释：好分区的情况是 ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) 和 ([4], [1,2,3]) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3,3], k = 4</span><br><span class="line">输出：0</span><br><span class="line">解释：数组中不存在好分区。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [6,6], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：可以将 nums[0] 放入第一个分区或第二个分区中。</span><br><span class="line">好分区的情况是 ([6], [6]) 和 ([6], [6]) 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length, k &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对于每个数<code>nums[i]</code>，我们有选与不选两种选择，对于选择的数可以放到第一个分区中，剩余的数放到第二个分区中，想到背包问题。<br>考虑到每个<code>nums[i]</code>的数值范围很大，我们可以考虑所有不合法的分法，然后让总的$2^n$种方案减去不合法的方案数就可以得到答案。</p>
<p>下面考虑不合法的方案，设分好后第一个分区的总和为a，第二个分区的总和为b。</p>
<p>不合法的分法有三类：</p>
<ol>
<li>a &lt; k 且 b &lt; k</li>
<li>a &lt; k 且 b &gt;= k</li>
<li>a &gt;= k 且 b &lt; k</li>
</ol>
<p>可以事先排除第1种情况，第1种情况没有可行的方案数。直接得到答案0</p>
<p>接下来可以用01背包计数</p>
<p>设<code>dp[i][j]</code>为前i个数中选取一些后，和为j的方案数。</p>
<p>初始化<code>dp[0][0] = 1</code>。</p>
<p>若不选第i个数，则有贡献<code>dp[i-1][j]</code></p>
<p>若选第i个数，则有贡献<code>dp[i-1][j-nums[i-1]]</code></p>
<p>因此状态转移为<code>dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]]</code></p>
<p>对于第二种不合法情况有$bad = \sum \limits_{i=0}^{k-1} dp[n][i]$种，而第三种情况和第二种情况具有对称性，因此也为bad种。</p>
<p>所以合法的方案数为$2^n-2*bad$种。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="type">const</span> ll M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function">ll <span class="title">fpow</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">        ll rt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p&amp;<span class="number">1</span>) rt = rt*x%M;</span><br><span class="line">            x = x*x%M;</span><br><span class="line">            p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    ll dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPartitions</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0LL</span>) &lt; <span class="number">2</span>*k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;k; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j&gt;=nums[i<span class="number">-1</span>]) dp[i][j] = (dp[i][j]+dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]])%M;</span><br><span class="line">                <span class="comment">// printf(&quot;%d,%d=%d\n&quot;,i,j,dp[i][j]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll bad = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++) bad = (bad+dp[n][i])%M;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">fpow</span>(<span class="number">2</span>, n)<span class="number">-2</span>*bad+M)%M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>背包dp</tag>
      </tags>
  </entry>
  <entry>
    <title>子数组中占绝大多数的元素</title>
    <url>/2023/04/09/%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8D%A0%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/online-majority-element-in-subarray/">1157. 子数组中占绝大多数的元素</a></p>
<hr>
<p>设计一个数据结构，有效地找到给定子数组的 <strong>多数元素</strong> 。</p>
<p>子数组的 <strong>多数元素</strong> 是在子数组中出现 <code>threshold</code> 次数或次数以上的元素。</p>
<p>实现 <code>MajorityChecker</code> 类:</p>
<ul>
<li>  <code>MajorityChecker(int[] arr)</code> 会用给定的数组 <code>arr</code> 对 <code>MajorityChecker</code> 初始化。</li>
<li><code>int query(int left, int right, int threshold)</code> 返回子数组中的元素  <code>arr[left...right]</code> 至少出现 <code>threshold</code> 次数，如果不存在这样的元素则返回 <code>-1</code>。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[&quot;MajorityChecker&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;]</span><br><span class="line">[[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, -1, 2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);</span><br><span class="line">majorityChecker.query(0,5,4); // 返回 1</span><br><span class="line">majorityChecker.query(0,3,3); // 返回 -1</span><br><span class="line">majorityChecker.query(2,3,2); // 返回 2</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= arr.length &lt;= 2 * 10^4</code></li>
<li>  <code>1 &lt;= arr[i] &lt;= 2 * 10^4</code></li>
<li>  <code>0 &lt;= left &lt;= right &lt; arr.length</code></li>
<li>  <code>threshold &lt;= right - left + 1</code></li>
<li>  <code>2 * threshold &gt; right - left + 1</code></li>
<li>调用 <code>query</code> 的次数最多为 <code>10^4</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>随机采样法</p>
<p>对于区间<code>[l,r]</code>，随机选取其中一个数，这个数如果不是<strong>多数元素</strong>，说明出现的次数小于区间大小的一半，抽到这样的元素概率是小于0.5的（threshold必定大于区间大小的一半），如果我们抽取k次，每次都保证抽到的不是<strong>多数元素</strong>的概率是小于$\frac{1}{2^k}$，可见概率是随k增长而指数下降的，k如果取30，那么抽不到多数元素的概率几乎为0。</p>
<p>查询的次数有$10^4$，我们每次查询只需要抽样30次左右，每次抽样需要确定所抽取元素是否为<strong>多数元素</strong>，常规的办法就是遍历区间统计个数。但这样会超时。</p>
<p>可以将每个元素出现的下标记录到数组，然后二分区间的端点得到区间内有多少下标。</p>
<p>本题如果可以<strong>离线</strong>的话可以用<a href="https://oi-wiki.org/misc/mo-algo/">莫队算法</a>。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MajorityChecker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mp[<span class="number">20004</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    <span class="built_in">MajorityChecker</span>(vector&lt;<span class="type">int</span>&gt;&amp; arr): <span class="built_in">arr</span>(arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            mp[arr[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> v = arr[<span class="built_in">rand</span>()%(right-left+<span class="number">1</span>)+left];</span><br><span class="line">            <span class="keyword">auto</span>&amp; a = mp[v];</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), left)-a.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), right)-a.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span> (r-l &gt;= threshold) <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MajorityChecker object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MajorityChecker* obj = new MajorityChecker(arr);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;query(left,right,threshold);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树与AC自动机</title>
    <url>/2023/06/14/%E5%AD%97%E5%85%B8%E6%A0%91%E4%B8%8EAC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="字典树和AC自动机"><a href="#字典树和AC自动机" class="headerlink" title="字典树和AC自动机"></a>字典树和AC自动机</h1><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>Trie树，又叫字典树、前缀树（Prefix Tree）、单词查找树 或 键树，是一种多叉树结构。</p>
<p><img src="https://cdnjson.com/images/2023/06/14/1115_1.gif" alt="1115_1.gif"></p>
<p>此图是一棵Trie树，表示了关键字集合{“hers”, “his”, “she”, “i”, “he”} 。从图中可以看出：</p>
<p>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>
<p>从根节点到标记呈橙色节点路径上字符组成的字符串是一个关键字。图中橙色节点就是关键字节点。</p>
<p>有共同前缀关键字有共同路径。</p>
<h3 id="构建字典树"><a href="#构建字典树" class="headerlink" title="构建字典树"></a>构建字典树</h3><p>如果我们以英文小写字母作为字符集，那么每个节点都有26个分支子节点。由于有些节点是标志着一个插入字符串的结尾，所以需要有一个标记位判断是否是一个关键字。</p>
<p>我们定义根节点的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> isKey;   <span class="comment">// 标记该节点是否代表一个关键字</span></span><br><span class="line">    Node * children[<span class="number">26</span>]; <span class="comment">// 各个子节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>刚开始字典树是只有一个根节点的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node* root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br></pre></td></tr></table></figure>

<p>我们需要通过一条一条加入字符串构建字典树。</p>
<p>插入一条字符串的过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">    Node* t = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> s = word[i]-<span class="string">&#x27;a&#x27;</span>;<span class="comment">//得到数组下标</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;child[s] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            t-&gt;child[s] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        t = t-&gt;child[s];</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;isKey = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Trie树的应用"><a href="#Trie树的应用" class="headerlink" title="Trie树的应用"></a>Trie树的应用</h3><ol>
<li><p>字符串检索</p>
<p> 检索/查询功能是Trie树最原始的功能。思路就是从根节点开始一个一个字符进行比较：</p>
<p> 如果沿路比较，发现不存在的字符，则表示该字符串在集合中不存在。</p>
<p> 如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> isKey;   <span class="comment">// 标记该节点是否代表一个关键字</span></span><br><span class="line">    Node * children[<span class="number">26</span>]; <span class="comment">// 各个子节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>词频统计</p>
<p> Trie树常被搜索引擎系统用于文本词频统计 。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> isKey;   <span class="comment">// 标记该节点是否代表一个关键字</span></span><br><span class="line">    Node * children[<span class="number">26</span>]; <span class="comment">// 各个子节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 思路：为了实现词频统计，我们修改了节点结构，用一个整型变量count来计数。对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后count置1。</p>
</li>
<li><p>字符串排序</p>
<p> Trie树可以对大量字符串按字典序进行排序，思路也很简单：遍历一次所有关键字，将它们全部插入trie树，树的每个结点的所有儿子很显然地按照字母表排序，然后先序遍历输出Trie树中所有关键字即可。</p>
</li>
<li><p>前缀匹配</p>
<p> 例如：找出一个字符串集合中所有以ab开头的字符串。我们只需要用所有字符串构造一个trie树，然后输出以a-&gt;b-&gt;开头的路径上的关键字即可。</p>
<p> trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
</li>
<li><p>作为其他数据结构和算法的辅助结构</p>
<p> 如后缀树，AC自动机等。</p>
</li>
</ol>
<h3 id="字典树代码实现"><a href="#字典树代码实现" class="headerlink" title="字典树代码实现"></a>字典树代码实现</h3><p>字符串检索的Trie树代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">bool</span> isKey;<span class="comment">//是否当前节点作为一个单词的结尾</span></span><br><span class="line">        Node* child[<span class="number">26</span>];<span class="comment">//a-z</span></span><br><span class="line">    &#125; *head;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* t = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> s = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;child[s] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                t-&gt;child[s] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            t = t-&gt;child[s];</span><br><span class="line">        &#125;</span><br><span class="line">        t-&gt;isKey = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* t = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> s = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;child[s] == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            t = t-&gt;child[s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t-&gt;isKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Node* t = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;prefix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> s = prefix[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;child[s] == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            t = t-&gt;child[s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用数组作为trie的储存结构。</p>
<p>数组下表起到指针的作用，new 一个节点得到的指针就是将当前树的大小作为指针, 因为sz是树中节点的个数(包括根节点)，而节点的编号是从0开始，所以树中存在编号0到sz-1刚好sz个，此时若分配新节点刚好是sz作为编号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Trie</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGMA 26</span></span><br><span class="line"><span class="comment">//仅含小写英文字母</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Trie &#123;</span><br><span class="line">	<span class="type">int</span> tr[MAXN][SIGMA];<span class="comment">//数组存储Trie树节点,下标起到指针作用</span></span><br><span class="line">	<span class="type">int</span> val[MAXN];<span class="comment">//若当前节点不是一个模式串的结尾则为0</span></span><br><span class="line">	<span class="type">int</span> sz;<span class="comment">//Trie中当前节点个数</span></span><br><span class="line">	<span class="built_in">Trie</span>() &#123;</span><br><span class="line">		<span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">		<span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="built_in">sizeof</span>(val));</span><br><span class="line">		sz = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> len = <span class="built_in">strlen</span>(s), u = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;<span class="comment">//不存在新开就一个节点</span></span><br><span class="line">				tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>] = sz;</span><br><span class="line">				sz++;</span><br><span class="line">			&#125;</span><br><span class="line">			u = tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		val[u] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查询s是否存在</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> len = <span class="built_in">strlen</span>(s), u = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			u = tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> val[u];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> txt[<span class="number">100</span>];</span><br><span class="line"><span class="type">char</span> pat[<span class="number">5</span>][<span class="number">100</span>] = &#123;<span class="string">&quot;hers&quot;</span>, <span class="string">&quot;he&quot;</span>, <span class="string">&quot;his&quot;</span>, <span class="string">&quot;she&quot;</span>, <span class="string">&quot;i&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Trie::<span class="built_in">Trie</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">		Trie::<span class="built_in">insert</span>(pat[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cin &gt;&gt; txt;</span><br><span class="line">		cout &lt;&lt; Trie::<span class="built_in">query</span>(txt) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>01字典树，查询满足异或值范围的个数，x^a≤b的x个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> cnt;</span><br><span class="line">        Node* child[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">Node</span>():<span class="built_in">cnt</span>(<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(child, <span class="number">0</span>, <span class="built_in">sizeof</span>(child));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; *head;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        Node* t = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">14</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> s = num&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;child[s] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                t-&gt;child[s] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            t = t-&gt;child[s];</span><br><span class="line">            t-&gt;cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前trie中x的个数，其中x^a&lt;=b</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        Node* t = head;</span><br><span class="line">        <span class="type">int</span> rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">14</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> ai = a&gt;&gt;i&amp;<span class="number">1</span>, bi = b&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bi) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;child[ai]) rt += t-&gt;child[ai]-&gt;cnt;</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;child[<span class="number">1</span>^ai] == <span class="literal">NULL</span>) <span class="keyword">return</span> rt;</span><br><span class="line">                <span class="keyword">else</span> t = t-&gt;child[<span class="number">1</span>^ai];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;child[ai] == <span class="literal">NULL</span>) <span class="keyword">return</span> rt;</span><br><span class="line">                <span class="keyword">else</span> t = t-&gt;child[ai];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt+t-&gt;cnt;<span class="comment">// 当前trie中满足x^a&lt;=b的x个数。（非rt+1，可能trie中存在多个使得x^a=b的x）</span></span><br><span class="line">        <span class="comment">// return rt; // 当前trie中满足x^a&lt;b的x个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="ac自动机"><a href="#ac自动机" class="headerlink" title="ac自动机"></a>ac自动机</h2><p>ac自动机的作用：在一个文本串中如果要找一个模式串在文本串中的位置，可以用kmp算法，但是若存在多个模式串要查找，就可用ac自动机来查询。</p>
<p>AC自动机是以Trie的结构为基础，结合KMP的思想建立的。</p>
<p>简单来说，建立一个AC自动机有两个步骤：</p>
<p>基础的Trie结构：将所有的模式串构成一棵Trie。KMP的思想：对Trie树上所有的结点构造失配指针。然后就可以利用它进行多模式匹配了。</p>
<p>在代码实现上需要写三个函数：</p>
<p><code>insert(char* pattern)</code> 构成trie树需要通过一条一条插入字符串来构造</p>
<p><code>build()</code> 构造ac自动机，其中包括两个目的：建立fail指针，建造字典图；</p>
<p><code>query(char* text)</code> 将文本串放到自动机里跑，查询你要查询的信息，如：哪个模式串在文本串哪个位置出现；每个模式串出现了多少次 等。</p>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>就是普通的字典树插入函数。只是在插入模式串后的关键字节点应当以编号形式出现，因为可能需要定位到具体是哪一个模式串在文本串中出现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s), u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>] = sz++;</span><br><span class="line">        &#125;</span><br><span class="line">        u = tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    val[u] = id;<span class="comment">//默认其他非关键字节点id为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>build 得理解fail指针和字典图。</p>
<p><strong>失配指针fail</strong></p>
<ol>
<li><p>fail是什么。</p>
<p> 在kmp算法中当失配后不是从头开始再匹配，而是跳转到一个合适的位置上，继续匹配。这个合适的位置是基于当前串<strong>最长的相同前后缀</strong>的，而ac自动机的fail指针也是基于这个思想，不同之处在于后缀是根节点到当前节点路径上的字符组成一个字符串的后缀，而前缀则是前缀树中某个前缀。ac自动机的fail指向当前状态的一个最长后缀，不停的跳转fail指针得到的就是当前状态的一个后缀集合</p>
<p> <img src="https://cdnjson.com/images/2023/06/14/1087_1.png" alt="1087_1.png"></p>
</li>
<li><p>fail怎么构造。<br> 或许我们能直观的找出每个节点的fail。构造fail的算法是怎样的呢?</p>
<p> 构造fail指针的基本思想：</p>
<p> 考虑字典树中的当前节点为<code>u</code>, <code>u</code>的父节点是<code>p</code>, <code>p</code>通过字符<code>c</code>的边指向<code>u</code>， 即<code>trie[p, c] = u</code>, 假设深度小于<code>u</code>的所有节点的fail指针都求出。</p>
<ol>
<li><p>若u失败指针指向的节点的c边存在，即<code>trie[fail[p], c]</code>存在， 让u的fail指针指向<code>trie[fail[p], c]</code>.</p>
</li>
<li><p>若u失败指针指向的节点的c边不存在，即<code>trie[fail[p], c]</code>不存在， 继续找<code>trie[fail[fail[p]], c]</code>, 重复1过程，到根节点</p>
</li>
<li><p>根节点也没有c边，就指向根。</p>
<p> 要求深度大的节点的fail指针，比他深度小的节点的fail都要求求出，因此，可用树的层序遍历，也就是广度优先搜搜。</p>
<p> <img src="https://cdnjson.com/images/2023/06/14/1089_1.gif" alt="1089_1.gif"></p>
</li>
</ol>
</li>
<li><p>fail的用处</p>
<p> fail指针虽然叫失配指针，但是在实际查询中并没有失配现象，这得益于字典图的构建。fail指针也帮助构了字典图。</p>
<p> 此外fail指针最重要的一点就是再查询时的作用。(之后查询再讲)</p>
</li>
</ol>
<p><strong>字典图</strong></p>
<ol>
<li><p>字典图是什么</p>
<p> 现在需要值得注意的是，以上所述fail指针的的实现只是基本思想，在实际广搜过程中还会给字典树增加一些边使得成为一个字典图，这个图中每个节点的26个子节点都存在。不存在的都指向根节点(图中未标注)。这个字典图会简化实现fail指针的基本思想</p>
<p> <img src="https://cdnjson.com/images/2023/06/14/1091_1.png" alt="1091_1.png"></p>
</li>
<li><p>字典图怎样构造</p>
<p> 字典图和fail指针构造同时进行</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立fail指针和字典图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;SIGMA; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[<span class="number">0</span>][i]) que.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;SIGMA; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tr[u][i]) &#123;<span class="comment">//子节点存在，构建fail</span></span><br><span class="line">                fail[tr[u][i]] = tr[fail[u]][i];</span><br><span class="line">                que.<span class="built_in">push</span>(tr[u][i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//子节点不存在，建立新边</span></span><br><span class="line">                tr[u][i] = tr[fail[u]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="https://cdnjson.com/images/2023/06/14/1093_1.gif" alt="1093_1.gif"></p>
</li>
<li><p>字典图的用处</p>
<p> 通过这两图发现构建fail指针不会发现空儿子了，因此不用一直跳fail指针，提高了构造fail指针的效率</p>
<p> 字典图在查找时使得匹配转移完善。</p>
<p> 总之<strong>对于fail指针和字典图他们相互对对方的构造起到帮助，且在最后的查询时都起到了重要作用。</strong></p>
<p> <img src="https://cdnjson.com/images/2023/06/14/1097_1.gif" alt="1097_1.gif"></p>
<p> <img src="https://cdnjson.com/images/2023/06/14/1095_1.gif" alt="1095_1.gif"></p>
</li>
</ol>
<h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>查询代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询, 每个节点都要暴力跳fial指针直到根节点， 期间可能有单词节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, len=<span class="built_in">strlen</span>(s); i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>]; j; j=fail[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[j] != <span class="number">0</span>) &#123;<span class="comment">//j是单词节点</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;编号为%d的模式串最后一个字符出现在文本串下标%d位置\\n&quot;</span>, val[j], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        u = tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://imgs.wiki/imgs/2023/06/14/07dec5613e91185b.gif" alt="1119_1.gif"></p>
<p>字典图的构建使得每个节点的子节点都有了转移的位置，使得文本串中的字符有着统一的节点转移函数<code>u=tr[u][s[i]-&#39;a&#39;]</code>, 使得查询代码对于失配情况和非失配情况有着同样的处理方法。</p>
<p>fail指针链上的节点是当前字符串的后缀集合，其中有些字符串是模式串，所以对于每一个节点需要遍历fail指针链。</p>
<p><img src="https://cdnjson.com/images/2023/06/14/1099_1.png" alt="1099_1.png"></p>
<p>从上图可以看出：</p>
<p>当前节点为13时遍历fail指针却没有一个是关键字节点。</p>
<p>当前节点为14时遍历fail指针有些是关键字节点，有些不是。</p>
<p>当前节点为15时遍历fail指针全是关键字节点。</p>
<p>遍历到非关键字节点是不必要的。</p>
<p>我们可以对每一个节点引入一个last指针，利用fail指针链路径压缩使得<code>last[i]</code>代表i节点指向fail链中离自己最近的一个关键字节点，如图：</p>
<p><img src="https://cdnjson.com/images/2023/06/14/1101_1.png" alt="1101_1.png"></p>
<p>这样，在查询时就可以遍历last指针链了，这样做的好处是last指向的一定是一个关键字节点，除了根节点外。此外对于当前节点可能是关节字节点也可能不是。</p>
<p>代码上的实现</p>
<p>在构建fail指针后紧接着构建last指针:</p>
<p>若需要构建last指针的节点为i，<code>fail[i]</code>指针所指节点是一个关键字节点，那么<code>last[i] = fail[i]</code>, 否则，<code>last[i] = last[fail[i]]</code>, 类似动态规划，在求i之前，比i深度小的节点已经建立last。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">last[tr[u][i]] = val[fail[tr[u][i]]]?fail[tr[u][i]]:last[fail[tr[u][i]]];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>定义$|s_i|$是第i个模板串的长度，$|S|$是文本串的长度， $|\sigma|$是字符集的大小（常数，一般为 26）。如果没有连 trie 图，时间复杂度就是$O(\sum|s_i|+n|\sigma|+|S|)$ ，其中$n$是 AC 自动机中结点的数目，并且最大可以达到$O(\sum|s_i|)$。如果连 trie 图，并且在构建 fail 指针的时候避免遍历到空儿子，时间复杂度就是 $O(\sum|s_i|+|S|)$ 。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGMA 26</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 建立字典树</span></span><br><span class="line"><span class="comment">2. 生成fail指针和字典图</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ac &#123;</span><br><span class="line">	<span class="type">int</span> tr[MAXN][SIGMA];</span><br><span class="line">	<span class="type">int</span> val[MAXN];<span class="comment">//关键字节点 val[i] i号节点是编号为val[i]的模式串，从1开始</span></span><br><span class="line">	<span class="type">int</span> fail[MAXN];<span class="comment">//指向最长的后缀且是前缀树的前缀</span></span><br><span class="line">	<span class="type">int</span> last[MAXN];<span class="comment">//在fail链中指向离自己最近的关键字节点</span></span><br><span class="line">	<span class="type">int</span> cnt[MAXN]; <span class="comment">//cnt[i] 编号为i的模式串出现的次数数</span></span><br><span class="line">	<span class="type">int</span> sz;<span class="comment">//节点个数</span></span><br><span class="line">	<span class="type">int</span> id;<span class="comment">//为将插入的模式串分配的id</span></span><br><span class="line">	<span class="built_in">Ac</span>() &#123;</span><br><span class="line">		<span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">		<span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="built_in">sizeof</span>(val));</span><br><span class="line">		<span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="built_in">sizeof</span>(fail));</span><br><span class="line">		sz = <span class="number">1</span>;</span><br><span class="line">		id = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> len = <span class="built_in">strlen</span>(s), u = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">				tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>] = sz++;</span><br><span class="line">			&#125;</span><br><span class="line">			u = tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		val[u] = id++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//建立fail指针和字典图 优化：在建立fail后再建立last</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;SIGMA; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tr[<span class="number">0</span>][i]) que.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="type">int</span> u = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;SIGMA; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (tr[u][i]) &#123;<span class="comment">//存在</span></span><br><span class="line">					fail[tr[u][i]] = tr[fail[u]][i];</span><br><span class="line">					last[tr[u][i]] = val[fail[tr[u][i]]]?fail[tr[u][i]]:last[fail[tr[u][i]]];<span class="comment">//优化</span></span><br><span class="line">					que.<span class="built_in">push</span>(tr[u][i]);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tr[u][i] = tr[fail[u]][i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查询, 每个节点都要暴力跳fial指针直到根节点， 期间可能有单词节点</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, len=<span class="built_in">strlen</span>(s); i&lt;len; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>]; j; j=fail[j]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (val[j] != <span class="number">0</span>) &#123;<span class="comment">//j是单词节点</span></span><br><span class="line">					cnt[val[j]]++;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;编号为%d的模式串最后一个字符出现在文本串下标%d位置\\n&quot;</span>, val[j], i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			u = tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//优化查询</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">queryWithLast</span><span class="params">(<span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, len=<span class="built_in">strlen</span>(s); i&lt;len; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>]; j; j=last[j]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (val[j] != <span class="number">0</span>) &#123;<span class="comment">//j是单词节点</span></span><br><span class="line">					cnt[val[j]]++;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;编号为%d的模式串最后一个字符出现在文本串下标%d位置\\n&quot;</span>, val[j], i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			u = tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印每个字符串出现次数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=id; i++) &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; cnt[i] &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//debug</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;fail[%d]=%d\\n&quot;</span>, i, fail[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;last[%d]=%d\\n&quot;</span>, i, last[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> txt[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//char pat[5][100] = &#123;&quot;i&quot;, &quot;she&quot;, &quot;his&quot;, &quot;hers&quot;, &quot;he&quot;&#125;;</span></span><br><span class="line"><span class="type">char</span> pat[<span class="number">8</span>][<span class="number">100</span>] = &#123;</span><br><span class="line"><span class="string">&quot;abc&quot;</span>,</span><br><span class="line"><span class="string">&quot;aabc&quot;</span>,</span><br><span class="line"><span class="string">&quot;aaabc&quot;</span>,</span><br><span class="line"><span class="string">&quot;aaaabc&quot;</span>,</span><br><span class="line"><span class="string">&quot;aaaaabc&quot;</span>,</span><br><span class="line"><span class="string">&quot;ab&quot;</span>,</span><br><span class="line"><span class="string">&quot;aaab&quot;</span>,</span><br><span class="line"><span class="string">&quot;aaaaab&quot;</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Ac::<span class="built_in">Ac</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">		Ac::<span class="built_in">insert</span>(pat[i]);</span><br><span class="line">		cout &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pat[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Ac::<span class="built_in">build</span>();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cin &gt;&gt; txt;</span><br><span class="line">		Ac::<span class="built_in">query</span>(txt);</span><br><span class="line">		Ac::<span class="built_in">print</span>();</span><br><span class="line">		Ac::<span class="built_in">debug</span>();</span><br><span class="line">		<span class="built_in">memset</span>(Ac::cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(Ac::cnt));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 abc</span><br><span class="line">2 aabc</span><br><span class="line">3 aaabc</span><br><span class="line">4 aaaabc</span><br><span class="line">5 aaaaabc</span><br><span class="line">6 ab</span><br><span class="line">7 aaab</span><br><span class="line">8 aaaaab</span><br><span class="line">aaaaab</span><br><span class="line">编号为8的模式串最后一个字符出现在文本串下标5位置</span><br><span class="line">编号为7的模式串最后一个字符出现在文本串下标5位置</span><br><span class="line">编号为6的模式串最后一个字符出现在文本串下标5位置</span><br><span class="line">每个模式串出现的次数</span><br><span class="line">1 0</span><br><span class="line">2 0</span><br><span class="line">3 0</span><br><span class="line">4 0</span><br><span class="line">5 0</span><br><span class="line">6 1</span><br><span class="line">7 1</span><br><span class="line">8 1</span><br><span class="line">fail[0]=0</span><br><span class="line">fail[1]=0</span><br><span class="line">fail[2]=0</span><br><span class="line">fail[3]=0</span><br><span class="line">fail[4]=1</span><br><span class="line">fail[5]=2</span><br><span class="line">fail[6]=3</span><br><span class="line">fail[7]=4</span><br><span class="line">fail[8]=5</span><br><span class="line">fail[9]=6</span><br><span class="line">fail[10]=7</span><br><span class="line">fail[11]=8</span><br><span class="line">fail[12]=9</span><br><span class="line">fail[13]=10</span><br><span class="line">fail[14]=11</span><br><span class="line">fail[15]=12</span><br><span class="line">last[0]=0</span><br><span class="line">last[1]=0</span><br><span class="line">last[2]=0</span><br><span class="line">last[3]=0</span><br><span class="line">last[4]=0</span><br><span class="line">last[5]=2</span><br><span class="line">last[6]=3</span><br><span class="line">last[7]=0</span><br><span class="line">last[8]=2</span><br><span class="line">last[9]=6</span><br><span class="line">last[10]=0</span><br><span class="line">last[11]=8</span><br><span class="line">last[12]=9</span><br><span class="line">last[13]=0</span><br><span class="line">last[14]=8</span><br><span class="line">last[15]=12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考文献<br><a href="https://oi-wiki.org/string/ac-automaton/">https://oi-wiki.org/string/ac-automaton/</a></p>
<p>专题练习<br><a href="https://vjudge.net/contest/70326">https://vjudge.net/contest/70326</a></p>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>Aho-Corasick automaton</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串哈希</title>
    <url>/2023/06/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<h1 id="单哈希"><a href="#单哈希" class="headerlink" title="单哈希"></a>单哈希</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="type">const</span> ull MOD = <span class="number">998244353</span>, BASE = <span class="number">171</span>;</span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;ull&gt; <span class="title">H</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">B</span><span class="params">(n+<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">// string s[] index from 0 to n-1</span></span><br><span class="line"><span class="comment">// B[i] = BASE^i</span></span><br><span class="line"><span class="comment">// s[i...j] = s[0...j] - s[0...i-1]</span></span><br><span class="line"><span class="comment">// hash s[0...i-1] = H[i] = s[0]*B[i-1]+s[1]*B[i-2]+...+s[i-1]*B[0]</span></span><br><span class="line"><span class="comment">// hash s[0...j] = H[j+1] = s[0]*B[j]+s[1]*B[j-1]+...+s[j]*B[0]</span></span><br><span class="line"><span class="comment">// hash s[i...j] = H[j+1] - H[i]*B[j-i+1]</span></span><br><span class="line"><span class="comment">// hash s[i...j-1] = H[j] - H[i]*B[j-i]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    H[i] = (H[i<span class="number">-1</span>]*BASE%MOD + s[i<span class="number">-1</span>])%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    B[i] = B[i<span class="number">-1</span>]*BASE%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> hash = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r) &#123;  <span class="comment">// hash of s[l...r-1]</span></span><br><span class="line">    <span class="built_in">return</span> (H[r] - H[l] * B[r - l] % MOD + MOD) % MOD;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于长度为n的字符串s，下标从0开始。</p>
<p>令$B[i] = BASE^i$</p>
<p>长度为i的前缀子串<code>s[0…i-1]</code>的哈希值, $H[i] = \sum \limits_{j=0}^{i-1} s[j]*B[i-1-j]$</p>
<p>长度为len的子串<code>s[i…j]</code>的哈希值<code>H[j+1] - H[i]*B[j-i+1]</code> 注意取模。</p>
<h1 id="无符整型自然溢出"><a href="#无符整型自然溢出" class="headerlink" title="无符整型自然溢出"></a>无符整型自然溢出</h1><p><del>毒瘤写法</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE 131</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;abcdabcdab&quot;</span>;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();<span class="comment">//n=10</span></span><br><span class="line">    <span class="function">vector&lt;ull&gt; <span class="title">H</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">B</span><span class="params">(n+<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        H[i] = H[i<span class="number">-1</span>]*BASE+s[i<span class="number">-1</span>];</span><br><span class="line">        B[i] = B[i<span class="number">-1</span>]*BASE;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// string s[] index from 0 to n-1</span></span><br><span class="line">    <span class="comment">// H[i] 前i个字符的前缀串哈希值, H[0] = 0。</span></span><br><span class="line">		<span class="comment">// B[i] = BASE^i</span></span><br><span class="line">    <span class="comment">// H[r]-H[l]*B[r-l] = s[l...r-1]</span></span><br><span class="line">    <span class="comment">// s[l...r] = H[r+1] - H[l]*B[r-l+1]</span></span><br><span class="line">    <span class="keyword">auto</span> hash = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r) &#123;  <span class="comment">// hash of s[l...r-1]</span></span><br><span class="line">        <span class="keyword">return</span> H[r] - H[l] * B[r - l];</span><br><span class="line">    &#125;;</span><br><span class="line">		cout &lt;&lt; H[<span class="number">3</span>] - H[<span class="number">0</span>]*B[<span class="number">3</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; H[<span class="number">7</span>] - H[<span class="number">4</span>]*B[<span class="number">3</span>] &lt;&lt; endl; <span class="comment">// abc abc</span></span><br><span class="line">    cout &lt;&lt; H[<span class="number">4</span>] - H[<span class="number">0</span>]*B[<span class="number">4</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; H[<span class="number">8</span>] - H[<span class="number">4</span>]*B[<span class="number">4</span>] &lt;&lt; endl; <span class="comment">// abcd abcd</span></span><br><span class="line">    cout &lt;&lt; H[<span class="number">2</span>] - H[<span class="number">0</span>]*B[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; H[<span class="number">6</span>] - H[<span class="number">4</span>]*B[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; H[<span class="number">10</span>]-H[<span class="number">8</span>]*B[<span class="number">2</span>] &lt;&lt; endl; <span class="comment">// abcd abcd</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1677554 1677554</span></span><br><span class="line"><span class="comment">219759674 219759674</span></span><br><span class="line"><span class="comment">12805 12805 12805</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="多重哈希"><a href="#多重哈希" class="headerlink" title="多重哈希"></a>多重哈希</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单哈希容易被卡，封装用多重哈希</span></span><br><span class="line"><span class="comment">// 两个串的哈希相等，说明串大概率相等。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hash</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line">    <span class="comment">// string s[] index from 0 to n-1</span></span><br><span class="line">    <span class="comment">// B[i] = BASE^i</span></span><br><span class="line">    <span class="comment">// s[i...j] = s[0...j] - s[0...i-1]</span></span><br><span class="line">    <span class="comment">// hash s[0...i-1] = H[i] = s[0]*B[i-1]+s[1]*B[i-2]+...+s[i-1]*B[0]</span></span><br><span class="line">    <span class="comment">// hash s[0...j] = H[j+1] = s[0]*B[j]+s[1]*B[j-1]+...+s[j]*B[0]</span></span><br><span class="line">    <span class="comment">// hash s[i...j] = H[j+1] - H[i]*B[j-i+1]</span></span><br><span class="line">    <span class="comment">// hash s[i...j-1] = H[j] - H[i]*B[j-i]</span></span><br><span class="line">    vector&lt;ull&gt; H, B;</span><br><span class="line">    ull len, base, mod;</span><br><span class="line">    <span class="built_in">Hash</span>(string&amp; s, ull base = <span class="number">131</span>, ull mod = <span class="number">998244353</span>)</span><br><span class="line">        : <span class="built_in">H</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">          <span class="built_in">B</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">          <span class="built_in">len</span>(s.<span class="built_in">size</span>()),</span><br><span class="line">          <span class="built_in">base</span>(base),</span><br><span class="line">          <span class="built_in">mod</span>(mod) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            H[i] = (H[i - <span class="number">1</span>] * base % mod + s[i - <span class="number">1</span>]) % mod;</span><br><span class="line">            B[i] = B[i - <span class="number">1</span>] * base % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ull <span class="title">hash</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;  <span class="comment">// hash of s[l...r-1]</span></span><br><span class="line">        <span class="keyword">return</span> (H[r] - H[l] * B[r - l] % mod + mod) % mod;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Checker</span> &#123;</span><br><span class="line">    vector&lt;Hash&gt; h;</span><br><span class="line">    <span class="built_in">Checker</span>(string&amp; s) &#123;</span><br><span class="line">        <span class="comment">// MOD 太大会溢出, 应在sqrt(ull)内</span></span><br><span class="line">        vector&lt;pair&lt;ull, ull&gt;&gt; param = &#123;&#123;<span class="number">131ull</span>, <span class="number">998244353ull</span>&#125;,</span><br><span class="line">                                        &#123;<span class="number">151ull</span>, <span class="number">1000000007ull</span>&#125;,</span><br><span class="line">                                        &#123;<span class="number">171ull</span>, <span class="number">998244357ull</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : param) &#123;</span><br><span class="line">            h.<span class="built_in">emplace_back</span>(s, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// is s[l1...r1-1] == s[l2...r2-1] ? s[] index from 0</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2, <span class="type">int</span> r2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : h) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.<span class="built_in">hash</span>(l1, r1) != i.<span class="built_in">hash</span>(l2, r2))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="判断回文串"><a href="#判断回文串" class="headerlink" title="判断回文串"></a>判断回文串</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> ull BASE = <span class="number">131</span>;</span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">vector&lt;ull&gt;<span class="built_in">P</span>(n+<span class="number">1</span>, <span class="number">0</span>),<span class="built_in">S</span>(n+<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">B</span>(n+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    P[i] = P[i<span class="number">-1</span>]*BASE+s[i<span class="number">-1</span>];</span><br><span class="line">    B[i] = B[i<span class="number">-1</span>]*BASE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">    S[i] = S[i+<span class="number">1</span>]*BASE+s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> ok = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r) &#123; <span class="comment">//[l,r) 0&lt;=l,r&lt;n</span></span><br><span class="line">    <span class="keyword">return</span> P[r]-P[l]*B[r-l] == S[l]-S[r]*B[r-l];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><strong><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></strong></strong></p>
<p><a href="https://leetcode-cn.com/problems/rotate-string/"><strong>796. 旋转字符串</strong></a></p>
<p><a href="https://leetcode-cn.com/problems/shortest-palindrome/"><strong>214. 最短回文串</strong></a></p>
<p><a href="https://leetcode-cn.com/problems/longest-duplicate-substring/"><strong>1044. 最长重复子串</strong></a></p>
<p><a href="https://leetcode-cn.com/problems/distinct-echo-substrings/"><strong>1316. 不同的循环子字符串</strong></a></p>
<p><a href="https://leetcode-cn.com/problems/longest-happy-prefix/"><strong>1392. 最长快乐前缀</strong></a></p>
<p><a href="https://leetcode-cn.com/problems/sum-of-scores-of-built-strings/"><strong>2223. 构造字符串的总得分和</strong></a></p>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>完成所有任务的最少时间</title>
    <url>/2023/04/09/%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/">6318. 完成所有任务的最少时间</a></p>
<hr>
<p>你有一台电脑，它可以 <strong>同时</strong> 运行无数个任务。给你一个二维整数数组 <code>tasks</code> ，其中 <code>tasks[i] = [starti, endi, durationi]</code> 表示第 <code>i</code> 个任务需要在 <strong>闭区间</strong> 时间段 <code>[starti, endi]</code> 内运行 <code>durationi</code> 个整数时间点（但不需要连续）。</p>
<p>当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。</p>
<p>请你返回完成所有任务的情况下，电脑最少需要运行多少秒。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：tasks = [[2,3,1],[4,5,1],[1,5,2]]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 第一个任务在闭区间 [2, 2] 运行。</span><br><span class="line">- 第二个任务在闭区间 [5, 5] 运行。</span><br><span class="line">- 第三个任务在闭区间 [2, 2] 和 [5, 5] 运行。</span><br><span class="line">电脑总共运行 2 个整数时间点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：tasks = [[1,3,2],[2,5,3],[5,6,2]]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">- 第一个任务在闭区间 [2, 3] 运行</span><br><span class="line">- 第二个任务在闭区间 [2, 3] 和 [5, 5] 运行。</span><br><span class="line">- 第三个任务在闭区间 [5, 6] 运行。</span><br><span class="line">电脑总共运行 4 个整数时间点。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= tasks.length &lt;= 2000</code></li>
<li>  <code>tasks[i].length == 3</code></li>
<li>  <code>1 &lt;= starti, endi &lt;= 2000</code></li>
<li><code>1 &lt;= durationi &lt;= endi - starti + 1</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>贪心</p>
<p>首先对区间进行右端点升序排序。</p>
<p>对于一个区间的duration个数应该尽可能的放在区间右端，以便让后面的区间能与当前尽可能多的重叠。</p>
<p>所以当前区间的duration应该减去前面区间在本区间放置的位置个数，然后从区间右端向左寻找空位放置。</p>
<p>实际复杂度$O(n^2)$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinimumTime</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(tasks.<span class="built_in">begin</span>(), tasks.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2001</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = tasks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:tasks) &#123;</span><br><span class="line">            <span class="type">int</span> r = i[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i[<span class="number">0</span>]; j&lt;=i[<span class="number">1</span>]; j++) &#123;</span><br><span class="line">                r -= d[j]==<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=i[<span class="number">1</span>]; j&gt;=i[<span class="number">0</span>]; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (d[j]) <span class="keyword">continue</span>;</span><br><span class="line">                    d[j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (--r == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>容斥与鸽巢</title>
    <url>/2023/01/06/%E5%AE%B9%E6%96%A5%E4%B8%8E%E9%B8%BD%E5%B7%A2/</url>
    <content><![CDATA[<h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><p>$|A_1\cup A_2 \cup A_3 \cdots \cup A_n| = \sum \limits_{i=1}^{n} |A_i| - \sum \limits_{i=1}^{n} \sum \limits_{i&lt;j}|A_i\cap A_j|+\sum \limits_{i=1}^{n} \sum \limits_{i&lt;j}\sum \limits_{j&lt;k}|A_i\cap A_j \cap A_k|-\cdots\pm|A_1\cap A_2 \cap A_3 \cap \cdots \cap A_n|$</p>
<p>$|\bar{A_1} \cap \bar A_2 \cap \bar A_3 \cdots \cap \bar A_n| =A - |A_1\cup A_2 \cup A_3 \cdots \cup A_n|=A- \sum \limits_{i=1}^{n} |A_i| + \sum \limits_{i=1}^{n} \sum \limits_{i&lt;j}|A_i\cap A_j|-\sum \limits_{i=1}^{n} \sum \limits_{i&lt;j}\sum \limits_{j&lt;k}|A_i\cap A_j \cap A_k|+\cdots \mp |A_1\cap A_2 \cap A_3 \cap \cdots \cap A_n|$</p>
<h2 id="容斥原理的引用"><a href="#容斥原理的引用" class="headerlink" title="容斥原理的引用"></a>容斥原理的引用</h2><p>求1到500内的整数中能被3或5整除的数的个数。</p>
<p>A = 1到500内的整数能被3整除的个数， $A=\lfloor \frac{500}{3}\rfloor = 166$</p>
<p>B = 1到500内的整数能被5整除的个数， $B=\lfloor \frac{500}{5}\rfloor = 100$</p>
<p>$A\cap B = \lfloor \frac{500}{15}\rfloor = 33$</p>
<p>$|A\cup B| = |A|+|B|-|A\cap B| = 166+100-33 = 233$</p>
<hr>
<p>a，b，c，d四个字母构成n位的字符串中，a，b，c至少都出现1次的串数目</p>
<p>所有方案数为$N=4^n$</p>
<p>a没有出现过的方案数$A=3^n$</p>
<p>b没有出现过的方案数$B=3^n$</p>
<p>c没有出现过的方案数$C=3^n$</p>
<p>a,b都没有出现过的方案数$|A\cap B| = 2^n$</p>
<p>a,c都没有出现过的方案数$|A\cap C| = 2^n$</p>
<p>b,c都没有出现过的方案数$|B\cap C| = 2^n$</p>
<p>a,b,c都没有出现过的方案数$|A\cap B\cap C| = 1$</p>
<p>$|\bar A \cap \bar B \cap \bar C| = N - |A \cup B \cup C | = N - A - B - C + |A \cap B| + |B\cap C| + |A \cap C| - |A\cap B \cap C|$ </p>
<hr>
<p>不超过120的素数有多少个？</p>
<p>不超过120的合数一定是2，3，5，7的倍数。</p>
<p>利用容斥原理算出所有不重复的能被2，3，5，7整除的数。用120减去他们，加上4个素数（2，3，5，7），再减去特殊的1便是答案。</p>
<hr>
<p>欧拉函数$\Phi(n)$是求小于n且与n互素的数的个数。</p>
<p>分解n为不同素数的乘积 $n = p_1^{a_1}p_2^{a_2}\cdots p_1k^{a_k}$</p>
<p>设1到n的个数中$p_i$的倍数集合是$A_i$</p>
<p>$|A_i| = \lfloor \frac{n}{p_i} \rfloor$</p>
<p>$p_i$与$p_j$的倍数$|A_i \cap A_j| = \lfloor \frac{n}{p_ip_j} \rfloor$</p>
<p>$|\bar A_1 \cap \bar A_2 \cap\bar A_3 \cap \cdots \cap A_k| = n - |A_1 \cup A_2  \cup A_3 \cup \cdots \cup A_k| = n\prod(1-\frac{1}{p_i})$</p>
<hr>
<p>求不定方程$x_1+x_2+x_3=15$的非负整数数目，其中$0≤x_1≤5,0≤x_2≤6,0≤x_3≤7$。</p>
<p>如果约束条件都是$x_i≥0$，那么答案就是有序拆分数。</p>
<p>作等价替换，例如令$y=x_1+6$，这样$y+x_2+x_3 = 9$的非负整数数目就是不满足约束$0≤x_1≤5$的数目。</p>
<p>令$A_i$为不满足$x_i$的约束的数目，那么答案是$|\bar A_1 \cap \bar A_2 \cap \bar A_3|$，利用容斥原理即可。</p>
<hr>
<p>格路问题</p>
<p><img src="https://i.328888.xyz/2022/12/17/4mIPv.png" alt="4mIPv.png"></p>
<p>不经过障碍的条数。</p>
<p>利用容斥思想，求出经过障碍的条数。</p>
<p>设经过障碍AB的集合为$A_1$，经过障碍CD的集合为$A_2$，经过障碍EF的集合为$A_3$，经过障碍HG的集合为$A_4$。答案是$|\bar A_1 \cap \bar A_2 \cap \bar A_3 \cap \bar A_4|$</p>
<hr>
<p>将n个有区别的球放到m个有区别的盒子，且不能空盒的方案数。</p>
<p>设$A_i$为不选第$i$个盒子的集合。</p>
<p>设$N$为可以有空盒的情况（至少0个空盒），有$m^n$种方案；|$A_i$|为至少一个空盒的方案数，有$C_m^1(m-1)^n$种（盒子有区别，有m种选法）；$|A_i \cap A_j|$为至少两个空盒的方案数，有$C_m^2(m-2)^n$种；……；</p>
<p>无空盒的方案数是$|\bar A_1 \cap \bar A_2 \cap \cdots \cap \bar A_m| = \sum \limits_{i=0}^{m}(-1)^iC_m^i(m-i)^n$</p>
<hr>
<p>错排问题，求n个元素都不在自己原来位置的排列数。</p>
<p>设$A_i$为第$i$位在原来位置上的排列。</p>
<p>$|A_i| = (n-1)!$</p>
<p>$|A_i \cap A_j| = (n-2)!$</p>
<p>$|\bar A_1 \cap \bar A_2 \cap \cdots \cap \bar A_n| = \sum \limits_{i=0}^{n} (-1)^iC_{n}^{i}(n-i)!= \sum \limits_{i=0}^{n} (-1)^i\frac{n!}{i!}$</p>
<h1 id="鸽巢原理"><a href="#鸽巢原理" class="headerlink" title="鸽巢原理"></a>鸽巢原理</h1><p>如果要把$n$个对象分配到$m$个容器中，必有至少一个容器容纳至少$\lceil \frac {n}{m}\rceil$个对象。</p>
<h2 id="鸽巢原理的应用"><a href="#鸽巢原理的应用" class="headerlink" title="鸽巢原理的应用"></a>鸽巢原理的应用</h2><ul>
<li><p>有n+1个正整数，全部小于或等于2n，证明一定有两个数是互质的。</p>
<p>  将2n个数分成n组，2i+1与2i+2在一组中，显然在一组中的数是互质的，现在选出n+1个数，一定会选到某一组互质的数。</p>
</li>
<li><p>1到2n的正整数任取n+1个，则n+1个数中至少有一对数其中一个是另一个的倍数。</p>
<p>  将所有的数的2因子去除，最后一定成为奇数，而2n内只有n个奇数，所以取出n+1个数必有两个相同的奇数，这两个相同的奇数各自乘以任意个数的2，依然成倍数关系。</p>
</li>
<li><p>有$a_1,a_2,\cdots,a_{100}$，是由1和2组成的序列，已知任意一个数开始的顺序10个数之和不超过16，即$a_i+a_{i+1}+a_{i+2}+\cdots+a_{i+9} \le 16, 1\le i \le91$，证明存在h与k，k&gt;h，使得$a_{h+1}+\cdots+a_{k} = 39$</p>
<p>  令$S_n = \sum \limits_{i=1}^{n} a_i$，构造序列$S_1,S_2,…,S_{100},S_1+39,S_2+39,…,S_{100}+39$，共计200项，最大值$S_{100}+39 = 199$，这200项中有两项相等，前n项互不相同，后n项互不相同，所以$S_k = S_h+39$，$S_i$单调增所以$h&lt;k$。</p>
</li>
<li><p>有20件衣服，4件蓝色，7件灰色，9件红色，任取多少件保证有4件同色?</p>
<p>  每种颜色都取3件共9件，再取1件就可以有4件同色。至多取10件。</p>
</li>
<li><p>有20件衣服，4件蓝色，7件灰色，9件红色，任取多少件保证有5件同色?</p>
<p>  由于蓝色只有4件，最坏的情况将蓝色取完，然后剩余两种颜色各取4件后再任取一件就会有5件同色，至多13件。</p>
</li>
<li><p>求最小非负整数$x$，使得$x=3a+2, x = 5b+3, x = 7c+2$，</p>
<p>  构造法</p>
<p>  考虑5和7的某个公倍数t1除以3余2。5*7 = 35，35%3 = 2，选择t1 = 35</p>
<p>  考虑3和7的某个公倍数t2除以5余3。3<em>7 = 21，21%5 = 1, 21</em>3%5 = 3，选择t2 = 63</p>
<p>  考虑3和5的某个公倍数t3除以7余2。3<em>5 = 15，15%7 = 1, 15</em>2%7 = 2，选择t3 = 30</p>
<p>  此时x+k*lcm(3,5,7)=t1+t2+t3。</p>
</li>
<li><p>中国剩余定理（Chinese Remainder Theorem），m和n是互质的正整数，对于任意非负整数$a$与$b(a&lt;m，b&lt;n)$。必定存在正整数$x$使得联立的同余方程组有公共解</p>
<p>  $\left{ \begin{array}{l}<br>  x = pm+a \<br>  x = qn+b<br>  \end{array}\right.$ $p,q$为非负整数</p>
<p>  考虑n个数$a, m+a, 2m+a, 3m+a, … , (n-1)m+a$ 均满足除以$m$余$a$</p>
<p>  这n个数除以n的余数是互不相同的。</p>
<p>  如果相同则有$im+a = q_in+r, jm + a = q_jm+r$，相减得到$(j-i)m = (q_j-q_i)n$，n和m是互质的，j-i&lt;n所以矛盾。</p>
<p>  由于除以n的余数只有n个，所以0到n-1一定有一个数b满足$x=qn+b$</p>
</li>
</ul>
]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥与鸽巢</tag>
      </tags>
  </entry>
  <entry>
    <title>将数组分成三个子数组的方案数</title>
    <url>/2023/04/09/%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E4%B8%89%E4%B8%AA%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/">1712. 将数组分成三个子数组的方案数</a></p>
<hr>
<p>我们称一个分割整数数组的方案是 <strong>好的</strong> ，当它满足：</p>
<ul>
<li>  数组被分成三个 <strong>非空</strong> 连续子数组，从左至右分别命名为 <code>left</code> ， <code>mid</code> ， <code>right</code> 。</li>
<li>  <code>left</code> 中元素和小于等于 <code>mid</code> 中元素和，<code>mid</code> 中元素和小于等于 <code>right</code> 中元素和。</li>
</ul>
<p>给你一个 <strong>非负</strong> 整数数组 <code>nums</code> ，请你返回 <strong>好的</strong> 分割 <code>nums</code> 方案数目。由于答案可能会很大，请你将结果对 <code>10^9 + 7</code> 取余后返回。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：唯一一种好的分割方案是将 nums 分成 [1] [1] [1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,2,2,5,0]</span><br><span class="line">输出：3</span><br><span class="line">解释：nums 总共有 3 种好的分割方案：</span><br><span class="line">[1] [2] [2,2,5,0]</span><br><span class="line">[1] [2,2] [2,5,0]</span><br><span class="line">[1,2] [2,2] [5,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：没有好的分割方案。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>3 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>0 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>已知<code>nums[i] i from 0 to n-1</code></p>
<p>题目要求<code>nums[0...i] &lt;= nums[i+1...j] &lt;= nums[j+1...n-1]</code>，其中<code>i&lt;j, i from 0 to n-3, j from 1 to n-2</code>。</p>
<p>令<code>p[i] = nums[0...i-1]</code>，得<code>p[i+1]-p[0]&lt;=p[j+1]-p[i+1]&lt;=p[n]-p[j+1]</code><br>变型可得$2p[i+1] \le p[j+1] \le \lfloor \frac{p[n]+p[i+1]}{2} \rfloor$</p>
<p>变量替换得</p>
<p>$2p[u] \le p[v] \le \lfloor \frac{p[n]+p[u]}{2} \rfloor, u&lt;v, u \in [1, n-2], v \in [2, n-1]$</p>
<p>由此我们可以遍历<code>u</code>，符合条件的<code>v</code>的个数是非负的<code>r-l+1</code></p>
<p>其中<code>l</code>是<code>p</code>中第一个大于等于<code>2p[u]</code>的下标与下标<code>i+1</code>的最大值。</p>
<p>其中<code>r</code>是<code>p</code>中最后一个小于等于$\lfloor \frac{p[n]+p[u]}{2} \rfloor$的下标与<code>n-1</code>的最小值。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">waysToSplit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">p</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            p[i] = p[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> ans = <span class="number">0</span>, MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">lower_bound</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">2</span>*p[i])-p.<span class="built_in">begin</span>();</span><br><span class="line">            l = <span class="built_in">max</span>(i+<span class="number">1</span>, l);</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">upper_bound</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), (p[n]+p[i])/<span class="number">2</span>)<span class="number">-1</span>-p.<span class="built_in">begin</span>();</span><br><span class="line">            r = <span class="built_in">min</span>(n<span class="number">-1</span>, r);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt;  l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="number">0</span>, r-l+<span class="number">1</span>);</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>将数组分成两个数组并最小化数组和的差</title>
    <url>/2023/04/09/%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%B9%B6%E6%9C%80%E5%B0%8F%E5%8C%96%E6%95%B0%E7%BB%84%E5%92%8C%E7%9A%84%E5%B7%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/partition-array-into-two-arrays-to-minimize-sum-difference/">2035. 将数组分成两个数组并最小化数组和的差</a></p>
<hr>
<p>给你一个长度为 <code>2 * n</code> 的整数数组。你需要将 <code>nums</code> 分成 <strong>两个</strong> 长度为 <code>n</code> 的数组，分别求出两个数组的和，并 <strong>最小化</strong> 两个数组和之 <strong>差的绝对值</strong> 。<code>nums</code> 中每个元素都需要放入两个数组之一。</p>
<p>请你返回 <strong>最小</strong> 的数组和之差。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/10/02/ex1.png" alt="example-1"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,9,7,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：最优分组方案是分成 [3,9] 和 [7,3] 。</span><br><span class="line">数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [-36,36]</span><br><span class="line">输出：72</span><br><span class="line">解释：最优分组方案是分成 [-36] 和 [36] 。</span><br><span class="line">数组和之差的绝对值为 abs((-36) - (36)) = 72 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/10/02/ex3.png" alt="example-3"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,-1,0,4,-2,-9]</span><br><span class="line">输出：0</span><br><span class="line">解释：最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。</span><br><span class="line">数组和之差的绝对值为 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 15</code></li>
<li>  <code>nums.length == 2 * n</code></li>
<li><code>-10^7 &lt;= nums[i] &lt;= 10^7</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>折半搜索+二分。</p>
<p>注意到数据量极小（n=30），但是每个数的数值范围极大(m=1e9)。</p>
<p>如果数据量不太小（n=1e3），所有数的总和范围不太大(sum(m)=1e3)，可以用01背包解决。时间复杂度$O(n*sum(m))$</p>
<p>这里就利用数据个数极小这一点进行优化。</p>
<p>利用折半搜索和二分查找，将时间复杂度降低到$O(2^{n/2}*log(2^{n/2}))$</p>
<p>具体做法是</p>
<p>将前n/2个数枚举选取的组合，对于选取的一部分a认为是放到第一个数组中，对于没有选取的一部分b认为是放到第二个数组中。</p>
<p>将a个数求和-b个数求和存入有序集合中。</p>
<p>然后再对后n/2个数枚举组合。在有序集合中寻找一个值与之和最靠近0，这可以用二分查找。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumDifference</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br><span class="line">        set&lt;ll&gt; st[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1</span>&lt;&lt;n; i++) &#123;</span><br><span class="line">            ll cnt = <span class="number">0</span>, cb = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;&gt;j&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                    cnt += nums[j];</span><br><span class="line">                    cb++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt -= nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            st[cb].<span class="built_in">insert</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">1e15</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1</span>&lt;&lt;n; i++) &#123;</span><br><span class="line">            ll cnt = <span class="number">0</span>, cb = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;&gt;j&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                    cnt += nums[j+n];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt -= nums[j+n];</span><br><span class="line">                    cb++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it = st[cb].<span class="built_in">lower_bound</span>(-cnt);</span><br><span class="line">            <span class="keyword">if</span> (it != st[cb].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(*it+cnt));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it != st[cb].<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(*--it+cnt));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>折半搜索，枚举前n个数的组合情况（选取x个的和减去剩余的n-x个的和cnt）存入第x个平衡树，注意到要将2n长度的数组分割成两个长度为n的数组。第二次枚举时当选取x个负数时，和为cnt，可以在第x个平衡树中二分查找离-cnt最近的数</p>
<p>同理也可以转化为n+1对有序列表，进行n+1次双指针。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumDifference</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> sum =  <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0L</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span>&gt;&gt; <span class="built_in">a</span>(n+<span class="number">1</span>), <span class="built_in">b</span>(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;n/<span class="number">2</span>); i++) &#123;</span><br><span class="line">            <span class="type">long</span> cnt = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;&gt;j&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                    cnt += nums[j];</span><br><span class="line">                    w++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt -= nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[w].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;n/<span class="number">2</span>); i++) &#123;</span><br><span class="line">            <span class="type">long</span> cnt = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;&gt;j&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                    cnt += nums[j+n/<span class="number">2</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt -= nums[j+n/<span class="number">2</span>];</span><br><span class="line">                    w++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            b[w].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(a[i].<span class="built_in">begin</span>(), a[i].<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">sort</span>(b[i].<span class="built_in">begin</span>(), b[i].<span class="built_in">end</span>());</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = (<span class="type">int</span>) b[i].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l&lt;a[i].<span class="built_in">size</span>() &amp;&amp; r&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(a[i][l] + b[i][r]));</span><br><span class="line">                <span class="keyword">if</span> (a[i][l] + b[i][r] &gt; <span class="number">0</span>) r--;</span><br><span class="line">                <span class="keyword">else</span> l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>并行课程 II</title>
    <url>/2023/04/09/%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/parallel-courses-ii/">1494. 并行课程 II</a></p>
<hr>
<p>给你一个整数 <code>n</code> 表示某所大学里课程的数目，编号为 <code>1</code> 到 <code>n</code> ，数组 <code>relations</code> 中， <code>relations[i] = [xi, yi]</code>  表示一个先修课的关系，也就是课程 <code>xi</code> 必须在课程 <code>yi</code> 之前上。同时你还有一个整数 <code>k</code> 。</p>
<p>在一个学期中，你 <strong>最多</strong> 可以同时上 <code>k</code> 门课，前提是这些课的先修课在之前的学期里已经上过了。</p>
<p>请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_1.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 4, relations = [[2,1],[3,1],[1,4]], k = 2</span><br><span class="line">输出：3 </span><br><span class="line">解释：上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ，第三个学期上课程 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_2.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2</span><br><span class="line">输出：4 </span><br><span class="line">解释：上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课程 1 ，第四学期上课程 5 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 11, relations = [], k = 2</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 15</code></li>
<li>  <code>1 &lt;= k &lt;= n</code></li>
<li>  <code>0 &lt;= relations.length &lt;= n * (n-1) / 2</code></li>
<li>  <code>relations[i].length == 2</code></li>
<li>  <code>1 &lt;= xi, yi &lt;= n</code></li>
<li>  <code>xi != yi</code></li>
<li>  所有先修关系都是不同的，也就是说 <code>relations[i] != relations[j]</code> 。</li>
<li>题目输入的图是个有向无环图。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先拓扑排序是错的</p>
<p>正解是状压dp</p>
<p>我们可以设计$f_S$为当前学习的课程集合为s时所需要的最小学期。且在求$f_S$时，$f_{Sub}$已经求出，$Sub \in S$.</p>
<p>初始化$f_{0} = 0, f_{i} = INF, i \neq 0$</p>
<p>对于每个$S$枚举它的子集$Sub$，当这个子集$Sub$中的课程数不超过k且不存在先修课的关系($ok_{Sub} = 1$)，另外$Sub$的前导课程$pre_{Sub}$也属于$S$集合中，那么这个集合$S$可以由学习课程集合$S-Sub$的最小学期加一个学期学习课程$Sub$转移，即$f_{S} = min(f_{S}, f_{S-Sub}+1)$</p>
<p>时间复杂度</p>
<p>总共有$2^{n}$个状态，每个状态需要枚举子集。</p>
<p>二进制只含一个1的状态有$n$个，每个状态有$1$个子集。</p>
<p>二进制只含两个1的状态有$C_{n}^{2}$个，每个状态有$2^2$个子集。</p>
<p>…</p>
<p>二进制只含k个1的状态有$C_{n}^{k}$个，每个状态有$2^k$个子集。</p>
<p>总枚举子集的个数是$\sum \limits_{i=0}^{n}C_{n}^{i}2^i = (1+2)^n = 3^n$</p>
<p>所以总时间复杂度为$O(3^n)$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cnt1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;x;x=x&amp;(x<span class="number">-1</span>)) rt++;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberOfSemesters</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; relations, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;<span class="comment">//p[i]课程i的前导课程集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:relations) &#123;</span><br><span class="line">            p[i[<span class="number">1</span>]<span class="number">-1</span>] |= <span class="number">1</span>&lt;&lt;i[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">1</span>&lt;&lt;n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(sz)</span>, <span class="title">ok</span><span class="params">(sz)</span></span>; </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            pre[s] 集合s是每学期学习的不超过k个的课程集合。pre[s]则是学习s这些课程所需要的前置课程。</span></span><br><span class="line"><span class="comment">            ok[s] 说明s中不存在先修课关系，也就是说pre[s]和s没有交集则ok[s] = true</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">            <span class="comment">// assert(__builtin_popcount(i) == cnt1(i));</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cnt1</span>(i)&lt;=k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i&gt;&gt;j&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                        pre[i] |= p[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ok[i] = (pre[i] &amp; i) == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(sz, INF)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> sub = i; sub; sub = i&amp;(sub<span class="number">-1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ok[sub] &amp;&amp; (pre[sub]|i) == i) &#123; <span class="comment">// sub 合法且 pre[sub]属于i</span></span><br><span class="line">                    f[i] = <span class="built_in">min</span>(f[i], f[i^sub]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[sz<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>序列中不同最大公约数的数目</title>
    <url>/2023/04/09/%E5%BA%8F%E5%88%97%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/number-of-different-subsequences-gcds/">1819. 序列中不同最大公约数的数目</a></p>
<hr>
<p>给你一个由正整数组成的数组 <code>nums</code> 。</p>
<p>数字序列的 <strong>最大公约数</strong> 定义为序列中所有整数的共有约数中的最大整数。</p>
<ul>
<li>  例如，序列 <code>[4,6,16]</code> 的最大公约数是 <code>2</code> 。</li>
</ul>
<p>数组的一个 <strong>子序列</strong> 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。</p>
<ul>
<li>  例如，<code>[2,5,10]</code> 是 <code>[1,2,1,**2**,4,1,**5**,**10**]</code> 的一个子序列。</li>
</ul>
<p>计算并返回 <code>nums</code> 的所有 <strong>非空</strong> 子序列中 <strong>不同</strong> 最大公约数的 <strong>数目</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/03/image-1.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [6,10,3]</span><br><span class="line">输出：5</span><br><span class="line">解释：上图显示了所有的非空子序列与各自的最大公约数。</span><br><span class="line">不同的最大公约数为 6 、10 、3 、2 和 1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,15,40,5,6]</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 2 * 10^5</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>数组的取值范围不超过2e5，可以枚举公约数g，然后将在数组中g的倍数求最大公约数，若等于g则可以为答案贡献1。</p>
<p>枚举倍数用筛选法，时间复杂度$O(nlogn)$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDifferentSubsequenceGCDs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mx = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">c</span><span class="params">(mx+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) c[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=mx; i++) &#123;</span><br><span class="line">            <span class="type">int</span> g = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&lt;=mx; j+=i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c[j]) &#123;</span><br><span class="line">                    g = <span class="built_in">gcd</span>(g, j);</span><br><span class="line">                    <span class="keyword">if</span> (g == i) &#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>得到子序列的最少操作次数</title>
    <url>/2023/04/09/%E5%BE%97%E5%88%B0%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/">1713. 得到子序列的最少操作次数</a></p>
<hr>
<p>给你一个数组 <code>target</code> ，包含若干 <strong>互不相同</strong> 的整数，以及另一个整数数组 <code>arr</code> ，<code>arr</code> <strong>可能</strong> 包含重复元素。</p>
<p>每一次操作中，你可以在 <code>arr</code> 的任意位置插入任一整数。比方说，如果 <code>arr = [1,4,1,2]</code> ，那么你可以在中间添加 <code>3</code> 得到 <code>[1,4,**3**,1,2]</code> 。你可以在数组最开始或最后面添加整数。</p>
<p>请你返回 <strong>最少</strong> 操作次数，使得 <code>target</code> 成为 <code>arr</code> 的一个子序列。</p>
<p>一个数组的 <strong>子序列</strong> 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，<code>[2,7,4]</code> 是 <code>[4,**2**,3,**7**,2,1,**4**]</code> 的子序列（加粗元素），但 <code>[2,4,2]</code> 不是子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：target = [5,1,3], arr = [9,4,2,3,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= target.length, arr.length &lt;= 10^5</code></li>
<li>  <code>1 &lt;= target[i], arr[i] &lt;= 10^9</code></li>
<li><code>target</code> 不包含任何重复元素。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>惊喜一遍过。<br>一个类似最长上升子序列的问题</p>
<p>初步思路</p>
<p>求得arr中的一个子序列，该序列也是target中的一个子序列，只要让这个子序列尽可能的长，最后的答案便是用arr的长度减该子序列的长度。</p>
<p>设dp[i] 为arr前i个数中与target的最长公共子序列。</p>
<p>可遍历arr中元素，若当前遍历元素为num，则判断：</p>
<ul>
<li>若num不在target中，则dp[i] = dp[i-1]</li>
<li>若num在target中，要求$dp[i]=之前遍历过的在target中的元素的最大dp值+1=dp[k]+1,k \in [0,i) \wedge k \in target$</li>
</ul>
<p>时间复杂度是O(n^2)</p>
<p>可以采用最长上升子序列的O(nlogn)算法的优化方式。</p>
<p>优化</p>
<p>设<code>dp[i]</code> ，<code>i</code>是<code>target</code>与<code>arr</code>共同的子序列的长度，<code>dp[i]</code>是该长度下的子序列最后一个元素在<code>target</code>中的下标。<code>dp[0]=-1</code>，因为<code>dp[]</code>是升序的，保持升序可以方便用二分查找。</p>
<p>用哈希表<code>map</code>将每个<code>target</code>中的元素映射为各自对应的下标。<br>遍历<code>arr</code>数组，当前元素为<code>num</code>：</p>
<ul>
<li>当<code>num</code>不在<code>map</code>中时，说明该元素不会为增长公共子序列做出贡献。不做处理</li>
<li>当<code>num</code>在<code>map</code>中时，则判断与<code>dp[len]</code>的大小，<code>len</code>是遍历到当前时最长公共子序列长度。<ul>
<li>若<code>dp[len]&lt;map[num]</code>, 在<code>target</code>中当前数字前有<code>len</code>个数字，则最长子序列增长。<code>dp[++len] = map[num]</code></li>
<li>若<code>dp[len]&gt;=map[num]</code>, 不能增长，但是可以某长度的子序列末元素下标，对于相同长度的子序列，最后元素的下标越靠前越好。这里可以采用二分查找，找到第一个大于等于当前<code>map[num]</code>的值然后替换。</li>
</ul>
</li>
</ul>
<p>最后的答案便是<code>target</code>的长度减去<code>len</code>。</p>
<p>时间复杂度$O(nlogn)$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">100005</span>];<span class="comment">//在arr找出一个子序列，该子序列也是target的子序列，长度为i，dp[i]是子序列的最后一个元素在target中的下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; target, vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">-1</span>;<span class="comment">//长度为0，在target中不存在</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;<span class="comment">//将target的元素映射为它自己的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;target.<span class="built_in">size</span>(); i++) mp[target[i]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">count</span>(arr[i])) &#123;<span class="comment">//若该值不属于target则len长度保持不变</span></span><br><span class="line">                <span class="type">int</span> cur = mp[arr[i]];</span><br><span class="line">                <span class="keyword">if</span> (cur&gt;dp[len]) dp[++len] = mp[arr[i]];</span><br><span class="line">                <span class="comment">//dp[] 是升序的，二分查找找到顺序第一个大于等于当前然后替换它。</span></span><br><span class="line">                <span class="comment">//dp[len] &gt;= mp[arr[i]], 二分查找区间[0,len)</span></span><br><span class="line">                <span class="type">int</span> l=<span class="number">0</span>, r=len, m;</span><br><span class="line">                <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">                    m = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dp[m] &gt;= cur) &#123;</span><br><span class="line">                        r = m;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        l = m+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[r] = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target.<span class="built_in">size</span>()-len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>可以用线段树求当前位置之前的最大递增子序列。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        ll val;</span><br><span class="line">    &#125; seg[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(Seg&amp; u, <span class="type">const</span> Seg&amp; l, <span class="type">const</span> Seg&amp; r)</span> </span>&#123;</span><br><span class="line">        u.val = <span class="built_in">max</span>(l.val, r.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">seg_build</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        seg[id].l = l; seg[id].r = r;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            seg[id].val = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// cin &gt;&gt; seg[id].val;</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">seg_build</span>(id&lt;&lt;<span class="number">1</span>, l, m);</span><br><span class="line">        <span class="built_in">seg_build</span>(id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, m+<span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">push_up</span>(seg[id], seg[id&lt;&lt;<span class="number">1</span>], seg[id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">seg_update</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> p, ll val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= seg[id].l &amp;&amp; seg[id].r &lt;= p) &#123;</span><br><span class="line">            seg[id].val = <span class="built_in">max</span>(seg[id].val, val);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = seg[id].l + seg[id].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= m) <span class="built_in">seg_update</span>(id&lt;&lt;<span class="number">1</span>, p, val);</span><br><span class="line">        <span class="keyword">if</span> (m &lt; p) <span class="built_in">seg_update</span>(id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, p, val);</span><br><span class="line">        <span class="built_in">push_up</span>(seg[id], seg[id&lt;&lt;<span class="number">1</span>], seg[id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">seg_query</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= seg[id].l &amp;&amp; seg[id].r &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> seg[id].val;</span><br><span class="line">        &#125;</span><br><span class="line">        ll rt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = seg[id].l + seg[id].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) rt = <span class="built_in">max</span>(rt, <span class="built_in">seg_query</span>(id&lt;&lt;<span class="number">1</span>, l, r));</span><br><span class="line">        <span class="keyword">if</span> (m &lt; r) rt = <span class="built_in">max</span>(rt, <span class="built_in">seg_query</span>(id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, l, r));</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; target, vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;target.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            mp[target[i]] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">seg_build</span>(<span class="number">1</span>, <span class="number">0</span>, target.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> con = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:arr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(i)) &#123;</span><br><span class="line">                <span class="type">int</span> t = <span class="built_in">seg_query</span>(<span class="number">1</span>, <span class="number">0</span>, mp[i]<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">                con = <span class="built_in">max</span>(con, t);</span><br><span class="line">                <span class="built_in">seg_update</span>(<span class="number">1</span>, mp[i], t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target.<span class="built_in">size</span>()-con;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍 IV</title>
    <url>/2023/04/09/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20IV/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/house-robber-iv/">6346. 打家劫舍 IV</a></p>
<hr>
<p>沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。</p>
<p>由于相邻的房屋装有相互连通的防盗系统，所以小偷 <strong>不会窃取相邻的房屋</strong> 。</p>
<p>小偷的 <strong>窃取能力</strong> 定义为他在窃取过程中能从单间房屋中窃取的 <strong>最大金额</strong> 。</p>
<p>给你一个整数数组 <code>nums</code> 表示每间房屋存放的现金金额。形式上，从左起第 <code>i</code> 间房屋中放有 <code>nums[i]</code> 美元。</p>
<p>另给你一个整数数组 <code>k</code> ，表示窃贼将会窃取的 <strong>最少</strong> 房屋数。小偷总能窃取至少 <code>k</code> 间房屋。</p>
<p>返回小偷的 <strong>最小</strong> 窃取能力。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,5,9], k = 2</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">小偷窃取至少 2 间房屋，共有 3 种方式：</span><br><span class="line">- 窃取下标 0 和 2 处的房屋，窃取能力为 max(nums[0], nums[2]) = 5 。</span><br><span class="line">- 窃取下标 0 和 3 处的房屋，窃取能力为 max(nums[0], nums[3]) = 9 。</span><br><span class="line">- 窃取下标 1 和 3 处的房屋，窃取能力为 max(nums[1], nums[3]) = 9 。</span><br><span class="line">因此，返回 min(5, 9, 9) = 5 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,9,3,1], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：共有 7 种窃取方式。窃取能力最小的情况所对应的方式是窃取下标 0 和 4 处的房屋。返回 max(nums[0], nums[4]) = 2 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li>  <code>1 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>1 &lt;= k &lt;= (nums.length + 1)/2</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>设f(x)为偷窃不大于x的且不相邻房屋的最大个数。<br>显然对于f(x)随着x增大而增大。<br>用二分法找到最小的x使得f(x)&gt;=k即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCapability</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">long</span> m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">-2</span>; i&lt;nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]&lt;=m &amp;&amp; j+<span class="number">1</span>&lt;i) cnt++, j = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt&gt;=k) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>拆分数组的最小代价</title>
    <url>/2023/04/09/%E6%8B%86%E5%88%86%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-cost-to-split-an-array/">2547. 拆分数组的最小代价</a></p>
<hr>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>
<p>将数组拆分成一些非空子数组。拆分的 <strong>代价</strong> 是每个子数组中的 <strong>重要性</strong> 之和。</p>
<p>令 <code>trimmed(subarray)</code> 作为子数组的一个特征，其中所有仅出现一次的数字将会被移除。</p>
<ul>
<li>  例如，<code>trimmed([3,1,2,4,3,4]) = [3,4,3,4]</code> 。</li>
</ul>
<p>子数组的 <strong>重要性</strong> 定义为 <code>k + trimmed(subarray).length</code> 。</p>
<ul>
<li>  例如，如果一个子数组是 <code>[1,2,3,3,3,4,4]</code> ，<code>trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4]</code> 。这个子数组的重要性就是 <code>k + 5</code> 。</li>
</ul>
<p>找出并返回拆分 <code>nums</code> 的所有可行方案中的最小代价。</p>
<p><strong>子数组</strong> 是数组的一个连续 <strong>非空</strong> 元素序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,1,2,1,3,3], k = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：将 nums 拆分成两个子数组：[1,2], [1,2,1,3,3]</span><br><span class="line">[1,2] 的重要性是 2 + (0) = 2 。</span><br><span class="line">[1,2,1,3,3] 的重要性是 2 + (2 + 2) = 6 。</span><br><span class="line">拆分的代价是 2 + 6 = 8 ，可以证明这是所有可行的拆分方案中的最小代价。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,1,2,1], k = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：将 nums 拆分成两个子数组：[1,2], [1,2,1] 。</span><br><span class="line">[1,2] 的重要性是 2 + (0) = 2 。</span><br><span class="line">[1,2,1] 的重要性是 2 + (2) = 4 。</span><br><span class="line">拆分的代价是 2 + 4 = 6 ，可以证明这是所有可行的拆分方案中的最小代价。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,1,2,1], k = 5</span><br><span class="line">输出：10</span><br><span class="line">解释：将 nums 拆分成一个子数组：[1,2,1,2,1].</span><br><span class="line">[1,2,1,2,1] 的重要性是 5 + (3 + 2) = 10 。</span><br><span class="line">拆分的代价是 10 ，可以证明这是所有可行的拆分方案中的最小代价。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 1000</code></li>
<li>  <code>0 &lt;= nums[i] &lt; nums.length</code></li>
<li><code>1 &lt;= k &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>不妨设$f_i$为前i个数的最小代价。<br>初始化$f_0 = 0, f_i = INF, i&gt;0$</p>
<p>$f_i = min(f_i, f_j+k+trimmed(nums_{j+1,\dots, i}).length), 0\le j\le i$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    ll f[<span class="number">1005</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mp</span><span class="params">(n)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;<span class="number">0</span>; j--) &#123;</span><br><span class="line">                mp[nums[j<span class="number">-1</span>]]++;</span><br><span class="line">                <span class="keyword">if</span> (mp[nums[j<span class="number">-1</span>]] == <span class="number">1</span>) cnt++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (mp[nums[j<span class="number">-1</span>]] == <span class="number">2</span>) cnt--;</span><br><span class="line">                f[i] = <span class="built_in">min</span>(f[i], f[j<span class="number">-1</span>]+i-j+<span class="number">1</span>-cnt+k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>按位与为零的三元组</title>
    <url>/2023/04/09/%E6%8C%89%E4%BD%8D%E4%B8%8E%E4%B8%BA%E9%9B%B6%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/">982. 按位与为零的三元组</a></p>
<hr>
<p>给你一个整数数组 <code>nums</code> ，返回其中 <strong>按位与三元组</strong> 的数目。</p>
<p><strong>按位与三元组</strong> 是由下标 <code>(i, j, k)</code> 组成的三元组，并满足下述全部条件：</p>
<ul>
<li>  <code>0 &lt;= i &lt; nums.length</code></li>
<li>  <code>0 &lt;= j &lt; nums.length</code></li>
<li>  <code>0 &lt;= k &lt; nums.length</code></li>
<li>  <code>nums[i] &amp; nums[j] &amp; nums[k] == 0</code> ，其中 <code>&amp;</code> 表示按位与运算符。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,1,3]</span><br><span class="line">输出：12</span><br><span class="line">解释：可以选出如下 i, j, k 三元组：</span><br><span class="line">(i=0, j=0, k=1) : 2 &amp; 2 &amp; 1</span><br><span class="line">(i=0, j=1, k=0) : 2 &amp; 1 &amp; 2</span><br><span class="line">(i=0, j=1, k=1) : 2 &amp; 1 &amp; 1</span><br><span class="line">(i=0, j=1, k=2) : 2 &amp; 1 &amp; 3</span><br><span class="line">(i=0, j=2, k=1) : 2 &amp; 3 &amp; 1</span><br><span class="line">(i=1, j=0, k=0) : 1 &amp; 2 &amp; 2</span><br><span class="line">(i=1, j=0, k=1) : 1 &amp; 2 &amp; 1</span><br><span class="line">(i=1, j=0, k=2) : 1 &amp; 2 &amp; 3</span><br><span class="line">(i=1, j=1, k=0) : 1 &amp; 1 &amp; 2</span><br><span class="line">(i=1, j=2, k=0) : 1 &amp; 3 &amp; 2</span><br><span class="line">(i=2, j=0, k=1) : 3 &amp; 2 &amp; 1</span><br><span class="line">(i=2, j=1, k=0) : 3 &amp; 1 &amp; 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：27</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt; 2^16</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用<code>nums[i]&amp;nums[j]</code>的值在2^16内。于是可以用哈希表cnt统计<code>nums[i]&amp;nums[j]</code>出现次数。</p>
<p>最后若<code>i &amp; nums[j]</code>为0，则累加<code>cnt[i]</code>作为最后答案。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">1</span>&lt;&lt;<span class="number">16</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j:nums) &#123;</span><br><span class="line">                cnt[i&amp;j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;(<span class="number">1</span>&lt;&lt;<span class="number">16</span>); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&amp;j) <span class="keyword">continue</span>;</span><br><span class="line">                ans += cnt[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>利用<code>nums[i]&amp;nums[j]</code>的值在2^16内。于是可以用哈希表cnt统计<code>nums[i]&amp;nums[j]</code>出现次数。</p>
<p>枚举<code>nums[i]</code>的补集s的子集sub，累加<code>cnt[sub]</code>即可。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">1</span>&lt;&lt;<span class="number">16</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j:nums) &#123;</span><br><span class="line">                cnt[i&amp;j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = cnt[<span class="number">0</span>]*nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0xffff</span>^i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=s; j; j=s&amp;(j<span class="number">-1</span>)) &#123;</span><br><span class="line">                ans += cnt[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>排列组合</title>
    <url>/2023/01/06/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="计数基本法则"><a href="#计数基本法则" class="headerlink" title="计数基本法则"></a>计数基本法则</h1><p>加法法则</p>
<p>事件A有m中产生方式，事件B有n中产生方式，事件A<strong>或</strong>B有m+n种产生方式</p>
<p>乘法法则</p>
<p>事件A有m中产生方式，事件B有n中产生方式，事件A<strong>与</strong>B有m*n种产生方式</p>
<p>加法法则和乘法法则运用时要注意事件的独立性</p>
<p>减法法则</p>
<p>$A = U - \overline{A}$ </p>
<p>除法法则</p>
<h1 id="排列permutation"><a href="#排列permutation" class="headerlink" title="排列permutation"></a>排列permutation</h1><p>从$n$个<strong>不同</strong>的元素中，取$r$个<strong>不重复</strong>的元素，按<strong>次序</strong>排列，称为从$n$个中取$r$个的无重排列，排列个数用$P(n,r)$表示，或者$P_n^r$。一般不说可重即无重。$(n≥r)$</p>
<p>$p(n,r) = n\times (n-1) \times \cdots \times (n-k+1) = \frac{n!}{(n-r)!}$</p>
<h2 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a><strong>递推关系</strong></h2><p>分步递推，n个球放入r个<strong>有区别</strong>盒子，<strong>考虑第一个盒子有多少种放球方式</strong>，第一个盒子可以放的球有n种方式，当放完第一个盒子后面临着n-1个球放入r-1个盒子。<br>所以$P(n,r) = n*P(n-1,r-1)$，</p>
<p>分类递推，n个球放入r个<strong>有区别</strong>盒子，<strong>考虑第一个球是否选择放入盒子</strong>，如果选择不放入那么面临着n-1个球放入r个盒子，即$P(n-1,r)$；如果第一个球选择放入盒子则有r种放入方式，放完后面临着n-1个球放入r-1个盒子，即$r<em>P(n-1,r-1)$。<br>所以$P(n,r) = P(n-1,r)+r</em>P(n-1, r-1)$</p>
<h2 id="圆排列与项链排列"><a href="#圆排列与项链排列" class="headerlink" title="圆排列与项链排列"></a><strong>圆排列与项链排列</strong></h2><p>n个元素中选r个的圆排列种数有$\frac{P(n,r)}{r}$，圆排列有r种剪断方式变为线排列，$2≤r≤n$</p>
<p>y项链排列与圆排列的区别在于项链排列可以反转，反转后仍然算作同一种排列。所以n个元素中选r个的项链排列种数有$\frac{P(n,r)}{2*r}$</p>
<h1 id="组合combination"><a href="#组合combination" class="headerlink" title="组合combination"></a>组合combination</h1><p>从$n$个<strong>不同</strong>的元素中，取$r$个<strong>不重复</strong>的元素，组成一个子集，不考虑顺序，称为从$n$个中取$r$个的无重组合，排列个数用$C(n,r)$表示，或者$C_n^r$。一般不说可重即无重。$(n≥r)$</p>
<p>r个<strong>无区别</strong>的盒子与r个<strong>有区别</strong>的盒子的差异在于有区别的盒子有r!种排列方式。<br>所以$C(n,r) = \frac{P(n,r)}{r!} = \frac{n!}{r!(n-r)!}$</p>
<h2 id="组合恒等式"><a href="#组合恒等式" class="headerlink" title="组合恒等式"></a>组合恒等式</h2><p>$C(n,r) = C(n,n-r)$，n个球选出r个的组合数正好对应剩余的n-r个球的组合数。</p>
<p>$C(n,l)C(l,r) = C(n,r)C(n-r,l-r)$，现有n个人组成的班级选班干部，共选l人，已选的l人中再选出r人作为核心班干部，那么选取核心班干部的方式有$C(n,l)C(l,r)$种。换一种思路如果直接从n个人中选出核心班干部，剩余的n-r人中应该还要再选出l-r个非核心的班干部，所以有$C(n,r)C(l-r,n-r)$种方式</p>
<p>$C(n,r) = C(n-1,r-1)+C(n-1,r)$，（杨辉三角），格路模型证明<br><strong>格路模型</strong>：如果有一个m行n列个网格从左上角到右下角每次只能向右或向下走一格，有多少种走法。可以将路径看作一个长度为m+n的字符串，字符x代表向右，共有n个x；字符y代表向下，共有m个y。那么走到终点可以认为是m+n个位置中方放置x的方式，即$C(m+n,n)$。也可认为是多重全排列$P(m+n;n,m)$<br>走到终点有两种方式从点$(m-1,n)$或$(m,n-1)$到达$(m,n)$。这时会有$C(m+n-1,n)+ C(m+n-1,n-1)=C(m+n,n)$</p>
<p>$C(n+m,r) = C(n,0)C(m,r)+ C(n,1)C(m,r-1) +\cdots + C(n,r)C(m,0)$，设有n个红球和m个蓝球，选取r个球的组合数，可以从红球种选k个剩余的r-k个可以从蓝球中选取。</p>
<h1 id="多重全排列"><a href="#多重全排列" class="headerlink" title="多重全排列"></a>多重全排列</h1><p>有$n$个元素，总共有$t$类，第$i$类元素有$r_i$个，全排列记为$P(n;r_1,r_2,\cdots,r_t)$</p>
<p>二项式定理的系数似乎就是一个多重全排列</p>
<p>$(a+b)^n = \sum \limits_{k=0}^{n} \frac{n!}{k!(n-k)!}a^{k}b^{n-k} =  \sum \limits_{k=0}^{n} P(n;k,k-1)a^{k}b^{n-k} =  \sum \limits_{k=0}^{n} C(n, k) a^{k}b^{n-k}$ </p>
<p>多项式定理</p>
<p>$(a_1+a_2+\cdots+a_t)^n = \sum \frac{n!}{r_1!r_2!\cdots r_t!}a^{r_1}_1a^{r_2}_2\cdots a^{r_t}_t, \sum r_i = n$</p>
<h1 id="可重排列"><a href="#可重排列" class="headerlink" title="可重排列"></a>可重排列</h1><p>n<strong>种</strong>元素中<strong>有顺序地</strong>取r个可以重复的元素，共有$n^k$种</p>
<h1 id="可重组合"><a href="#可重组合" class="headerlink" title="可重组合"></a>可重组合</h1><p>n<strong>种</strong>元素中取r个可以重复的元素，记$\overline{C}(n,r)$</p>
<p>相当于将r个无区别元素分成n个区域，加入n-1个无区别的隔板，根据多重排列$P(n+r-1;r,n-1) = C(n+r-1,r)$</p>
<p>$x_1+x_2+\cdots+x_n = b$有多少个非负整数解？</p>
<p>相当于n个可重复元素中选b个，相当于将b分到n个区间中，相当于b个无区别元素加入n-1个无区别隔板的多重全排列。</p>
<h1 id="不相邻组合"><a href="#不相邻组合" class="headerlink" title="不相邻组合"></a>不相邻组合</h1><p>n<strong>种</strong>不同的元素选r个<strong>不相邻可重复</strong>的元素。</p>
<p>设选取的不相邻组合为$B={b_0, b_1, \cdots , b_{r-1}}$，且$B$是升序排序的。</p>
<p>我们通过$B$中<strong>每个元素减去对应下标</strong>来构造一个组合$C={b_0, b_1-1, \cdots, b_{r-1}-r+1}$</p>
<p>由于B是不相邻组合，所以每个相邻元素满足$b_i &lt; b_{i+1}-1$，为不等式两边都减去$i$得$b_i-i &lt; b_{i+1}-(i+1)$，即$C_i&lt;C_{i+1}$。因此C是不重复的。</p>
<p>C的最大取值为$n-r+1$，n种元素中选r个不相邻的数的种数对应无重组合数$C(n-r+1，r)$</p>
<h1 id="捆绑法与隔板法"><a href="#捆绑法与隔板法" class="headerlink" title="捆绑法与隔板法"></a>捆绑法与隔板法</h1><p>对于相邻问题用捆绑，对于分区域用隔板</p>
<p><strong>捆绑法</strong></p>
<p>26个英文字母能组成多少个4位数相邻不同字符串，其中b和d不相邻</p>
<p>我们将b和d捆绑在一起，运用减法法则：4位不相邻不重复的种数-4位不相邻不重复且b和d不相邻的种数。</p>
<p>4位不相邻不重复的种数$P(26,4)$</p>
<p>4位不相邻不重复且b和d不相邻的种数，我们可以在非b和d的字母中选出长度为2的排列，然后将捆绑的bd插入到这个排列中，总共有三种插入法且bd位置可互换。所以种数为$P(24,2)<em>3</em>2$</p>
<p>答案为$P(26,4)-P(24,2)*6$</p>
<p><strong>隔板法</strong></p>
<p>共有6个洞，每个洞只能进入一个球，编号为1到9的球进洞的方案有多少？</p>
<p>进洞顺序不同也算不同的方案。我们认为有5个隔板插入到这9个球中，然后求全排列，由于隔板是无差别的，根据多重全排列可以除以隔板个数的全排列。所以答案是$\frac{15!}{5!}$</p>
<h1 id="枚举排列"><a href="#枚举排列" class="headerlink" title="枚举排列"></a>枚举排列</h1><p><strong>字典序法求下一个排列</strong></p>
<p>从右至左找到第一个下降的位置，然后与后面大于它的最小值交换。</p>
<p><strong>SJT算法</strong></p>
<p>设[a1,a2 … aN] 每一项都有向左或向右两个移动方向。</p>
<ol>
<li>初始化所有移动方向向左；</li>
<li>如果移动方向的值比自己小，就可移动；</li>
<li>移动最大的可以动项，在上面例子中就是数字3；</li>
<li>将所有比移动项大的项方向反转，重复第三步，直到不能移动为止。</li>
</ol>
]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>推箱子</title>
    <url>/2023/05/09/%E6%8E%A8%E7%AE%B1%E5%AD%90/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-moves-to-move-a-box-to-their-target-location/">1263. 推箱子</a></p>
<hr>
<p>「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。</p>
<p>游戏地图用大小为 <code>m x n</code> 的网格 <code>grid</code> 表示，其中每个元素可以是墙、地板或者是箱子。</p>
<p>现在你将作为玩家参与游戏，按规则将箱子 <code>&#39;B&#39;</code> 移动到目标位置 <code>&#39;T&#39;</code> ：</p>
<ul>
<li>  玩家用字符 <code>&#39;S&#39;</code> 表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。</li>
<li>  地板用字符 <code>&#39;.&#39;</code> 表示，意味着可以自由行走。</li>
<li>  墙用字符 <code>&#39;#&#39;</code> 表示，意味着障碍物，不能通行。 </li>
<li>  箱子仅有一个，用字符 <code>&#39;B&#39;</code> 表示。相应地，网格上有一个目标位置 <code>&#39;T&#39;</code>。</li>
<li>  玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。</li>
<li>  玩家无法越过箱子。</li>
</ul>
<p>返回将箱子推到目标位置的最小 <strong>推动</strong> 次数，如果无法做到，请返回 <code>-1</code>。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/sample_1_1620.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;T&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]]</span><br><span class="line">输出：3</span><br><span class="line">解释：我们只需要返回推箱子的次数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;T&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;T&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;],</span><br><span class="line">             [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]]</span><br><span class="line">输出：5</span><br><span class="line">解释：向下、向左、向左、向上再向上。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>m == grid.length</code></li>
<li>  <code>n == grid[i].length</code></li>
<li>  <code>1 &lt;= m, n &lt;= 20</code></li>
<li>  <code>grid</code> 仅包含字符 <code>&#39;.&#39;</code>, <code>&#39;#&#39;</code>,  <code>&#39;S&#39;</code> , <code>&#39;T&#39;</code>, 以及 <code>&#39;B&#39;</code>。</li>
<li><code>grid</code> 中 <code>&#39;S&#39;</code>, <code>&#39;B&#39;</code> 和 <code>&#39;T&#39;</code> 各只能出现一个。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们需要箱子到目标点的最小距离，箱子的移动方向有四种但是有些位置的移动方向不可用。</p>
<p>我们注意到每次箱子移动完后，人的位置就代替了之前的箱子的位置。</p>
<p>那么我们可以用状态$f_{x,y,z}$代表箱子在坐标<code>(x,y)</code>位置且人在坐标<code>(x+(z-1)%2, y+(z-2)%2)</code>的最小移动次数。<br>（z取值在0到3，这样人的位置就有4种<code>(x-1,y), (x,y-1), (x+1,y), (x,y+1)</code>）</p>
<p>状态的转移可以用BFS来完成。</p>
<p>我们需要先找到初始状态，也就是人一开始可以在箱子四周的位置个数。然后加入队列。</p>
<p>在队列中每次出队一个状态，我们考虑可以转移到哪些状态：<br>若出队$f_{i,j,z}$，能转移的状态为$f_{i’,j’,z’}$，则$(i’,j’)$是$(i,j)$的四周的一个位置且不能越界，不能为墙。然后$z$和$z’$在不经过$(i,j)$必须连通。</p>
<p>数据范围n最多20，m最多20。<br>总状态数4nm个，每次状态转移方向有4个，每个需要用BFS花$O(nm)$时间来检测连通性。<br>时间复杂度为$O(n^2m^2)$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// i   0  1  2  3</span></span><br><span class="line">    <span class="comment">// i-1 -1 0  1  0</span></span><br><span class="line">    <span class="comment">// i-2 0  -1 0  1</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPushBox</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = g.<span class="built_in">size</span>(), m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> box_x, box_y, peo_x, peo_y, tar_x, tar_y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">                    peo_x = i, peo_y = j, g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">                    box_x = i, box_y = j, g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">                    tar_x = i, tar_y = j, g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i=0; i&lt;n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j=0; j&lt;m; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; g[i][j];</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> p1, <span class="type">int</span> p2) &#123;</span><br><span class="line">            <span class="type">int</span> sx = x+(p1<span class="number">-1</span>)%<span class="number">2</span>, sy = y+(p1<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> tx = x+(p2<span class="number">-1</span>)%<span class="number">2</span>, ty = y+(p2<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sx&lt;<span class="number">0</span> || sx&gt;=n || sy&lt;<span class="number">0</span> || sy&gt;=m || g[sx][sy] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tx&lt;<span class="number">0</span> || tx&gt;=n || ty&lt;<span class="number">0</span> || ty&gt;=m || g[tx][ty] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vis</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">            vis[sx][sy] = <span class="number">1</span>;</span><br><span class="line">            queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">            q.<span class="built_in">emplace</span>(sx, sy);</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [a, b] = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (a == tx &amp;&amp; b == ty) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> ma = a+(i<span class="number">-1</span>)%<span class="number">2</span>, mb = b+(i<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (ma&lt;<span class="number">0</span> || ma&gt;=n || mb&lt;<span class="number">0</span> || mb&gt;=m || ma==x &amp;&amp; mb==y ||</span><br><span class="line">                     g[ma][mb]==<span class="string">&#x27;#&#x27;</span> || vis[ma][mb])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    vis[ma][mb] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(ma, mb);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> get_start = [&amp;]() &#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dis</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, INF));</span><br><span class="line">            dis[peo_x][peo_y] = <span class="number">0</span>;</span><br><span class="line">            queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">            q.<span class="built_in">emplace</span>(peo_x, peo_y);</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [x, y] = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> mx = x+(i<span class="number">-1</span>)%<span class="number">2</span>;</span><br><span class="line">                    <span class="type">int</span> my = y+(i<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mx&lt;<span class="number">0</span> || mx&gt;=n || my&lt;<span class="number">0</span> || my&gt;=m || </span><br><span class="line">                    mx == box_x &amp;&amp; my == box_y || g[mx][my] == <span class="string">&#x27;#&#x27;</span> || dis[mx][my] != INF) </span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    dis[mx][my] = dis[x][y] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(mx, my);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt; rt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> mx = box_x+(i<span class="number">-1</span>)%<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> my = box_y+(i<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (mx&lt;<span class="number">0</span> || mx&gt;=n || my&lt;<span class="number">0</span> || my&gt;=m || g[mx][my] == <span class="string">&#x27;#&#x27;</span> || dis[mx][my] == INF) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                rt.<span class="built_in">emplace_back</span>(box_x, box_y, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rt;</span><br><span class="line">        &#125;;</span><br><span class="line">        queue&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="type">int</span> vis[<span class="number">22</span>][<span class="number">22</span>][<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">auto</span> s = <span class="built_in">get_start</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [i,j,k]: s) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">            q.<span class="built_in">emplace</span>(i,j,k);</span><br><span class="line">            vis[i][j][k] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> stp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> _=<span class="number">0</span>; _&lt;sz; _++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [x, y, z] = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// printf(&quot;x=%d y=%d z=%d stp=%d\n&quot;, x, y, z, stp);</span></span><br><span class="line">                <span class="keyword">if</span> (x == tar_x &amp;&amp; y == tar_y) <span class="keyword">return</span> stp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> mx = x+(i<span class="number">-1</span>)%<span class="number">2</span>;</span><br><span class="line">                    <span class="type">int</span> my = y+(i<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">check</span>(x,y,z,(i+<span class="number">2</span>)%<span class="number">4</span>) || mx&lt;<span class="number">0</span> || mx&gt;=n || my&lt;<span class="number">0</span> || my&gt;=m </span><br><span class="line">                    || g[mx][my] == <span class="string">&#x27;#&#x27;</span>|| vis[mx][my][(i+<span class="number">2</span>)%<span class="number">4</span>]) </span><br><span class="line">                        <span class="keyword">continue</span>; </span><br><span class="line">                    <span class="comment">// printf(&quot;%d,%d, %d,%d, ok=%d, dir:%d\n&quot;, x,y,z,(i+2)%4,check(x,y,z,(i+2)%4),i);</span></span><br><span class="line">                    <span class="comment">// printf(&quot;mx=%d,my=%d %c\n&quot;, mx,my,g[mx][my]);</span></span><br><span class="line">                    vis[mx][my][(i+<span class="number">2</span>)%<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(mx,my,(i+<span class="number">2</span>)%<span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>收集树中金币</title>
    <url>/2023/04/09/%E6%94%B6%E9%9B%86%E6%A0%91%E4%B8%AD%E9%87%91%E5%B8%81/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/collect-coins-in-a-tree/">6356. 收集树中金币</a></p>
<hr>
<p>给你一个 <code>n</code> 个节点的无向无根树，节点编号从 <code>0</code> 到 <code>n - 1</code> 。给你整数 <code>n</code> 和一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间有一条边。再给你一个长度为 <code>n</code> 的数组 <code>coins</code> ，其中 <code>coins[i]</code> 可能为 <code>0</code> 也可能为 <code>1</code> ，<code>1</code> 表示节点 <code>i</code> 处有一个金币。</p>
<p>一开始，你需要选择树中任意一个节点出发。你可以执行下述操作任意次：</p>
<ul>
<li>  收集距离当前节点距离为 <code>2</code> 以内的所有金币，或者</li>
<li>  移动到树中一个相邻节点。</li>
</ul>
<p>你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数。</p>
<p>如果你多次经过一条边，每一次经过都会给答案加一。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/03/01/graph-2.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">输出：2</span><br><span class="line">解释：从节点 2 出发，收集节点 0 处的金币，移动到节点 3 ，收集节点 5 处的金币，然后移动回节点 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/03/02/graph-4.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]</span><br><span class="line">输出：2</span><br><span class="line">解释：从节点 0 出发，收集节点 4 和 3 处的金币，移动到节点 2 处，收集节点 7 处的金币，移动回节点 0 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>n == coins.length</code></li>
<li>  <code>1 &lt;= n &lt;= 3 * 10^4</code></li>
<li>  <code>0 &lt;= coins[i] &lt;= 1</code></li>
<li>  <code>edges.length == n - 1</code></li>
<li>  <code>edges[i].length == 2</code></li>
<li>  <code>0 &lt;= ai, bi &lt; n</code></li>
<li>  <code>ai != bi</code></li>
<li><code>edges</code> 表示一棵合法的树。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先不断去除非金币叶子，这些节点无需访问，去除的方式就是拓扑排序。</p>
<p>剩余的叶子就都是金币，我们从这些节点再次拓扑排序，并记录每个节点的首次访问时间。</p>
<p>显然对于访问时间大于等于2的节点之间所连接的边我们需要访问两次。注意由于是树，所以没有环。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">collectTheCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">deg</span><span class="params">(n)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            deg[i[<span class="number">0</span>]]++;</span><br><span class="line">            deg[i[<span class="number">1</span>]]++;</span><br><span class="line">            g[i[<span class="number">0</span>]].<span class="built_in">push_back</span>(i[<span class="number">1</span>]);</span><br><span class="line">            g[i[<span class="number">1</span>]].<span class="built_in">push_back</span>(i[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deg[i] == <span class="number">1</span> &amp;&amp; coins[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拓扑排序 去除多余非金币叶子</span></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v:g[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--deg[v] == <span class="number">1</span> &amp;&amp; coins[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子都为金币，记录每个节点的访问时间</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deg[i] == <span class="number">1</span> &amp;&amp; coins[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v:g[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--deg[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                    vis[v] = vis[u] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i:vis) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// 统计边数</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i[<span class="number">0</span>]]&gt;=<span class="number">2</span> &amp;&amp; vis[i[<span class="number">1</span>]]&gt;=<span class="number">2</span>) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>放置盒子</title>
    <url>/2023/04/09/%E6%94%BE%E7%BD%AE%E7%9B%92%E5%AD%90/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/building-boxes/">1739. 放置盒子</a></p>
<hr>
<p>有一个立方体房间，其长度、宽度和高度都等于 <code>n</code> 个单位。请你在房间里放置 <code>n</code> 个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：</p>
<ul>
<li>  你可以把盒子放在地板上的任何地方。</li>
<li>  如果盒子 <code>x</code> 需要放置在盒子 <code>y</code> 的顶部，那么盒子 <code>y</code> 竖直的四个侧面都 <strong>必须</strong> 与另一个盒子或墙相邻。</li>
</ul>
<p>给你一个整数 <code>n</code> ，返回接触地面的盒子的 <strong>最少</strong> 可能数量<em>。</em></p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/3-boxes.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：上图是 3 个盒子的摆放位置。</span><br><span class="line">这些盒子放在房间的一角，对应左侧位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/4-boxes.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：上图是 3 个盒子的摆放位置。</span><br><span class="line">这些盒子放在房间的一角，对应左侧位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/10-boxes.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：6</span><br><span class="line">解释：上图是 10 个盒子的摆放位置。</span><br><span class="line">这些盒子放在房间的一角，对应后方位置。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>个人思路二分套二分。<br>用f(x)表示底层放x个盒子最多能堆积的盒子总数。<br>那么我们只需要找到第一个x使得f(x)大于等于n, 那么x就是答案。<br>对于f(x)的计算<br>找到了规律：当有x个盒子在底层，上一层最多有x-r个，其中r是第一个使得r * (r+1) / 2 &gt;= x的数。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    unordered_map&lt;ll, ll&gt; mp;</span><br><span class="line">    <span class="function">ll <span class="title">max_box</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">count</span>(x)) <span class="keyword">return</span> mp[x];</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        ll l = <span class="number">1</span>, r = x+<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            ll m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (m*(m+<span class="number">1</span>)&gt;=<span class="number">2</span>*x) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> l = m+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp[x] = x + <span class="built_in">max_box</span>(x-r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumBoxes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ll l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            ll m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">max_box</span>(m)&gt;=n) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> l = m+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的均值分割</title>
    <url>/2023/04/09/%E6%95%B0%E7%BB%84%E7%9A%84%E5%9D%87%E5%80%BC%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/split-array-with-same-average/">805. 数组的均值分割</a></p>
<hr>
<p>给定你一个整数数组 <code>nums</code></p>
<p>我们要将 <code>nums</code> 数组中的每个元素移动到 <code>A</code> 数组 或者 <code>B</code> 数组中，使得 <code>A</code> 数组和 <code>B</code> 数组不为空，并且 <code>average(A) == average(B)</code> 。</p>
<p>如果可以完成则返回<code>true</code> ， 否则返回 <code>false</code>  。</p>
<p><strong>注意：</strong>对于数组 <code>arr</code> ,  <code>average(arr)</code> 是 <code>arr</code> 的所有元素的和除以 <code>arr</code> 长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7,8]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入: nums = [3,1]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 30</code></li>
<li><code>0 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>折半搜索解决的经典问题。</p>
<p>长度为n=40以内的数组arr选取一些元素使得和为x。可以二进制枚举前n/2个元素的组合，将每个组合的和存入哈希表，然后二进制枚举后n/2个元素的组合，当 x-组合值 在哈希表中存在便找到了两个组合。时间复杂度$O(2^{\frac{n}{2}})$</p>
<p>数组中的值比较小还可以用01背包解决。</p>
<p>这里A数组的平均值和B数组的平均值相等，其实也和整个数组的平均值相等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(a) * len(b) = sum(b) * len(a)</span><br><span class="line">sum(a) * (n-len(a) ) = sum(b)*len(a)</span><br><span class="line">sum(a) * n = (sum(a) + sum(b))*len(a)</span><br><span class="line">sum(a)/len(a) = (sum(a)+sum(b))/n</span><br></pre></td></tr></table></figure>
<p>然后让数组中每个值减去平均值，数组的平均值变为0，只需找到一个子序列的平均值为0那么剩余的数的平均值也是0，平均值为0就是和为0. </p>
<p>这个题对于折半搜索其实并不难理解，但是比较棘手的地方就是两个集合不能有一个是空集合。设我们在左半数组选的数的集合是X，右半数组选的数的集合是Y，</p>
<p>X共有三种状态在左半数组中一个都不选X0，选一部分X1，全选X2。</p>
<p>Y同理有Y0，Y1，Y2。</p>
<p>X和Y中的数将移入到A数组，剩余没选的数移入B数组，A和B不能为空，所以X和Y不能全为空或全选，即X0Y0，X2Y2的组合是不合法的。</p>
<p>所以X和Y的所有状态的组合中只有3 * 3 - 2 = 7种是合法的。</p>
<p>只需判断7钟组合是不是存在和为0即可。</p>
<p>首先我们可以预处理出左半和lsum，右半和rsum。</p>
<p>由于lsum+rsum=0, 所以当lsum=0是rsum也=0，这样就判断完两种状态X2Y0，X0Y2.</p>
<p>二进制枚举左半数组X1状态的子集，可以判断X1Y0，X1Y2是不是和为0</p>
<p>同理右半数组判断X0Y1，X2Y1是不是和为0</p>
<p>最后可以在右半枚举Y1时，查询左半枚举X1的哈希表判断最后一种组合X1Y1和为0的情况。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">splitArraySameAverage</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:nums) i = i*n-s;</span><br><span class="line">        <span class="type">int</span> s1 = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>()+n/<span class="number">2</span>, <span class="number">0</span>), s2 = -s1;</span><br><span class="line">        <span class="keyword">if</span> (s1 == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i+<span class="number">1</span>&lt;<span class="number">1</span>&lt;&lt;n/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;&gt;j&amp;<span class="number">1</span>) cnt += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span> || cnt + s2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            mp[cnt]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i+<span class="number">1</span>&lt;<span class="number">1</span>&lt;&lt;n-n/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n-n/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;&gt;j&amp;<span class="number">1</span>) cnt += nums[j+n/<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span> || cnt + s1 == <span class="number">0</span> || mp.<span class="built_in">count</span>(-cnt)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>无平方子集计数</title>
    <url>/2023/04/09/%E6%97%A0%E5%B9%B3%E6%96%B9%E5%AD%90%E9%9B%86%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/count-the-number-of-square-free-subsets/">6364. 无平方子集计数</a></p>
<hr>
<p>给你一个正整数数组 <code>nums</code> 。</p>
<p>如果数组 <code>nums</code> 的子集中的元素乘积是一个 <strong>无平方因子数</strong> ，则认为该子集是一个 <strong>无平方</strong> 子集。</p>
<p><strong>无平方因子数</strong> 是无法被除 <code>1</code> 之外任何平方数整除的数字。</p>
<p>返回数组 <code>nums</code> 中 <strong>无平方</strong> 且 <strong>非空</strong> 的子集数目。因为答案可能很大，返回对 <code>10^9 + 7</code> 取余的结果。</p>
<p><code>nums</code> 的 <strong>非空子集</strong> 是可以由删除 <code>nums</code> 中一些元素（可以不删除，但不能全部删除）得到的一个数组。如果构成两个子集时选择删除的下标不同，则认为这两个子集不同。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,4,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：示例中有 3 个无平方子集：</span><br><span class="line">- 由第 0 个元素 [3] 组成的子集。其元素的乘积是 3 ，这是一个无平方因子数。</span><br><span class="line">- 由第 3 个元素 [5] 组成的子集。其元素的乘积是 5 ，这是一个无平方因子数。</span><br><span class="line">- 由第 0 个和第 3 个元素 [3,5] 组成的子集。其元素的乘积是 15 ，这是一个无平方因子数。</span><br><span class="line">可以证明给定数组中不存在超过 3 个无平方子集。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br><span class="line">解释：示例中有 1 个无平方子集：</span><br><span class="line">- 由第 0 个元素 [1] 组成的子集。其元素的乘积是 1 ，这是一个无平方因子数。</span><br><span class="line">可以证明给定数组中不存在超过 1 个无平方子集。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 30</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们考虑每个数的质因数分解。<br>如果一个数有两个相同的质因数则说明这个数是非<strong>无平方因子数</strong>。<br><strong>无平方因子数</strong>的质因子每种只有一个，注意到每个数的大小不超过30，30内质数只有10个。</p>
<p>我们用10位二进制数表示一个数质因子出现情况。</p>
<p>$f_{i,j}$为前i个数中选取若干个使得乘积为j的选取种数。</p>
<p>$f_{0,0} = 1$</p>
<p>对于第i个数考虑选和不选。</p>
<p>不选，$f_{i,j}$由$f_{i-1,j}$转移。</p>
<p>选择，当$j \cap mask_i = \varnothing$时，$f_{i,j|mask_i}$由$f_{i-1,j}+1$贡献，$mask_i$是第i个数的质因数集合表示，若存在多个相同的质因数则设置为不存在。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll f[n+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>]; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1024</span>; j++) &#123;</span><br><span class="line">        f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1024</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mask[i<span class="number">-1</span>]&gt;=<span class="number">0</span> &amp;&amp; (j &amp; mask[i<span class="number">-1</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">            f[i][j|mask[i<span class="number">-1</span>]] += f[i<span class="number">-1</span>][j];</span><br><span class="line">            f[i][j|mask[i<span class="number">-1</span>]] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者$f_{i,j}$由$f_{i-1, j-mask_i}+1$转移，$j-mask_i$集合$j$移除集合$mask_i$，也就是说要保证$mask_i \in j$<br>即$f_{i,j} = f_{i-1, j} + f_{i-1, j-mask_i}$，和01背包几乎一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll f[n+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>]; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="comment">// for (int j=0; j&lt;1024; j++) &#123;</span></span><br><span class="line">    <span class="comment">//     f[i][j] = f[i-1][j];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1024</span>; j++) &#123;</span><br><span class="line">        f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (mask[i<span class="number">-1</span>]&gt;=<span class="number">0</span> &amp;&amp; (j | mask[i<span class="number">-1</span>]) == j) &#123;</span><br><span class="line">            f[i][j] += f[i<span class="number">-1</span>][j^mask[i<span class="number">-1</span>]];</span><br><span class="line">            f[i][j] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们用一个二进制数表示集合，当一个集合a是另一个集合b的子集时，所代表的二进制数同样a &lt; b。基于这一点我们可以类似01背包用滚动数组以减小空间复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll f[<span class="number">1</span>&lt;&lt;<span class="number">10</span>]; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1023</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mask[i<span class="number">-1</span>]&gt;=<span class="number">0</span> &amp;&amp; (j | mask[i<span class="number">-1</span>]) == j) &#123;</span><br><span class="line">            f[j] += f[j^mask[i<span class="number">-1</span>]];</span><br><span class="line">            f[j] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后$-1+\sum\limits_{j=0}^{1023}f_{n, j}$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="type">const</span> ll MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">squareFreeSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; p = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>&#125;;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mask</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> ok = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] % (p[j] * p[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    ok = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (nums[i] % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    mask[i] |= <span class="number">1</span>&lt;&lt;j;</span><br><span class="line">                    nums[i] /= p[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ok) mask[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i:mask) cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl;</span></span><br><span class="line">        ll f[n+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;<span class="number">10</span>]; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1024</span>; j++) &#123;</span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1024</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mask[i<span class="number">-1</span>]&gt;=<span class="number">0</span> &amp;&amp; (j &amp; mask[i<span class="number">-1</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j|mask[i<span class="number">-1</span>]] += f[i<span class="number">-1</span>][j];</span><br><span class="line">                    f[i][j|mask[i<span class="number">-1</span>]] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; i++) &#123;</span><br><span class="line">            ans += f[n][i];</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ans<span class="number">-1</span>+MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="type">const</span> ll MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">squareFreeSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; p = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>&#125;;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mask</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> ok = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] % (p[j] * p[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    ok = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (nums[i] % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    mask[i] |= <span class="number">1</span>&lt;&lt;j;</span><br><span class="line">                    nums[i] /= p[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ok) mask[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i:mask) cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl;</span></span><br><span class="line">        ll f[<span class="number">1</span>&lt;&lt;<span class="number">10</span>]; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1023</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mask[i<span class="number">-1</span>]&gt;=<span class="number">0</span> &amp;&amp; (j | mask[i<span class="number">-1</span>]) == j) &#123;</span><br><span class="line">                    f[j] += f[j^mask[i<span class="number">-1</span>]];</span><br><span class="line">                    f[j] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; i++) &#123;</span><br><span class="line">            ans += f[i];</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ans<span class="number">-1</span>+MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>背包dp</tag>
      </tags>
  </entry>
  <entry>
    <title>最大价值和与最小价值和的差值</title>
    <url>/2023/04/09/%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC%E5%92%8C%E4%B8%8E%E6%9C%80%E5%B0%8F%E4%BB%B7%E5%80%BC%E5%92%8C%E7%9A%84%E5%B7%AE%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/">6294. 最大价值和与最小价值和的差值</a></p>
<hr>
<p>给你一个 <code>n</code> 个节点的无向无根图，节点编号为 <code>0</code> 到 <code>n - 1</code> 。给你一个整数 <code>n</code> 和一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间有一条边。</p>
<p>每个节点都有一个价值。给你一个整数数组 <code>price</code> ，其中 <code>price[i]</code> 是第 <code>i</code> 个节点的价值。</p>
<p>一条路径的 <strong>价值和</strong> 是这条路径上所有节点的价值之和。</p>
<p>你可以选择树中任意一个节点作为根节点 <code>root</code> 。选择 <code>root</code> 为根的 <strong>开销</strong> 是以 <code>root</code> 为起点的所有路径中，<strong>价值和</strong> 最大的一条路径与最小的一条路径的差值。</p>
<p>请你返回所有节点作为根节点的选择中，<strong>最大</strong> 的 <strong>开销</strong> 为多少。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/12/01/example14.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]</span><br><span class="line">输出：24</span><br><span class="line">解释：上图展示了以节点 2 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。</span><br><span class="line">- 第一条路径节点为 [2,1,3,4]：价值为 [7,8,6,10] ，价值和为 31 。</span><br><span class="line">- 第二条路径节点为 [2] ，价值为 [7] 。</span><br><span class="line">最大路径和与最小路径和的差值为 24 。24 是所有方案中的最大开销。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/11/24/p1_example2.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1],[1,2]], price = [1,1,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：上图展示了以节点 0 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。</span><br><span class="line">- 第一条路径包含节点 [0,1,2]：价值为 [1,1,1] ，价值和为 3 。</span><br><span class="line">- 第二条路径节点为 [0] ，价值为 [1] 。</span><br><span class="line">最大路径和与最小路径和的差值为 2 。2 是所有方案中的最大开销。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 10^5</code></li>
<li>  <code>edges.length == n - 1</code></li>
<li>  <code>0 &lt;= ai, bi &lt;= n - 1</code></li>
<li>  <code>edges</code> 表示一棵符合题面要求的树。</li>
<li>  <code>price.length == n</code></li>
<li><code>1 &lt;= price[i] &lt;= 10^5</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>求出每个节点u为根的<strong>子树最大路径和</strong>，以及<strong>不含叶子最大路径和</strong>。</p>
<p>在u为根的子树中经过节点u的最大路径和<code>f[u]</code> = u的子节点中最大的路径和+u的子节点中不含叶子的最大的路径和+1，这两条路径不能重叠。</p>
<p>整棵树的最大路径和肯定在某颗u为根的子树中且经过了u，对于所有u求出<code>f[u]</code>最大值即为整棵树的最大路径和。</p>
<p>如何保证求子节点两条路径不重叠？</p>
<p>在u为根的子树中</p>
<p>设<code>x[i]</code>u的第i个儿子的最大路径和</p>
<p>设<code>y[i]</code>u的第i个儿子的不含叶子最大路径和</p>
<p>设<code>s1[i]</code>是遍历u前i个儿子后，得到u子树最大路径和的最大值</p>
<p>设<code>s2[i]</code>是遍历u前i个儿子后，得到u子树不含叶子最大路径和的最大值</p>
<p>在没有儿子时，显然<code>s1[0]=price[u], s2[0]=0</code>。</p>
<p>在遍历第i个儿子时，可更新<code>f[u]</code>的情况：之前最大路径+当前不含叶子最大路径 或 之前不含叶子最大路径+当前最大路径，即<code>s1[i]+x[i]</code>或<code>s2[i]+y[i]</code>。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxOutput</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">int</span>&gt;&amp; price)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; g[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            g[i[<span class="number">0</span>]].<span class="built_in">push_back</span>(i[<span class="number">1</span>]);</span><br><span class="line">            g[i[<span class="number">1</span>]].<span class="built_in">push_back</span>(i[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        function&lt;pair&lt;ll,ll&gt; (<span class="type">int</span>,<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa) -&gt; pair&lt;ll,ll&gt; &#123;</span><br><span class="line">            ll p = price[u];</span><br><span class="line">            ll s1 = price[u], s2 = <span class="number">0</span>;<span class="comment">//无子树时，以u为根最大路径值，不含叶子最大路径值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : g[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == fa) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">auto</span> [x, y] = <span class="built_in">dfs</span>(i, u);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(s1+y, s2+x));</span><br><span class="line">                <span class="comment">//以遍历子树中，以u为根最大路径值，不含叶子最大路径值</span></span><br><span class="line">                s1 = <span class="built_in">max</span>(s1, x+p);</span><br><span class="line">                s2 = <span class="built_in">max</span>(s2, y+p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &#123;s1, s2&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>树型dp</tag>
      </tags>
  </entry>
  <entry>
    <title>最大化城市的最小供电站数目</title>
    <url>/2023/04/09/%E6%9C%80%E5%A4%A7%E5%8C%96%E5%9F%8E%E5%B8%82%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BE%9B%E7%94%B5%E7%AB%99%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/maximize-the-minimum-powered-city/">2528. 最大化城市的最小供电站数目</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始长度为 <code>n</code> 的整数数组 <code>stations</code> ，其中 <code>stations[i]</code> 表示第 <code>i</code> 座城市的供电站数目。</p>
<p>每个供电站可以在一定 <strong>范围</strong> 内给所有城市提供电力。换句话说，如果给定的范围是 <code>r</code> ，在城市 <code>i</code> 处的供电站可以给所有满足 <code>|i - j| &lt;= r</code> 且 <code>0 &lt;= i, j &lt;= n - 1</code> 的城市 <code>j</code> 供电。</p>
<ul>
<li>  <code>|x|</code> 表示 <code>x</code> 的 <strong>绝对值</strong> 。比方说，<code>|7 - 5| = 2</code> ，<code>|3 - 10| = 7</code> 。</li>
</ul>
<p>一座城市的 <strong>电量</strong> 是所有能给它供电的供电站数目。</p>
<p>政府批准了可以额外建造 <code>k</code> 座供电站，你需要决定这些供电站分别应该建在哪里，这些供电站与已经存在的供电站有相同的供电范围。</p>
<p>给你两个整数 <code>r</code> 和 <code>k</code> ，如果以最优策略建造额外的发电站，返回所有城市中，最小供电站数目的最大值是多少。</p>
<p>这 <code>k</code> 座供电站可以建在多个城市。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：stations = [1,2,4,5,0], r = 1, k = 2</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">最优方案之一是把 2 座供电站都建在城市 1 。</span><br><span class="line">每座城市的供电站数目分别为 [1,4,4,5,0] 。</span><br><span class="line">- 城市 0 的供电站数目为 1 + 4 = 5 。</span><br><span class="line">- 城市 1 的供电站数目为 1 + 4 + 4 = 9 。</span><br><span class="line">- 城市 2 的供电站数目为 4 + 4 + 5 = 13 。</span><br><span class="line">- 城市 3 的供电站数目为 5 + 4 = 9 。</span><br><span class="line">- 城市 4 的供电站数目为 5 + 0 = 5 。</span><br><span class="line">供电站数目最少是 5 。</span><br><span class="line">无法得到更优解，所以我们返回 5 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：stations = [4,4,4,4], r = 0, k = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">无论如何安排，总有一座城市的供电站数目是 4 ，所以最优解是 4 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>n == stations.length</code></li>
<li>  <code>1 &lt;= n &lt;= 10^5</code></li>
<li>  <code>0 &lt;= stations[i] &lt;= 10^5</code></li>
<li>  <code>0 &lt;= r &lt;= n - 1</code></li>
<li><code>0 &lt;= k &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>以后遇到 <strong>最大化最小值</strong> 或 <strong>最小化最大值</strong>，优先考虑二分。</p>
<p>在第$i$座城市处的发电站可以作用的城市区间为<code>[i-r, i+r]</code>。因此我们先预处理出代表每个城市的电量的数组$t$。</p>
<p>城市$i$的电量是$\sum \limits_{j = max(0,i-r)}^{min(n-1,i+r)}stations[j]$。<br>我们可以通过求$stations$的前缀数组，在$O(n)$的时间复杂度内求出t数组：令$p[i]$是前i作城市的电量总和，即$p[i] = \sum \limits_{j=0}^{i-1}stations[j]$。这样$t[i] = p[min(n,i+r+1)]-p[max(0, i-r)]$，可以通过一遍遍历求出t数组。</p>
<p>接下来考虑二分答案。</p>
<p>假设通过建造额外的供电站使得所有城市中电力最小值为$x$，设额外的供电站的数量为$f(x)$，$f(x)$是会随着$x$的增大而增大。能够建造的供电站的个数是$k$，显然可以二分法找到最后一个满足的$f(x)&lt;k$的$x$。<br>如果电力最小值为$x$，我们需要尝试构造使得每座城市的电力都至少为x。这个可以用贪心法来构造：如果构造到第$i$座城市的电力小于$x$，即$t[i]&lt;x$。由于构造后保证了前$i-1$座城市的电力都大于等于$x$，那么我们要贪心地让未构造的城市得到更多的电力，因此在第i+r座城市建立$x-t[i]$座城市可以为区间为<code>[i, i+2*r]</code>的城市都增长$x-t[i]$。累加所建电站数量到$f(x)$。</p>
<p>最后如果$f(x)&gt;k$，说明是不满足，缩小二分区间为左半区间。<br>否则如果$f(x)\le k$，说明是满足的，缩小二分区间为右半区间。<br>最后锁定到最后一个满足$f(x)\le k$的x作为答案。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxPower</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; s, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">p</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            p[i] = p[i<span class="number">-1</span>]+s[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;ll&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            t.<span class="built_in">push_back</span>(p[<span class="built_in">min</span>(n, i+r)] - p[<span class="built_in">max</span>(<span class="number">0</span>,i-r<span class="number">-1</span>)]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; t.back() &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sz = t.<span class="built_in">size</span>();</span><br><span class="line">        ll L = <span class="number">0</span>, R = <span class="number">1e15</span>;</span><br><span class="line">        <span class="keyword">while</span> (L&lt;R) &#123;</span><br><span class="line">            ll m = L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(sz)</span></span>;</span><br><span class="line">            ll cnt = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">                pre += d[i];</span><br><span class="line">                <span class="keyword">if</span> (pre+t[i]&lt;m) &#123;</span><br><span class="line">                    cnt += m-pre-t[i];</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">2</span>*r+<span class="number">1</span>&lt;sz) d[i+<span class="number">2</span>*r+<span class="number">1</span>] -= m-pre-t[i];</span><br><span class="line">                    pre += m-pre-t[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; k) &#123;</span><br><span class="line">                R = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                L = m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小体力消耗路径</title>
    <url>/2023/04/09/%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></p>
<hr>
<p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p>
<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>
<p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：heights = [[1,2,2],[3,8,2],[5,3,5]]</span><br><span class="line">输出：2</span><br><span class="line">解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。</span><br><span class="line">这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：heights = [[1,2,3],[3,8,4],[5,3,5]]</span><br><span class="line">输出：1</span><br><span class="line">解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex3.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]</span><br><span class="line">输出：0</span><br><span class="line">解释：上图所示路径不需要消耗任何体力。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>rows == heights.length</code></li>
<li>  <code>columns == heights[i].length</code></li>
<li>  <code>1 &lt;= rows, columns &lt;= 100</code></li>
<li><code>1 &lt;= heights[i][j] &lt;= 10^6</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>二分法。</p>
<p>若d为体力消耗值，则大于d的体力消耗值也能从起点到终点。所以找到最小的使得能从起点到达终点的d便是答案。</p>
<p>可以用dfs或bfs来判断能否从起点能到终点。</p>
<p>时间复杂度$O(m \cdot n \cdot logh)$ n为矩阵的行数，m为矩阵的列数，h为矩阵中的最大值。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g; </span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> vis[<span class="number">104</span>][<span class="number">104</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        vis[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == n<span class="number">-1</span> &amp;&amp; y == m<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> mx = x + (i<span class="number">-1</span>)%<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> my = y + (i<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mx&lt;<span class="number">0</span> || mx&gt;=n || my&lt;<span class="number">0</span> || my&gt;=m || vis[mx][my] || <span class="built_in">abs</span>(g[x][y]-g[mx][my])&gt;d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(mx, my, d)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumEffortPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        n = heights.<span class="built_in">size</span>();</span><br><span class="line">        m = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        g = heights;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e6</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> d = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,d)) &#123;</span><br><span class="line">                r = d;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = d+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>并查集。</p>
<p>类似求最小生成树，可以把矩阵看作一个图，每个格子为图中的节点。相邻格子间存在一条边，边权为格子值之差的绝对值，先把所有边按照边权从小到大排序。再枚举每条边，将边所连接的两个点纳入同一个集合中，并判断起点与终点是否在同一集合，若在则当前所枚举的边权是路径中的最大值。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> st[<span class="number">10005</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ufind</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st[x] &lt; <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> st[x] = <span class="built_in">ufind</span>(st[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">to_id</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x*m+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumEffortPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        n = g.<span class="built_in">size</span>(), m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m*n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; e;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;m; j++) &#123;</span><br><span class="line">                e.<span class="built_in">push_back</span>(&#123;<span class="built_in">abs</span>(g[i][j<span class="number">-1</span>]-g[i][j]), <span class="built_in">to_id</span>(i, j<span class="number">-1</span>), <span class="built_in">to_id</span>(i, j)&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">                e.<span class="built_in">push_back</span>(&#123;<span class="built_in">abs</span>(g[j<span class="number">-1</span>][i]-g[j][i]), <span class="built_in">to_id</span>(j<span class="number">-1</span>, i), <span class="built_in">to_id</span>(j, i)&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">-1</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;e.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">ufind</span>(e[i][<span class="number">1</span>]), y = <span class="built_in">ufind</span>(e[i][<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">                st[x] = y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ufind</span>(<span class="number">0</span>) == <span class="built_in">ufind</span>(n*m<span class="number">-1</span>)) <span class="keyword">return</span> e[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>djkstra</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> dis[<span class="number">10005</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> id, dis;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node&amp; o) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dis &gt; o.dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">to_id</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x*m+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumEffortPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        n = g.<span class="built_in">size</span>(), m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">        dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;Node&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = que.<span class="built_in">top</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (u.id == n*m<span class="number">-1</span>) <span class="keyword">return</span> u.dis;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, x=u.id/m, y = u.id%m; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> dx = x+(i<span class="number">-1</span>)%<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> dy = y+(i<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> id = <span class="built_in">to_id</span>(dx, dy);</span><br><span class="line">                <span class="keyword">if</span> (dx&lt;<span class="number">0</span> || dx&gt;=n || dy&lt;<span class="number">0</span> || dy&gt;=m || dis[id] &lt;= <span class="built_in">max</span>(dis[u.id], <span class="built_in">abs</span>(g[x][y]-g[dx][dy]))) <span class="keyword">continue</span>;</span><br><span class="line">                dis[id] = <span class="built_in">max</span>(dis[u.id], <span class="built_in">abs</span>(g[x][y]-g[dx][dy]));</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;id, dis[id]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小化数对的最大差值</title>
    <url>/2023/04/09/%E6%9C%80%E5%B0%8F%E5%8C%96%E6%95%B0%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/">6359. 最小化数对的最大差值</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>p</code> 。请你从 <code>nums</code> 中找到 <code>p</code> 个下标对，每个下标对对应数值取差值，你需要使得这 <code>p</code> 个差值的 <strong>最大值</strong> <strong>最小</strong>。同时，你需要确保每个下标在这 <code>p</code> 个下标对中最多出现一次。</p>
<p>对于一个下标对 <code>i</code> 和 <code>j</code> ，这一对的差值为 <code>|nums[i] - nums[j]|</code> ，其中 <code>|x|</code> 表示 <code>x</code> 的 <strong>绝对值</strong> 。</p>
<p>请你返回 <code>p</code> 个下标对对应数值 <strong>最大差值</strong> 的 <strong>最小值</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,1,2,7,1,3], p = 2</span><br><span class="line">输出：1</span><br><span class="line">解释：第一个下标对选择 1 和 4 ，第二个下标对选择 2 和 5 。</span><br><span class="line">最大差值为 max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1 。所以我们返回 1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,2,1,2], p = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：选择下标 1 和 3 构成下标对。差值为 |2 - 2| = 0 ，这是最大差值的最小值。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li>  <code>0 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>0 &lt;= p &lt;= (nums.length)/2</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>在排序后，只有选相邻的两个数才能尽可能的让差值小。</p>
<p>假设最大差值的最小值为x，那么我们从左至右贪心的统计差值小于等于x的点对数cnt，如果大于p，说明x还可以增大。<br>当我们找到由小到大找到第一个使得cnt等于p的x便是答案。这可以通过二分查找得到快速找到。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimizeMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        ll l=<span class="number">0</span>, r=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            ll m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i+<span class="number">1</span>&lt;n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i+<span class="number">1</span>]-nums[i]&lt;=m) cnt++,i++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt&gt;=p) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小化旅行的价格总和</title>
    <url>/2023/04/16/%E6%9C%80%E5%B0%8F%E5%8C%96%E6%97%85%E8%A1%8C%E7%9A%84%E4%BB%B7%E6%A0%BC%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/">6378. 最小化旅行的价格总和</a></p>
<hr>
<p>现有一棵无向、无根的树，树中有 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n - 1</code> 编号。给你一个整数 <code>n</code> 和一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>
<p>每个节点都关联一个价格。给你一个整数数组 <code>price</code> ，其中 <code>price[i]</code> 是第 <code>i</code> 个节点的价格。</p>
<p>给定路径的 <strong>价格总和</strong> 是该路径上所有节点的价格之和。</p>
<p>另给你一个二维整数数组 <code>trips</code> ，其中 <code>trips[i] = [starti, endi]</code> 表示您从节点 <code>starti</code> 开始第 <code>i</code> 次旅行，并通过任何你喜欢的路径前往节点 <code>endi</code> 。</p>
<p>在执行第一次旅行之前，你可以选择一些 <strong>非相邻节点</strong> 并将价格减半。</p>
<p>返回执行所有旅行的最小价格总和。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/03/16/diagram2.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]</span><br><span class="line">输出：23</span><br><span class="line">解释：</span><br><span class="line">上图表示将节点 2 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 0 、2 和 3 并使其价格减半后的树。</span><br><span class="line">第 1 次旅行，选择路径 [0,1,3] 。路径的价格总和为 1 + 2 + 3 = 6 。</span><br><span class="line">第 2 次旅行，选择路径 [2,1] 。路径的价格总和为 2 + 5 = 7 。</span><br><span class="line">第 3 次旅行，选择路径 [2,1,3] 。路径的价格总和为 5 + 2 + 3 = 10 。</span><br><span class="line">所有旅行的价格总和为 6 + 7 + 10 = 23 。可以证明，23 是可以实现的最小答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/03/16/diagram3.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">上图表示将节点 0 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 0 并使其价格减半后的树。 </span><br><span class="line">第 1 次旅行，选择路径 [0] 。路径的价格总和为 1 。 </span><br><span class="line">所有旅行的价格总和为 1 。可以证明，1 是可以实现的最小答案。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 50</code></li>
<li>  <code>edges.length == n - 1</code></li>
<li>  <code>0 &lt;= ai, bi &lt;= n - 1</code></li>
<li>  <code>edges</code> 表示一棵有效的树</li>
<li>  <code>price.length == n</code></li>
<li>  <code>price[i]</code> 是一个偶数</li>
<li>  <code>1 &lt;= price[i] &lt;= 1000</code></li>
<li>  <code>1 &lt;= trips.length &lt;= 100</code></li>
<li><code>0 &lt;= starti, endi &lt;= n - 1</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>动态规划</p>
<p>首先需要预处理出每个点需要经过多少次。我们可以通过dfs统计每条线路经过的点<code>i</code>的次数<code>w[i]</code>。</p>
<p>然后我们将图中的某些的点价格减半，最后答案就是$\sum \limits_{i=0}^{n-1} price[i]*w[i]$</p>
<p>现在关键就在于选择哪些点价格减半。</p>
<p>每个点有选与不选两种情况，所以总共有$2^n$种情况，我们可以逐个判断去除选择的相邻的两个数的不合法情况，然后求出合法情况中答案最小的一个。显然在n=50的情况下，$2^50 = 1125899906842624$已经严重超时。</p>
<p>动态规划需要我们需要我们将问题转为同样性质的子问题，通过子问题的解较快地得到原问题的解。</p>
<p>既然它是一颗树，那么我们就可以指定一个点作为根（不妨设0点为根）。这样这棵树就有子问题————子树。</p>
<p>现在我们需要设一个状态，一般问什么就设什么。</p>
<p>这个题要我们求最小价格。所以可以设为每颗子树的最小价格，即<code>f[i]</code>为i节点及其子树的最小价值。</p>
<p>但是，显然这样条件还是不够，因为存在一个不能选相邻的两个节点价格减半的条件。我们的状态似乎缺失了一些信息。这时候添加一个是否选择了当前节点价格减半就可以解决问题，即<code>f[i][j]</code>为i节点价格是否减半（j=0否，j=1是）i节点及其子树的最小价值。</p>
<p>现在就考虑状态转移，也就是子问题与当前问题存在什么样的关系。</p>
<ul>
<li>如果我选择了i节点价格减半，那么i节点的子节点就<strong>一定不能</strong>价格减半，即$f[i][1] = w[i]*price[i]/2+ \sum \limits _{j \in i的子节点}f[j][0]$</li>
<li>如果我没有选择了i节点价格减半，那么i节点的子节点就<strong>可以</strong>价格减半，为了价格更小，所以我们要选择减半和没有减半的状态中的最小值，即$f[i][0] = w[i]*price[i] + \sum \limits _{j \in i的子节点}min(f[j][0], f[j][1])$</li>
</ul>
<p>现在考虑边界状态，也就是最小的子问题，防止无限的递归，这里就是叶子节点作为一颗子树。如果i是叶子，$f[i][1] = w[i]*price[i]/2, f[i][0] = w[i]*price[i]$</p>
<p>最后我们要求的答案就是$min(f[0][0], f[0][1])$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotalPrice</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">int</span>&gt;&amp; price, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; trips)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            g[i[<span class="number">0</span>]].<span class="built_in">push_back</span>(i[<span class="number">1</span>]);</span><br><span class="line">            g[i[<span class="number">1</span>]].<span class="built_in">push_back</span>(i[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(n)</span></span>;</span><br><span class="line">        function&lt;<span class="type">bool</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> ta) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u == ta) &#123;</span><br><span class="line">                w[u]++;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i:g[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == fa) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(i, u, ta)) &#123;</span><br><span class="line">                    w[u]++;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:trips) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i[<span class="number">0</span>], <span class="number">-1</span>, i[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i:w) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="type">int</span> f[n][<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; DP = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> c) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; fa &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (f[u][c] != INF) <span class="keyword">return</span> f[u][c];</span><br><span class="line">            <span class="keyword">if</span> (c) &#123;</span><br><span class="line">                <span class="type">int</span> res = price[u]/<span class="number">2</span>*w[u];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i:g[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == fa) <span class="keyword">continue</span>;</span><br><span class="line">                    res += <span class="built_in">DP</span>(i, u, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> f[u][c] = res;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> res = price[u]*w[u];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i:g[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == fa) <span class="keyword">continue</span>;</span><br><span class="line">                    res += <span class="built_in">min</span>(<span class="built_in">DP</span>(i, u, <span class="number">1</span>), <span class="built_in">DP</span>(i, u, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> f[u][c] = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">DP</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>), <span class="built_in">DP</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>树型dp</tag>
      </tags>
  </entry>
  <entry>
    <title>最小无法得到的或值</title>
    <url>/2023/04/09/%E6%9C%80%E5%B0%8F%E6%97%A0%E6%B3%95%E5%BE%97%E5%88%B0%E7%9A%84%E6%88%96%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-impossible-or/">6360. 最小无法得到的或值</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p>
<p>如果存在一些整数满足 <code>0 &lt;= index1 &lt; index2 &lt; ... &lt; indexk &lt; nums.length</code> ，得到 <code>nums[index1] | nums[index2] | ... | nums[indexk] = x</code> ，那么我们说 <code>x</code> 是 <strong>可表达的</strong> 。换言之，如果一个整数能由 <code>nums</code> 的某个子序列的或运算得到，那么它就是可表达的。</p>
<p>请你返回 <code>nums</code> 不可表达的 <strong>最小非零整数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：1 和 2 已经在数组中，因为 nums[0] | nums[1] = 2 | 1 = 3 ，所以 3 是可表达的。由于 4 是不可表达的，所以我们返回 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,3,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：1 是最小不可表达的数字。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>当出现$2^0, 2^1, \cdots, 2^i$，则$[1,2^{i+1})$都出现过，所以找到第一个没有出现的$2^i$即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minImpossibleOR</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">31</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">count</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">1</span>&lt;&lt;i) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>最小的必要团队</title>
    <url>/2023/04/09/%E6%9C%80%E5%B0%8F%E7%9A%84%E5%BF%85%E8%A6%81%E5%9B%A2%E9%98%9F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/smallest-sufficient-team/">1125. 最小的必要团队</a></p>
<hr>
<p>作为项目经理，你规划了一份需求的技能清单 <code>req_skills</code>，并打算从备选人员名单 <code>people</code> 中选出些人组成一个「必要团队」（ 编号为 <code>i</code> 的备选人员 <code>people[i]</code> 含有一份该备选人员掌握的技能列表）。</p>
<p>所谓「必要团队」，就是在这个团队中，对于所需求的技能列表 <code>req_skills</code> 中列出的每项技能，团队中至少有一名成员已经掌握。可以用每个人的编号来表示团队中的成员：</p>
<ul>
<li>  例如，团队 <code>team = [0, 1, 3]</code> 表示掌握技能分别为 <code>people[0]</code>，<code>people[1]</code>，和 <code>people[3]</code> 的备选人员。</li>
</ul>
<p>请你返回 <strong>任一</strong> 规模最小的必要团队，团队成员用人员编号表示。你可以按 <strong>任意顺序</strong> 返回答案，题目数据保证答案存在。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：req_skills = [&quot;java&quot;,&quot;nodejs&quot;,&quot;reactjs&quot;], people = [[&quot;java&quot;],[&quot;nodejs&quot;],[&quot;nodejs&quot;,&quot;reactjs&quot;]]</span><br><span class="line">输出：[0,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：req_skills = [&quot;algorithms&quot;,&quot;math&quot;,&quot;java&quot;,&quot;reactjs&quot;,&quot;csharp&quot;,&quot;aws&quot;], people = [[&quot;algorithms&quot;,&quot;math&quot;,&quot;java&quot;],[&quot;algorithms&quot;,&quot;math&quot;,&quot;reactjs&quot;],[&quot;java&quot;,&quot;csharp&quot;,&quot;aws&quot;],[&quot;reactjs&quot;,&quot;csharp&quot;],[&quot;csharp&quot;,&quot;math&quot;],[&quot;aws&quot;,&quot;java&quot;]]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= req_skills.length &lt;= 16</code></li>
<li>  <code>1 &lt;= req_skills[i].length &lt;= 16</code></li>
<li>  <code>req_skills[i]</code> 由小写英文字母组成</li>
<li>  <code>req_skills</code> 中的所有字符串 <strong>互不相同</strong></li>
<li>  <code>1 &lt;= people.length &lt;= 60</code></li>
<li>  <code>0 &lt;= people[i].length &lt;= 16</code></li>
<li>  <code>1 &lt;= people[i][j].length &lt;= 16</code></li>
<li>  <code>people[i][j]</code> 由小写英文字母组成</li>
<li>  <code>people[i]</code> 中的所有字符串 <strong>互不相同</strong></li>
<li>  <code>people[i]</code> 中的每个技能是 <code>req_skills</code> 中的技能</li>
<li>题目数据保证「必要团队」一定存在</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>每个人有选与不选，我们需要选尽可能少的人来达到所有需要的技能。</p>
<p>将其转化为01背包问题。<br>可以将每个人的看作物品。背包总容量是所需的技能列表。<br>每个人的所掌握的技能看作物品的体积，每个人的价值是1，需要求让背包装满且价值最小的一种方案。</p>
<p>与以往01背包不同的是这里的背包容量不再是一个数，而是一个集合，而这个集合中元素不超过16，可以用二进制表示。</p>
<p>然后答案是需要构造一个最小人数的序列。人数不超过60，可以用longlong的二进制表示</p>
<p>另外如果人数超过64，我们可以修改一下状态的定义 <code>f[i][j]</code> 前i个人能否拥有j技能最小集合大小，<br>然后逆推<code>f[m][(1&lt;&lt;n)-1]</code>构造一个答案。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestSufficientTeam</span><span class="params">(vector&lt;string&gt;&amp; req_skills, vector&lt;vector&lt;string&gt;&gt;&amp; people)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;req_skills.<span class="built_in">size</span>(); i++) mp[req_skills[i]] = i;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; peo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:people) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; j:i) x |= <span class="number">1</span>&lt;&lt;mp[j];</span><br><span class="line">            peo.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> cntbits = [](ll x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">64</span>;</span><br><span class="line">            <span class="type">int</span> rt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (;x; x=x&amp;(x<span class="number">-1LL</span>)) rt++;</span><br><span class="line">            <span class="keyword">return</span> rt;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> n = req_skills.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = people.<span class="built_in">size</span>();</span><br><span class="line">        ll f[m+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;n]; <span class="comment">// f[i][j] 前i个人拥有j技能集合的一个合法最小人数下标集合</span></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1</span>&lt;&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">cntbits</span>(f[i<span class="number">-1</span>][j&amp;~peo[i<span class="number">-1</span>]]|<span class="number">1LL</span>&lt;&lt;i<span class="number">-1</span>) &gt; <span class="built_in">cntbits</span>(f[i<span class="number">-1</span>][j]))</span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j&amp;~peo[i<span class="number">-1</span>]]|<span class="number">1LL</span>&lt;&lt;i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll u = f[m][(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u&gt;&gt;i&amp;<span class="number">1</span>) rt.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestSufficientTeam</span><span class="params">(vector&lt;string&gt;&amp; req_skills, vector&lt;vector&lt;string&gt;&gt;&amp; people)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;req_skills.<span class="built_in">size</span>(); i++) mp[req_skills[i]] = i;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; peo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:people) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; j:i) x |= <span class="number">1</span>&lt;&lt;mp[j];</span><br><span class="line">            peo.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> cntbits = [](ll x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">64</span>;</span><br><span class="line">            <span class="type">int</span> rt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (;x; x=x&amp;(x<span class="number">-1LL</span>)) rt++;</span><br><span class="line">            <span class="keyword">return</span> rt;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> n = req_skills.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = people.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f[m+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;n]; <span class="comment">// f[i][j] 前i个人能否拥有j技能最小集合大小</span></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1</span>&lt;&lt;n; j++) &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j], f[i<span class="number">-1</span>][j&amp;~peo[i<span class="number">-1</span>]]+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; f[i][j] &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造答案 逆推 f[m][(1&lt;&lt;n)-1] 由谁转移</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rt;</span><br><span class="line">        ll u = m, v = (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (u) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[u][v] == f[u<span class="number">-1</span>][v&amp;~peo[u<span class="number">-1</span>]]+<span class="number">1</span>) v = v&amp;~peo[u<span class="number">-1</span>], rt.<span class="built_in">push_back</span>(u<span class="number">-1</span>);</span><br><span class="line">            u--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>背包dp</tag>
      </tags>
  </entry>
  <entry>
    <title>最小面积矩形 II</title>
    <url>/2023/04/09/%E6%9C%80%E5%B0%8F%E9%9D%A2%E7%A7%AF%E7%9F%A9%E5%BD%A2%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-area-rectangle-ii/">963. 最小面积矩形 II</a></p>
<hr>
<p>给定在 xy 平面上的一组点，确定由这些点组成的任何矩形的最小面积，其中矩形的边<strong>不一定平行于</strong> x 轴和 y 轴。</p>
<p>如果没有任何矩形，就返回 0。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/22/1a.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：[[1,2],[2,1],[1,0],[0,1]]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：最小面积的矩形出现在 [1,2],[2,1],[1,0],[0,1] 处，面积为 2。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/23/2.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：[[0,1],[2,1],[1,1],[1,0],[2,0]]</span><br><span class="line">输出：1.00000</span><br><span class="line">解释：最小面积的矩形出现在 [1,0],[1,1],[2,1],[2,0] 处，面积为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/23/3.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：[[0,3],[1,2],[3,1],[1,3],[2,1]]</span><br><span class="line">输出：0</span><br><span class="line">解释：没法从这些点中组成任何矩形。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/21/4c.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：[[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：最小面积的矩形出现在 [2,1],[2,3],[3,3],[3,1] 处，面积为 2。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li> <code>1 &lt;= points.length &lt;= 50</code></li>
<li> <code>0 &lt;= points[i][0] &lt;= 40000</code></li>
<li> <code>0 &lt;= points[i][1] &lt;= 40000</code></li>
<li> 所有的点都是不同的。</li>
<li>与真实值误差不超过 <code>10^-5</code> 的答案将视为正确结果。</li>
</ol>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>枚举四个不同的点A,B,C,D，若相邻两个点的向量AB与另外两个点的向量CD平行且长度相等，若AB与AC垂直且AB与BD垂直 或者 AB与AD垂直且AB与BC垂直 则形成矩形。计算矩形面积。维护最小即可。时间复杂度$O(n^4)$</p>
<p>优化：</p>
<p>哈希表存储每个点，枚举三个不同点，是否形成直角三角形，再从哈希表中判断第四个点是否存在。时间复杂度$O(n^3)$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function">ll <span class="title">cross</span><span class="params">(ll x1, ll y1, ll x2, ll y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x1*y2 - x2*y1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">mult</span><span class="params">(ll x1, ll y1, ll x2, ll y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x1*x2 + y1*y2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">minAreaFreeRect</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">1e15</span>;</span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:points) &#123;</span><br><span class="line">            mp[i[<span class="number">0</span>]] = i[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=j+<span class="number">1</span>; k&lt;n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == j || i== k) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">auto</span>&amp; pj = points[j], &amp;pi = points[i], &amp;pk = points[k];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">mult</span>(pj[<span class="number">0</span>]-pi[<span class="number">0</span>], pj[<span class="number">1</span>]-pi[<span class="number">1</span>], pk[<span class="number">0</span>]-pi[<span class="number">0</span>], pk[<span class="number">1</span>]-pi[<span class="number">1</span>]) == <span class="number">0</span> </span><br><span class="line">                    &amp;&amp; mp.<span class="built_in">count</span>(pj[<span class="number">0</span>]+pk[<span class="number">0</span>]-pi[<span class="number">0</span>]) &amp;&amp; mp[pj[<span class="number">0</span>]+pk[<span class="number">0</span>]-pi[<span class="number">0</span>]] == pj[<span class="number">1</span>]+pk[<span class="number">1</span>]-pi[<span class="number">1</span>]) &#123;</span><br><span class="line">                        ans = <span class="built_in">min</span>(ans, <span class="built_in">fabs</span>(<span class="built_in">cross</span>(pj[<span class="number">0</span>]-pi[<span class="number">0</span>], pj[<span class="number">1</span>]-pi[<span class="number">1</span>], pk[<span class="number">0</span>]-pi[<span class="number">0</span>], pk[<span class="number">1</span>]-pi[<span class="number">1</span>])));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1e15</span>-ans &lt; <span class="number">1e-5</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>最少侧跳次数</title>
    <url>/2023/04/09/%E6%9C%80%E5%B0%91%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-sideway-jumps/">1824. 最少侧跳次数</a></p>
<hr>
<p>给你一个长度为 <code>n</code> 的 <strong>3 跑道道路</strong> ，它总共包含 <code>n + 1</code> 个 <strong>点</strong> ，编号为 <code>0</code> 到 <code>n</code> 。一只青蛙从 <code>0</code> 号点第二条跑道 <strong>出发</strong> ，它想要跳到点 <code>n</code> 处。然而道路上可能有一些障碍。</p>
<p>给你一个长度为 <code>n + 1</code> 的数组 <code>obstacles</code> ，其中 <code>obstacles[i]</code> （<strong>取值范围从 0 到 3</strong>）表示在点 <code>i</code> 处的 <code>obstacles[i]</code> 跑道上有一个障碍。如果 <code>obstacles[i] == 0</code> ，那么点 <code>i</code> 处没有障碍。任何一个点的三条跑道中 <strong>最多有一个</strong> 障碍。</p>
<ul>
<li>  比方说，如果 <code>obstacles[2] == 1</code> ，那么说明在点 2 处跑道 1 有障碍。</li>
</ul>
<p>这只青蛙从点 <code>i</code> 跳到点 <code>i + 1</code> 且跑道不变的前提是点 <code>i + 1</code> 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 <strong>同一个</strong> 点处 <strong>侧跳</strong> 到 <strong>另外一条</strong> 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。</p>
<ul>
<li>  比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。</li>
</ul>
<p>这只青蛙从点 0 处跑道 <code>2</code> 出发，并想到达点 <code>n</code> 处的 <strong>任一跑道</strong> ，请你返回 <strong>最少侧跳次数</strong> 。</p>
<p><strong>注意</strong>：点 <code>0</code> 处和点 <code>n</code> 处的任一跑道都不会有障碍。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex1.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：obstacles = [0,1,2,3,0]</span><br><span class="line">输出：2 </span><br><span class="line">解释：最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。</span><br><span class="line">注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex2.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：obstacles = [0,1,1,3,3,0]</span><br><span class="line">输出：0</span><br><span class="line">解释：跑道 2 没有任何障碍，所以不需要任何侧跳。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex3.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：obstacles = [0,2,1,0,3,0]</span><br><span class="line">输出：2</span><br><span class="line">解释：最优方案如上图所示。总共有 2 次侧跳。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>obstacles.length == n + 1</code></li>
<li>  <code>1 &lt;= n &lt;= 5 * 10^5</code></li>
<li>  <code>0 &lt;= obstacles[i] &lt;= 3</code></li>
<li><code>obstacles[0] == obstacles[n] == 0</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>动态规划做法<br>可以简单设<code>f[i][j]</code>为第i行j列的最少跳跃次数。<br>为方便实现，用第0列作为哨兵，所以答案是<code>min(f[i][n+1])</code>。</p>
<p>初始<code>f[1][0] = 1</code>。</p>
<p>状态转移 </p>
<p>可以由同一列的非障碍位置侧跳过来<code>f[k][j]+1-&gt;f[i][j], k!=i</code>。</p>
<p>也可以由前一列同一行非障碍位置直跳过来<code>f[i][j-1]-&gt;f[i][j]</code>。</p>
<p>由于同列侧跳有后效性，可以有前一列不同行侧跳过来<code>f[k][j-1]+1-&gt;f[i][j], k!=i</code>。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> f[<span class="number">3</span>][<span class="number">500005</span>]; <span class="comment">//f[i][j] 到达i行j列需要侧跳的最小次数。</span></span><br><span class="line">    <span class="comment">// init f[i][j] = inf, f[1][0] = 0</span></span><br><span class="line">    <span class="comment">// ans min(f[i][n+1])</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSideJumps</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; obstacles)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sz = obstacles.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacles[i<span class="number">-1</span>]) f[obstacles[i<span class="number">-1</span>]<span class="number">-1</span>][i<span class="number">-1</span>] = INF;</span><br><span class="line">            f[<span class="number">0</span>][i] = <span class="built_in">min</span>(&#123;f[<span class="number">0</span>][i<span class="number">-1</span>], f[<span class="number">1</span>][i<span class="number">-1</span>]+<span class="number">1</span>, f[<span class="number">2</span>][i<span class="number">-1</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">            f[<span class="number">1</span>][i] = <span class="built_in">min</span>(&#123;f[<span class="number">0</span>][i<span class="number">-1</span>]+<span class="number">1</span>, f[<span class="number">1</span>][i<span class="number">-1</span>], f[<span class="number">2</span>][i<span class="number">-1</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">            f[<span class="number">2</span>][i] = <span class="built_in">min</span>(&#123;f[<span class="number">0</span>][i<span class="number">-1</span>]+<span class="number">1</span>, f[<span class="number">1</span>][i<span class="number">-1</span>]+<span class="number">1</span>, f[<span class="number">2</span>][i<span class="number">-1</span>]&#125;);</span><br><span class="line">            <span class="keyword">if</span> (obstacles[i<span class="number">-1</span>]) f[obstacles[i<span class="number">-1</span>]<span class="number">-1</span>][i] = INF;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; f[0][i] &lt;&lt; &quot; &quot; &lt;&lt; f[1][i] &lt;&lt; &quot; &quot; &lt;&lt; f[2][i] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(&#123;f[<span class="number">0</span>][sz], f[<span class="number">1</span>][sz], f[<span class="number">2</span>][sz]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>01BFS</p>
<p>建图</p>
<p>对于非障碍位置作为图中点。</p>
<p>当位置<code>(i, j)</code>移动到<code>(i, j+1)</code>时建立权值为0的边</p>
<p>当位置<code>(i, j)</code>移动到<code>(k, j)</code>时建立权值为1的边, <code>i!=k</code>。</p>
<p>这是图中边权不是0就是1，可以用dijkstra算法求出每个点到起点的最短路即可。</p>
<p>但是实际上在如果用01BFS可以更快。</p>
<p><code>dis[i]</code>作为起点到<code>i</code>的最短距离</p>
<p>用双端队列进行BFS，保证队列中每个节点到起点的距离从小到大排序。</p>
<p>对于边权为 0 的边 <code>x→y</code>，如果 <code>dis[x]&lt;dis[y]</code>，更新 <code>dis[y]=dis[x]</code>，把 <code>y</code> 加到队首。由于队首<code>x</code>到起点的距离最小，而<code>y</code>到起点的距离已经于<code>x</code>相等，所以<code>y</code>放队首理应最小。</p>
<p>对于边权为 <code>1</code> 的边 <code>x→y</code>，如果 <code>dis[x]+1&lt;dis[y]</code>，更新 <code>dis[y]=dis[x]+1</code>，把 <code>y</code> 加到队尾。</p>
<p>一个节点第一次出队这个节点到顶点的最短距离就确定了。再次出队不会比之前更优。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSideJumps</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; obstacles)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sz = obstacles.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dis</span>(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(sz, INF));</span><br><span class="line">        dis[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        deque&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace_front</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r,c] = q.<span class="built_in">front</span>(); q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span> (c+<span class="number">1</span>&lt;sz &amp;&amp; obstacles[c+<span class="number">1</span>]<span class="number">-1</span> != r &amp;&amp; dis[r][c+<span class="number">1</span>]&gt;dis[r][c]) &#123;</span><br><span class="line">                dis[r][c+<span class="number">1</span>] = dis[r][c];</span><br><span class="line">                q.<span class="built_in">emplace_front</span>(r,c+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == r || obstacles[c]<span class="number">-1</span> == i || dis[i][c]&lt;=<span class="number">1</span>+dis[r][c]) <span class="keyword">continue</span>;</span><br><span class="line">                dis[i][c] = <span class="number">1</span> + dis[r][c];</span><br><span class="line">                q.<span class="built_in">emplace_back</span>(i, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(&#123;dis[<span class="number">0</span>][sz<span class="number">-1</span>], dis[<span class="number">1</span>][sz<span class="number">-1</span>], dis[<span class="number">2</span>][sz<span class="number">-1</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>最少得分子序列</title>
    <url>/2023/04/09/%E6%9C%80%E5%B0%91%E5%BE%97%E5%88%86%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/subsequence-with-the-minimum-score/">6357. 最少得分子序列</a></p>
<hr>
<p>给你两个字符串 <code>s</code> 和 <code>t</code> 。</p>
<p>你可以从字符串 <code>t</code> 中删除任意数目的字符。</p>
<p>如果没有从字符串 <code>t</code> 中删除字符，那么得分为 <code>0</code> ，否则：</p>
<ul>
<li>  令 <code>left</code> 为删除字符中的最小下标。</li>
<li>  令 <code>right</code> 为删除字符中的最大下标。</li>
</ul>
<p>字符串的得分为 <code>right - left + 1</code> 。</p>
<p>请你返回使 <code>t</code> 成为 <code>s</code> 子序列的最小得分。</p>
<p>一个字符串的 <strong>子序列</strong> 是从原字符串中删除一些字符后（也可以一个也不删除），剩余字符不改变顺序得到的字符串。（比方说 <code>&quot;ace&quot;</code> 是 <code>&quot;***a***b***c***d***e***&quot;</code> 的子序列，但是 <code>&quot;aec&quot;</code> 不是）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abacaba&quot;, t = &quot;bzaa&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：这个例子中，我们删除下标 1 处的字符 &quot;z&quot; （下标从 0 开始）。</span><br><span class="line">字符串 t 变为 &quot;baa&quot; ，它是字符串 &quot;abacaba&quot; 的子序列，得分为 1 - 1 + 1 = 1 。</span><br><span class="line">1 是能得到的最小得分。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cde&quot;, t = &quot;xyz&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：这个例子中，我们将下标为 0， 1 和 2 处的字符 &quot;x&quot; ，&quot;y&quot; 和 &quot;z&quot; 删除（下标从 0 开始）。</span><br><span class="line">字符串变成 &quot;&quot; ，它是字符串 &quot;cde&quot; 的子序列，得分为 2 - 0 + 1 = 3 。</span><br><span class="line">3 是能得到的最小得分。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length, t.length &lt;= 10^5</code></li>
<li><code>s</code> 和 <code>t</code> 都只包含小写英文字母。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>令 left 为删除字符中的最小下标。<br>令 right 为删除字符中的最大下标。<br>删除left到right中所有字符，得分仍然相同，且更容易让t成为s的子序列。</p>
<p>所以我们将题目转化为删除t最小的子串使得成为s的子序列。</p>
<p><code>t[:left-1]</code>在s中的子序列应该越靠前越好。<br><code>t[:right+1]</code>在s中的子序列应该越靠后越好。</p>
<p>我们可以O(n)分别预处理出<br><code>l[i]</code> t中前i个字符在s中最靠前的子序列位置（子序列最后一个字符在s中的位置）<br><code>l[i]</code> t中后i个字符在s中最靠后的子序列位置（子序列第一个字符在s中的位置）<br>若<code>l[x-1]&lt;r[y+1]</code>，则说明删除子串<code>[x,y]</code>可以成为子序列。</p>
<p><code>f(x)</code> 为在t中删除长度为x的子串，能否成为s的子序列。<br>显然x越大越有可能成为。</p>
<p>因此可以二分找到第一个满足<code>f(x) = 1</code>的x。</p>
<p>每次二分时可以通过滑动窗口来判断。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumScore</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = t.<span class="built_in">size</span>(), m = s.<span class="built_in">size</span>();</span><br><span class="line">        t = <span class="string">&quot;0&quot;</span>+t+<span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(n+<span class="number">2</span>, <span class="number">-1</span>)</span>, <span class="title">r</span><span class="params">(n+<span class="number">2</span>, m)</span></span>; <span class="comment">//l[i] 为t[1:i]为s中子序列，t[i]在s中最小位置。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>, p=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p&lt;m &amp;&amp; t[i] != s[p]) p++;</span><br><span class="line">            l[i] = p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n, p=m<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p&gt;=<span class="number">0</span> &amp;&amp; t[i] != s[p]) p--;</span><br><span class="line">            r[i] = p--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, upp = n;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; upp) &#123;</span><br><span class="line">            <span class="type">int</span> mid = low+upp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=mid+<span class="number">1</span>; i&lt;=n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l[i-mid<span class="number">-1</span>] &lt; r[i]) ok = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                upp = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> upp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>最少翻转操作数</title>
    <url>/2023/04/09/%E6%9C%80%E5%B0%91%E7%BF%BB%E8%BD%AC%E6%93%8D%E4%BD%9C%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-reverse-operations/">6365. 最少翻转操作数</a></p>
<hr>
<p>给你一个整数 <code>n</code> 和一个在范围 <code>[0, n - 1]</code> 以内的整数 <code>p</code> ，它们表示一个长度为 <code>n</code> 且下标从 <strong>0</strong> 开始的数组 <code>arr</code> ，数组中除了下标为 <code>p</code> 处是 <code>1</code> 以外，其他所有数都是 <code>0</code> 。</p>
<p>同时给你一个整数数组 <code>banned</code> ，它包含数组中的一些位置。<code>banned</code> 中第 <strong>i</strong> 个位置表示 <code>arr[banned[i]] = 0</code> ，题目保证 <code>banned[i] != p</code> 。</p>
<p>你可以对 <code>arr</code> 进行 <strong>若干次</strong> 操作。一次操作中，你选择大小为 <code>k</code> 的一个 <strong>子数组</strong> ，并将它 <strong>翻转</strong> 。在任何一次翻转操作后，你都需要确保 <code>arr</code> 中唯一的 <code>1</code> 不会到达任何 <code>banned</code> 中的位置。换句话说，<code>arr[banned[i]]</code> 始终 <strong>保持</strong> <code>0</code> 。</p>
<p>请你返回一个数组 <code>ans</code> ，对于 <code>[0, n - 1]</code> 之间的任意下标 <code>i</code> ，<code>ans[i]</code> 是将 <code>1</code> 放到位置 <code>i</code> 处的 <strong>最少</strong> 翻转操作次数，如果无法放到位置 <code>i</code> 处，此数为 <code>-1</code> 。</p>
<ul>
<li>  <strong>子数组</strong> 指的是一个数组里一段连续 <strong>非空</strong> 的元素序列。</li>
<li>  对于所有的 <code>i</code> ，<code>ans[i]</code> 相互之间独立计算。</li>
<li>将一个数组中的元素 <strong>翻转</strong> 指的是将数组中的值变成 <strong>相反顺序</strong> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 4, p = 0, banned = [1,2], k = 4</span><br><span class="line">输出：[0,-1,-1,1]</span><br><span class="line">解释：k = 4，所以只有一种可行的翻转操作，就是将整个数组翻转。一开始 1 在位置 0 处，所以将它翻转到位置 0 处需要的操作数为 0 。</span><br><span class="line">我们不能将 1 翻转到 banned 中的位置，所以位置 1 和 2 处的答案都是 -1 。</span><br><span class="line">通过一次翻转操作，可以将 1 放到位置 3 处，所以位置 3 的答案是 1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 5, p = 0, banned = [2,4], k = 3</span><br><span class="line">输出：[0,-1,-1,-1,-1]</span><br><span class="line">解释：这个例子中 1 一开始在位置 0 处，所以此下标的答案为 0 。</span><br><span class="line">翻转的子数组长度为 k = 3 ，1 此时在位置 0 处，所以我们可以翻转子数组 [0, 2]，但翻转后的下标 2 在 banned 中，所以不能执行此操作。</span><br><span class="line">由于 1 没法离开位置 0 ，所以其他位置的答案都是 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 4, p = 2, banned = [0,1,3], k = 1</span><br><span class="line">输出：[-1,-1,0,-1]</span><br><span class="line">解释：这个例子中，我们只能对长度为 1 的子数组执行翻转操作，所以 1 无法离开初始位置。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 10^5</code></li>
<li>  <code>0 &lt;= p &lt;= n - 1</code></li>
<li>  <code>0 &lt;= banned.length &lt;= n - 1</code></li>
<li>  <code>0 &lt;= banned[i] &lt;= n - 1</code></li>
<li>  <code>1 &lt;= k &lt;= n</code> </li>
<li>  <code>banned[i] != p</code></li>
<li><code>banned</code> 中的值 <strong>互不相同</strong> 。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>在n个数中，有n-k+1个长度为k子数组。对子数组的反转，若子数组中有1，可以将1移动到子数组中对于的对称点。</p>
<p>一个直观的思路就是广搜，从p点作为出发点。然后枚举所有包含当前点u的k长度子数组，u的对称点就是可以转移的点。问题是这个图的边数是$O(n^2)$的。直接广搜会超时</p>
<p>我们进一步观察到无论k是是奇数还是偶数，能转移的点都是只间隔一个点。所以可以按照奇偶性分成两个未遍历点的有序集合，每次广搜转移通过二分查找找到需要删除的范围，然后从集合中删除这个范围内存在的点。</p>
<p>由于广搜每个点都要二分查找所用时间$O(nlogn)$，每个点只会删除一次，对于删除点可以用平衡树或并查集，时间复杂度也是$O(nlogn)$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minReverseOperations</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p, vector&lt;<span class="type">int</span>&gt;&amp; banned, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> st[<span class="number">2</span>][n+<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">-1</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; ufind = [&amp;](<span class="type">int</span> wc, <span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="keyword">return</span> st[wc][x] &lt; <span class="number">0</span> ? x : st[wc][x] = <span class="built_in">ufind</span>(wc, st[wc][x]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> ujoin = [&amp;](<span class="type">int</span> wc, <span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">            st[wc][<span class="built_in">ufind</span>(wc, x)] = <span class="built_in">ufind</span>(wc, y);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ban</span><span class="params">(n)</span>, uban[2], <span class="title">ans</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:banned) ban[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ban[i] || i == p) <span class="keyword">continue</span>;</span><br><span class="line">            uban[i%<span class="number">2</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        uban[<span class="number">0</span>].<span class="built_in">push_back</span>(n);</span><br><span class="line">        uban[<span class="number">1</span>].<span class="built_in">push_back</span>(n);</span><br><span class="line">        ans[p] = <span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(p);</span><br><span class="line">        <span class="type">int</span> stp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">                <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                ans[u] = stp;</span><br><span class="line">                <span class="type">int</span> l = <span class="built_in">max</span>(u-k+<span class="number">1</span>, k<span class="number">-1</span>-u), r = <span class="built_in">min</span>(u+k<span class="number">-1</span>, <span class="number">2</span>*n-k<span class="number">-1</span>-u);</span><br><span class="line">                <span class="keyword">auto</span>&amp; a = uban[l%<span class="number">2</span>];</span><br><span class="line">                <span class="type">int</span> x = <span class="built_in">ufind</span>(l%<span class="number">2</span>, <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(), l)-a.<span class="built_in">begin</span>());</span><br><span class="line">                <span class="keyword">while</span> (a[x]&lt;=r) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(a[x]);</span><br><span class="line">                    st[l%<span class="number">2</span>][x] = <span class="built_in">ufind</span>(l%<span class="number">2</span>, x+<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// ujoin(l%2, x, x+1);</span></span><br><span class="line">                    x = <span class="built_in">ufind</span>(l%<span class="number">2</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平衡树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minReverseOperations</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p, vector&lt;<span class="type">int</span>&gt;&amp; banned, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; st[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            st[i%<span class="number">2</span>].<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        st[p%<span class="number">2</span>].<span class="built_in">erase</span>(p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:banned) st[i%<span class="number">2</span>].<span class="built_in">erase</span>(i);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        ans[p] = <span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(p);</span><br><span class="line">        <span class="type">int</span> stp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            stp++;</span><br><span class="line">            <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">                <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> l = u-k+<span class="number">1</span>, r = u+k<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> (l&lt;<span class="number">0</span>) l = k<span class="number">-1</span>-u;</span><br><span class="line">                <span class="keyword">if</span> (r&gt;=n) r = <span class="number">2</span>*n-k<span class="number">-1</span>-u;</span><br><span class="line">                <span class="keyword">auto</span> itl = st[l%<span class="number">2</span>].<span class="built_in">lower_bound</span>(l);</span><br><span class="line">                <span class="keyword">auto</span> itr = st[l%<span class="number">2</span>].<span class="built_in">upper_bound</span>(r);</span><br><span class="line">                <span class="keyword">while</span> (itl != itr) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((*itl-l)%<span class="number">2</span>) &#123;</span><br><span class="line">                        itl++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(*itl);</span><br><span class="line">                        ans[*itl] = stp;</span><br><span class="line">                        st[l%<span class="number">2</span>].<span class="built_in">erase</span>(itl++);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>最接近目标值的子序列和</title>
    <url>/2023/04/09/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/closest-subsequence-sum/">1755. 最接近目标值的子序列和</a></p>
<hr>
<p>给你一个整数数组 <code>nums</code> 和一个目标值 <code>goal</code> 。</p>
<p>你需要从 <code>nums</code> 中选出一个子序列，使子序列元素总和最接近 <code>goal</code> 。也就是说，如果子序列元素和为 <code>sum</code> ，你需要 <strong>最小化绝对差</strong> <code>abs(sum - goal)</code> 。</p>
<p>返回 <code>abs(sum - goal)</code> 可能的 <strong>最小值</strong> 。</p>
<p>注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,-7,3,5], goal = 6</span><br><span class="line">输出：0</span><br><span class="line">解释：选择整个数组作为选出的子序列，元素和为 6 。</span><br><span class="line">子序列和与目标值相等，所以绝对差为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,-9,15,-2], goal = -5</span><br><span class="line">输出：1</span><br><span class="line">解释：选出子序列 [7,-9,-2] ，元素和为 -4 。</span><br><span class="line">绝对差为 abs(-4 - (-5)) = abs(1) = 1 ，是可能的最小值。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], goal = -7</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 40</code></li>
<li>  <code>-10^7 &lt;= nums[i] &lt;= 10^7</code></li>
<li><code>-10^9 &lt;= goal &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>折半搜索，二分或双指针。</p>
<p>注意到数组大小最多为40</p>
<p>我们枚举左一半长度的数组的所有子序列的和（共2^{n/2}种）存到有序集合a中，然后枚举右一半长度的数组的每个子序列之和x，可以通过在a中二分查找距离goal-x最近的数y，然后维护最小值min(goal-x-y)。时间复杂度O(2^{n/2} * logn)</p>
<p>也可以求出两个子序列集合a，b。然后通过双指针找到离goal最近的两数之和。时间复杂度O(2^{n/2})</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minAbsDifference</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> goal)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a, b;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">abs</span>(goal);</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;n/<span class="number">2</span>); i++) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;&gt;j&amp;<span class="number">1</span>) cnt += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a.<span class="built_in">push_back</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i:st) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;(n+<span class="number">1</span>)/<span class="number">2</span>); i++) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;(n+<span class="number">1</span>)/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;&gt;j&amp;<span class="number">1</span>) cnt += nums[j+n/<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            b.<span class="built_in">push_back</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        a.<span class="built_in">erase</span>(<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        b.<span class="built_in">erase</span>(<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = (<span class="type">int</span>)b.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;a.<span class="built_in">size</span>() &amp;&amp; r&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(a[l]+b[r]-goal));</span><br><span class="line">            <span class="keyword">if</span> (a[l]+b[r]&gt;goal) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>最短公共超序列</title>
    <url>/2023/04/09/%E6%9C%80%E7%9F%AD%E5%85%AC%E5%85%B1%E8%B6%85%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/shortest-common-supersequence/">1092. 最短公共超序列</a></p>
<hr>
<p>给你两个字符串 <code>str1</code> 和 <code>str2</code>，返回同时以 <code>str1</code> 和 <code>str2</code> 作为 <strong>子序列</strong> 的最短字符串。如果答案不止一个，则可以返回满足条件的 <strong>任意一个</strong> 答案。</p>
<p>如果从字符串 <code>t</code> 中删除一些字符（也可能不删除），可以得到字符串 <code>s</code> ，那么 <code>s</code> 就是 t 的一个子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：str1 = &quot;abac&quot;, str2 = &quot;cab&quot;</span><br><span class="line">输出：&quot;cabac&quot;</span><br><span class="line">解释：</span><br><span class="line">str1 = &quot;abac&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 的第一个 &quot;c&quot;得到 &quot;abac&quot;。 </span><br><span class="line">str2 = &quot;cab&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 末尾的 &quot;ac&quot; 得到 &quot;cab&quot;。</span><br><span class="line">最终我们给出的答案是满足上述属性的最短字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：str1 = &quot;aaaaaaaa&quot;, str2 = &quot;aaaaaaaa&quot;</span><br><span class="line">输出：&quot;aaaaaaaa&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= str1.length, str2.length &lt;= 1000</code></li>
<li><code>str1</code> 和 <code>str2</code> 都由小写英文字母组成。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>类似LCS的动态规划</p>
<p>令$f_{i,j}$ 为str1的前i个数和str2的前j个数的最短公共超序列长度。</p>
<p>当$str1_i == str2_j$时，$f_{i,j} = f_{i-1,j-1}+1$</p>
<p>否则，$f_{i,j} = min(f_{i,j-1},f_{i-1,j})+1$</p>
<p>然后根据$f$的状态转移逆推构造出最短公共超序列。</p>
<p>令$ans_{i,j}$ 为str1的前i个数和str2的前j个数的最短公共超序列。</p>
<p>当$str1_i == str2_j$时，$ans_{i,j} = ans_{i-1,j-1}+str1_i$<br>否则，$\begin{array}{ll} ans_{i,j} = ans_{i-1,j}+str1_i &amp; f_{i-1, j}&lt;f_{i,j-1} \ ans_{i,j} = ans_{i,j-1}+str2_j &amp; f_{i-1, j}\ge f_{i,j-1}\end{array}$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def shortestCommonSupersequence(self, str1: str, str2: str) -&gt; str:</span><br><span class="line">        @cache</span><br><span class="line">        def dfs(l:int, r:int)-&gt;int:</span><br><span class="line">            if l&lt;0 : return r+1</span><br><span class="line">            if r&lt;0 : return l+1</span><br><span class="line">            if str1[l] == str2[r] : return dfs(l-1, r-1)+1</span><br><span class="line">            return min(dfs(l-1, r), dfs(l, r-1))+1</span><br><span class="line">        </span><br><span class="line">        def ans(l:int, r:int)-&gt;str:</span><br><span class="line">            if l&lt;0 : return str2[:r+1]</span><br><span class="line">            if r&lt;0 : return str1[:l+1]</span><br><span class="line">            if str1[l] == str2[r] : return ans(l-1, r-1)+str1[l]</span><br><span class="line">            elif dfs(l, r-1) &gt; dfs(l-1, r) : return ans(l-1, r)+str1[l]</span><br><span class="line">            else : return ans(l, r-1)+str2[r]</span><br><span class="line">        return ans(len(str1)-1, len(str2)-1)</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>先求<code>str1</code>和<code>str2</code>的最长公共子序列长度k。</p>
<p>可知<code>sz1+sz2-k</code>是最终构造出来的串的长度。<code>sz1</code>为<code>str1</code>长度，<code>sz2</code>为<code>str2</code>长度。</p>
<p>求最长公共子序列，令<code>dp[i][j]</code>为<code>str1</code>的前<code>i</code>个字符和<code>str2</code>的前<code>j</code>个字符的最长公共子序列长度。</p>
<p>当<code>str1[i-1] != str2[j-1]</code> 时，<code>dp[i][j] = max(dp[l-1][r], dp[l][r-1])</code></p>
<p>当<code>str1[i-1] != str2[j-1]</code> 时，<code>dp[i][j] = dp[l-1][r-1]+1</code></p>
<p>构造字符串。</p>
<p>首先初始化双指针i=sz1, j=sz2</p>
<p>当<code>str1[i-1] == str2[j-1]</code>时, 说明找到了公共字符加入字符串中。</p>
<p>否则，判断<code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code>谁更大就移动对应的i和j指针，并加入所指向字符到字符串。每次选择大的dp值来移动指针可以确保选出k个公共字符。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s1, s2;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">1004</span>][<span class="number">1004</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span> || r == <span class="number">0</span>) <span class="keyword">return</span> dp[l][r] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r]) <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        dp[l][r] = <span class="built_in">max</span>(<span class="built_in">dfs</span>(l<span class="number">-1</span>, r), <span class="built_in">dfs</span>(l, r<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span> (s1[l<span class="number">-1</span>] == s2[r<span class="number">-1</span>]) dp[l][r] = <span class="built_in">max</span>(dp[l][r], <span class="built_in">dfs</span>(l<span class="number">-1</span>, r<span class="number">-1</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">shortestCommonSupersequence</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sz1 = str1.<span class="built_in">size</span>(), sz2 = str2.<span class="built_in">size</span>();</span><br><span class="line">        s1 = str1;</span><br><span class="line">        s2 = str2;</span><br><span class="line">        <span class="comment">// dfs(sz1, sz2);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=sz1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=sz2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i=1; i&lt;=sz1; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j=1; j&lt;=sz2; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="type">int</span> l = sz1, r = sz2;</span><br><span class="line">        string rt;</span><br><span class="line">        <span class="keyword">while</span> (dp[l][r] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1[l<span class="number">-1</span>] == str2[r<span class="number">-1</span>]) &#123;</span><br><span class="line">                rt.<span class="built_in">push_back</span>(str2[r<span class="number">-1</span>]);</span><br><span class="line">                r--; l--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[l<span class="number">-1</span>][r] &gt; dp[l][r<span class="number">-1</span>])&#123;</span><br><span class="line">                rt.<span class="built_in">push_back</span>(str1[--l]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rt.<span class="built_in">push_back</span>(str2[--r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l&gt;<span class="number">0</span>) rt.<span class="built_in">push_back</span>(str1[--l]);</span><br><span class="line">        <span class="keyword">while</span> (r&gt;<span class="number">0</span>) rt.<span class="built_in">push_back</span>(str2[--r]);</span><br><span class="line">        <span class="built_in">reverse</span>(rt.<span class="built_in">begin</span>(), rt.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>LCS</tag>
      </tags>
  </entry>
  <entry>
    <title>最高的广告牌</title>
    <url>/2023/04/09/%E6%9C%80%E9%AB%98%E7%9A%84%E5%B9%BF%E5%91%8A%E7%89%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/tallest-billboard/">956. 最高的广告牌</a></p>
<hr>
<p>你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。</p>
<p>你有一堆可以焊接在一起的钢筋 <code>rods</code>。举个例子，如果钢筋的长度为 <code>1</code>、<code>2</code> 和 <code>3</code>，则可以将它们焊接在一起形成长度为 <code>6</code> 的支架。</p>
<p>返回 <em>广告牌的最大可能安装高度</em> 。如果没法安装广告牌，请返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,6]</span><br><span class="line">输出：6</span><br><span class="line">解释：我们有两个不相交的子集 &#123;1,2,3&#125; 和 &#123;6&#125;，它们具有相同的和 sum = 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：10</span><br><span class="line">解释：我们有两个不相交的子集 &#123;2,3,5&#125; 和 &#123;4,6&#125;，它们具有相同的和 sum = 10。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：[1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：没法安装广告牌，所以返回 0。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li> <code>0 &lt;= rods.length &lt;= 20</code></li>
<li> <code>1 &lt;= rods[i] &lt;= 1000</code></li>
<li><code>sum(rods[i]) &lt;= 5000</code></li>
</ol>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>折半搜索</p>
<p>对于每个支架有三种选择：选择放左边，选择放右边，不选。</p>
<p>总共有n个支架，于是总共有$3^n$种选择情况。n最大为20显然枚举所有情况会超时。</p>
<p>我们可以先枚举前n/2个数的组合情况，并将其存储到哈希表。</p>
<p>然后再枚举后n/2个数的组合情况，并查哈希表是否有对应合法的情况，取最大值即可。</p>
<p>具体做法是，枚举前n/2的组合，哈希表键存储：选取左边支架值的总和-选取右边支架值的总和，值存储：选取左边支架值的总和。</p>
<p>然后枚举后n/2的组合，我们要使得整体左边支架值的总和等于选取右边支架值的总和才是合法情况，说明后n/2个选取左边支架值的总和-选取右边支架值的总和在哈希表中存在相反数则找到一个合法情况。哈希表值存储前n/2个选取左边支架值的总和+当前后n/2个选取左边支架值的总和便是当前广告牌高度</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tallestBillboard</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; rods)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> BASE = <span class="number">5001</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">h</span><span class="params">(<span class="number">2</span>*BASE+<span class="number">5</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = rods.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> a = n/<span class="number">2</span>, b = n-a;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">        <span class="type">int</span> asz = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;a; i++) asz *= <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> bsz = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;b; i++) bsz *= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;asz; i++) &#123;</span><br><span class="line">            <span class="type">int</span> neg = <span class="number">0</span>, pos = <span class="number">0</span>, u = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;a; j++) &#123;</span><br><span class="line">                <span class="type">int</span> s = u%<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="number">0</span>) &#123;</span><br><span class="line">                    neg += rods[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">1</span>) &#123;</span><br><span class="line">                    pos += rods[j];</span><br><span class="line">                &#125; </span><br><span class="line">                u /= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            h[pos-neg+BASE] = <span class="built_in">max</span>(h[pos-neg+BASE], pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;bsz; i++) &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="number">0</span>, neg = <span class="number">0</span>, u = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;b; j++) &#123;</span><br><span class="line">                <span class="type">int</span> s = u%<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="number">0</span>) &#123;</span><br><span class="line">                    neg += rods[j+a];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">1</span>) &#123;</span><br><span class="line">                    pos += rods[j+a];</span><br><span class="line">                &#125; </span><br><span class="line">                u /= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h[neg-pos+BASE] != <span class="number">-1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, pos+h[neg-pos+BASE]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>有界数组中指定下标处的最大值</title>
    <url>/2023/04/09/%E6%9C%89%E7%95%8C%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E4%B8%8B%E6%A0%87%E5%A4%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/">1802. 有界数组中指定下标处的最大值</a></p>
<hr>
<p>给你三个正整数 <code>n</code>、<code>index</code> 和 <code>maxSum</code> 。你需要构造一个同时满足下述所有条件的数组 <code>nums</code>（下标 <strong>从 0 开始</strong> 计数）：</p>
<ul>
<li>  <code>nums.length == n</code></li>
<li>  <code>nums[i]</code> 是 <strong>正整数</strong> ，其中 <code>0 &lt;= i &lt; n</code></li>
<li>  <code>abs(nums[i] - nums[i+1]) &lt;= 1</code> ，其中 <code>0 &lt;= i &lt; n-1</code></li>
<li>  <code>nums</code> 中所有元素之和不超过 <code>maxSum</code></li>
<li>  <code>nums[index]</code> 的值被 <strong>最大化</strong></li>
</ul>
<p>返回你所构造的数组中的 <code>nums[index]</code> 。</p>
<p>注意：<code>abs(x)</code> 等于 <code>x</code> 的前提是 <code>x &gt;= 0</code> ；否则，<code>abs(x)</code> 等于 <code>-x</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 4, index = 2,  maxSum = 6</span><br><span class="line">输出：2</span><br><span class="line">解释：数组 [1,1,2,1] 和 [1,2,2,1] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 6, index = 1,  maxSum = 10</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= maxSum &lt;= 10^9</code></li>
<li><code>0 &lt;= index &lt; n</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>要让<code>nums[index]</code>最大化，然后<code>nums</code>的总和最小，可以贪心地让数组形成以<code>index</code>最大然后向两侧逐渐递减，注意每个值最低不小于1。<br>假设<code>f(x)</code>是当<code>nums[index] = x</code>时的<code>nums</code>总和。显然<code>f(x)</code>单调递增，我们可以用二分法找到最后一个满足<code>f(x)&lt;=maxSum</code>的<code>x</code>。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> index, <span class="type">int</span> maxSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> calc = [&amp;](<span class="type">long</span> x) &#123;</span><br><span class="line">            <span class="type">long</span> l = x-index, r = x-n+<span class="number">1L</span>+index;</span><br><span class="line">            <span class="type">long</span> rt = -x;</span><br><span class="line">            <span class="keyword">if</span> (l&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                rt += (l+x)*(index+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rt += (<span class="number">1</span>+x)*x/<span class="number">2</span>+<span class="number">1</span>-l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                rt += (r+x)*(n-index)/<span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rt += (<span class="number">1</span>+x)*x/<span class="number">2</span>+<span class="number">1</span>-r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rt;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">long</span> l = <span class="number">0</span>, r = maxSum+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">long</span> m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">calc</span>(m)&lt;=maxSum) l = m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>查询数组 Xor 美丽值</title>
    <url>/2023/04/09/%E6%9F%A5%E8%AF%A2%E6%95%B0%E7%BB%84%20Xor%20%E7%BE%8E%E4%B8%BD%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/find-xor-beauty-of-array/">2527. 查询数组 Xor 美丽值</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p>
<p>三个下标 <code>i</code> ，<code>j</code> 和 <code>k</code> 的 <strong>有效值</strong> 定义为 <code>((nums[i] | nums[j]) &amp; nums[k])</code> 。</p>
<p>一个数组的 <strong>xor 美丽值</strong> 是数组中所有满足 <code>0 &lt;= i, j, k &lt; n</code>  <strong>的三元组</strong> <code>(i, j, k)</code> 的 <strong>有效值</strong> 的异或结果。</p>
<p>请你返回 <code>nums</code> 的 xor 美丽值。</p>
<p><strong>注意：</strong></p>
<ul>
<li>  <code>val1 | val2</code> 是 <code>val1</code> 和 <code>val2</code> 的按位或。</li>
<li><code>val1 &amp; val2</code> 是 <code>val1</code> 和 <code>val2</code> 的按位与。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">三元组和它们对应的有效值如下：</span><br><span class="line">- (0,0,0) 有效值为 ((1 | 1) &amp; 1) = 1</span><br><span class="line">- (0,0,1) 有效值为 ((1 | 1) &amp; 4) = 0</span><br><span class="line">- (0,1,0) 有效值为 ((1 | 4) &amp; 1) = 1</span><br><span class="line">- (0,1,1) 有效值为 ((1 | 4) &amp; 4) = 4</span><br><span class="line">- (1,0,0) 有效值为 ((4 | 1) &amp; 1) = 1</span><br><span class="line">- (1,0,1) 有效值为 ((4 | 1) &amp; 4) = 4</span><br><span class="line">- (1,1,0) 有效值为 ((4 | 4) &amp; 1) = 0</span><br><span class="line">- (1,1,1) 有效值为 ((4 | 4) &amp; 4) = 4 </span><br><span class="line">数组的 xor 美丽值为所有有效值的按位异或 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [15,45,20,2,34,35,5,44,32,30]</span><br><span class="line">输出：34</span><br><span class="line">解释：数组的 xor 美丽值为 34 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由于异或的性质<code>a^a=0</code>，对于<code>((nums[i] | nums[j]) &amp; nums[k])</code>和<code>((nums[j] | nums[i]) &amp; nums[k])</code>会抵消，所以只剩下<code>((nums[i] | nums[i]) &amp; nums[j])</code>这种情况。即<code>nums[i] &amp; nums[j]</code>这种情况。</p>
<p>同理<code>nums[i] &amp; nums[j]</code>和<code>nums[j] &amp; nums[i]</code>也会抵消掉，所以只需考虑<code>nums[i] &amp; nums[i]</code>，即<code>nums[i]</code>。</p>
<p>于是将所有数异或起来就是答案。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">xorBeauty</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) ans ^= i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>检查边长度限制的路径是否存在</title>
    <url>/2023/04/09/%E6%A3%80%E6%9F%A5%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/">1697. 检查边长度限制的路径是否存在</a></p>
<hr>
<p>给你一个 <code>n</code> 个点组成的无向图边集 <code>edgeList</code> ，其中 <code>edgeList[i] = [ui, vi, disi]</code> 表示点 <code>ui</code> 和点 <code>vi</code> 之间有一条长度为 <code>disi</code> 的边。请注意，两个点之间可能有 <strong>超过一条边</strong> 。</p>
<p>给你一个查询数组<code>queries</code> ，其中 <code>queries[j] = [pj, qj, limitj]</code> ，你的任务是对于每个查询 <code>queries[j]</code> ，判断是否存在从 <code>pj</code> 到 <code>qj</code> 的路径，且这条路径上的每一条边都 <strong>严格小于</strong> <code>limitj</code> 。</p>
<p>请你返回一个 <strong>布尔数组</strong> <code>answer</code> ，其中 <code>answer.length == queries.length</code> ，当 <code>queries[j]</code> 的查询结果为 <code>true</code> 时， <code>answer</code> 第 <code>j</code> 个值为 <code>true</code> ，否则为 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/19/h.png" alt="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/19/h.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]</span><br><span class="line">输出：[false,true]</span><br><span class="line">解释：上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。</span><br><span class="line">对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。</span><br><span class="line">对于第二个查询，有一条路径（0 -&gt; 1 -&gt; 2）两条边都小于 5 ，所以这个查询我们返回 true 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/19/q.png" alt="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/19/q.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]</span><br><span class="line">输出：[true,false]</span><br><span class="line">解释：上图为给定数据。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= edgeList.length, queries.length &lt;= 10^5</code></li>
<li><code>edgeList[i].length == 3</code></li>
<li><code>queries[j].length == 3</code></li>
<li><code>0 &lt;= ui, vi, pj, qj &lt;= n - 1</code></li>
<li><code>ui != vi</code></li>
<li><code>pj != qj</code></li>
<li><code>1 &lt;= disi, limitj &lt;= 10^9</code></li>
<li>两个点之间可能有 <strong>多条</strong> 边。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>离线操作，将查询的limit按照升序排序。将所有边按照边权升序排序。</p>
<p>接下来用双指针，在遍历查询时将小于当前limit的所有边都纳入到同一个集合。然后检查当前所查询的两个点是否在同一集合即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">distanceLimitedPathsExist</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edgeList, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> st[n]; <span class="built_in">memset</span>(st, <span class="number">-1</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; ufind = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="keyword">return</span> st[x]&lt;<span class="number">0</span>?x:st[x] = <span class="built_in">ufind</span>(st[x]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(edgeList.<span class="built_in">begin</span>(), edgeList.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">2</span>] &lt; y[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> esz = edgeList.<span class="built_in">size</span>(), qsz = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">id</span><span class="params">(qsz)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">ans</span><span class="params">(qsz)</span></span>;</span><br><span class="line">        <span class="built_in">iota</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sort</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> x,<span class="type">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> queries[x][<span class="number">2</span>] &lt; queries[y][<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:id) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; q = queries[i];</span><br><span class="line">            <span class="keyword">while</span> (p&lt;esz &amp;&amp; edgeList[p][<span class="number">2</span>] &lt; q[<span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> x = <span class="built_in">ufind</span>(edgeList[p][<span class="number">0</span>]), y = <span class="built_in">ufind</span>(edgeList[p][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">                    st[x] = y;</span><br><span class="line">                &#125;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = (<span class="built_in">ufind</span>(q[<span class="number">0</span>]) == <span class="built_in">ufind</span>(q[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>母函数</title>
    <url>/2023/01/06/%E6%AF%8D%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h1><p>在数学中，某个序列${\displaystyle (a_{n}){n\in \mathbb {N} }}(a{n})_{n\in \mathbb {N} }$ 的母函数（又称生成函数，英语：Generating function）是一种形式幂级数，其每一项的系数可以提供关于这个序列的信息。</p>
<p>母函数就是一列用来展示一串数字序列的挂衣架。</p>
<p>定义：对于$c_0,c_1,c_2,\dots$ 构造函数$G(x) = c_0+c_1x+c_2x^2+\dots$ 称$G(x)$为序列$c_0,c_1,c_2,\dots$ 的母函数</p>
<hr>
<p>投掷m粒骰子时，加起来点数等于n的方式的数目？</p>
<p>等价于求$G(x) = (x+x^2+x^3+x^4+x^5+x^6)^m$的$x^n$的系数。</p>
<hr>
<p>有1g，2g，3g，4g的砝码，问有多少种重量组合方案。</p>
<p>对于1g砝码有选与不选两种选择，所以可以表示为$x^0+x^1$，以此类推有$x^0+x^2$，$x^0+x^3$，$x^0+x^4$</p>
<p>母函数G(x) =$(1+x)(1+x^2)(1+x^3)(1+x^4)$，展开后不同幂次代表不同重量，系数代表该重量的方案数。</p>
<hr>
<p>将整数n拆分成1，2，… , m的和。求母函数</p>
<p>每个数代表幂次，每个数出现的次数可以是0次，1次，… ，无限次。</p>
<p>$G(x) = (1+x+x^2+x^3+\cdots)(1+x^2+x^4+x^6+\cdots)\cdots(1+x^m+x^{2m}+x^{3m}+\cdots)$</p>
<h1 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h1><p>将一个正整数拆分成若干个<strong>正整数</strong>之和。</p>
<h2 id="有序拆分"><a href="#有序拆分" class="headerlink" title="有序拆分"></a><strong>有序拆分</strong></h2><p>各个部分之间考虑顺序叫做有序拆分（Composition）</p>
<p>数字n拆分成r个正整数之和，有多少种拆分方案？</p>
<p>相当于将n个<strong>无差别</strong>的球放入r个<strong>有标志</strong>区域，每个区域至少一个球。</p>
<p>用隔板法需要r-1个隔板，且隔板应该放入每个球的间隙之间，隔板是无差别的所以应该是$C(n-1,r-1)$</p>
<h2 id="无序拆分"><a href="#无序拆分" class="headerlink" title="无序拆分"></a><strong>无序拆分</strong></h2><p>各个部分不考虑顺序的拆分叫无序拆分（Partition）</p>
<p>把n个无区别的球放到r个无标志的盒子，盒子可以是空的。</p>
<p>$G(x) = (1+x+x^2+x^3+\cdots)(1+x^2+x^4+x^6+\cdots)\cdots(1+x^r+x^{2r}+x^{3r}+\cdots)$，n的拆分个数就是$x^n$的系数。</p>
<p>1出现的母函数$(1+x+x^2+x^3+\cdots)$</p>
<p>2出现的母函数$(1+x^2+x^4+x^6+\cdots)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">cnt = [<span class="number">1</span>]*(x+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, x+<span class="number">1</span>):</span><br><span class="line">    c = [<span class="number">0</span>]*(x+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, x+<span class="number">1</span>, i):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j, x+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># print(i+1, j, k)</span></span><br><span class="line">            c[k]+=cnt[k-j];</span><br><span class="line">    cnt = c</span><br><span class="line">    <span class="comment"># for i, j in enumerate(cnt):</span></span><br><span class="line">    <span class="comment">#     print(&quot;cnt[&#123;&#125;]=&#123;&#125;&quot;.format(i, j), end= &#x27; &#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;可拆分方案数为&#123;&#125;&quot;</span>.<span class="built_in">format</span>(x, cnt[x]))</span><br></pre></td></tr></table></figure>

<h2 id="Ferrers图像"><a href="#Ferrers图像" class="headerlink" title="Ferrers图像"></a><strong>Ferrers图像</strong></h2><p>整数n拆分成最大数为k的拆分数，和数n拆分成k个数的和的拆分数相等。</p>
<p>整数n拆分成最多不超过m个数的和的拆分数，和数n拆分最大不超过的拆分数相等。</p>
<p>奇数个拆分只有一种图像</p>
<h1 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h1><p>母函数可作为<strong>递推公式</strong>和<strong>通项公式</strong>的<strong>桥梁</strong></p>
<p>现有编号$A$、$B$和$C$三根柱子，有$n$个中空盘子在$A$柱子上，盘子大小互不相同从小到大依次排列，每次只能移动最上面的盘子且移动后要保证小盘子在大盘子上。</p>
<p>现在需要将$A$柱子上的$n$个盘子移动到$C$上，三步走，首先移动$n-1$个盘到$B$柱子上，然后将最后一个盘子移动到$C$上，最后将$B$上的$n-1$个盘子移动到$C$上。</p>
<p>我们设移动$n$个盘子到另一根柱子上需要$f(n)$步，根据三步走有递推公式$f(i) = 2 * f(i-1) + 1,f(0) = 0$。</p>
<p>构造母函数$G(x) = f(0) + f(1)x + f(2)x^2 + f(3)x^3 + \cdots$</p>
<p>这时候我们要$f(n)$就只要求出$x^n$的系数即可。</p>
<p>将递推公式带入$G(x)$可得</p>
<p>$G(x) = (2f(0)+1)x+(2f(1)+1)x^2+(2f(2)+1)x^3+\cdots$</p>
<p>$G(x) = 2x(f(0)+f(1)x+f(2)x^2+\cdots) + x + x^2 + x^3 + \cdots$</p>
<p>$G(x) = 2xG(x) + x+ x^2 + x^3 + \cdots$</p>
<p>根据泰勒公式</p>
<p>$G(x) = 2xG(x) + \frac{1}{1-x}-1$</p>
<p>$G(x) = \frac{x}{(1-2x)(1-x)} = \frac{1}{1-2x} - \frac{1}{1-x} = (1+2x+ 2^2x^2 + 2^3x^3 + \cdots)-(1+x+ x^2 + x^3 + \cdots)=\sum \limits_{i=0}^{\infty} (2^i-1)x^i$</p>
<h1 id="出现偶数次数5的n位10进制数"><a href="#出现偶数次数5的n位10进制数" class="headerlink" title="出现偶数次数5的n位10进制数"></a>出现偶数次数5的n位10进制数</h1><p>给出一个长度位n的10进制数，问出现5的次数是偶数的个数有多少?不能有前导零。</p>
<p>用动态规划的思想寻找子问题。</p>
<p>考虑前i个数以5结尾和非5结尾的个数有多少个。</p>
<p>设$a_i$前$i$位偶数个5的个数，$b_i$前$i$位奇数个5的个数。</p>
<p>从显然对于长度为1的偶数个5的情况是不包含5，但也不能是前导0，所以$a_1 = 8$，对于长度为1的奇数个5的情况就是选择5，$b_i = 1$</p>
<p>对于$a_i$的求解考虑第i位是否为5，如果是5那么前i-1为应该为奇数个5；如果不是5那么前i-1位应该为偶数个5，即$a_i = 9*a_{i-1}+b_{i-1}$</p>
<p>对于$b_i$同理可得$b_i = 9*b_{i-1}+a_{i-1}$</p>
<p>我们得到了两个相互依赖的递推式</p>
<p>设母函数</p>
<p>$A(x) = a_1+a_2x+a_3x^2+\cdots$</p>
<p>$B(x) = b_1+b_2x+b_3x^2+\cdots$</p>
<p>对于每个系数$a_i,b_i,i&gt;1$都带入递推式，整理后得到</p>
<p>$A(x) = 8 + x(9A(x) + B(x))$</p>
<p>$B(x) = 1 + x(9B(x) + A(x))$</p>
<p>联立方程组求得$A(x) = \frac{8-71x}{(1-10x)(1-8x)} = \frac{1}{2}(\frac{9}{1-10x}+\frac{7}{1-8x}) = \sum \limits_{i=0}^{\infty}(\frac{9\cdot10^i+7\cdot8^i}{2})x^{i}$</p>
<p>$a_i = \frac{9\cdot10^{i-1}+7\cdot8^{i-1}}{2}$</p>
<h1 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h1><p>$F_i = F_{i-1} + F_{i-2} , i&gt;2$</p>
<p>$F_1 = F_2 = 1$</p>
<p>a母函数法求$F_i$，构造母函数$G(x) = F_1x+F_2x^2+\cdots+F_ix^i+\cdots$</p>
<p>$G(x) = x + xG(x)+x^2G(x)$</p>
<p>$G(x) = \frac{x}{1-x-x^2}$</p>
<p>由于需要利用$\frac{1}{1-x}$的泰勒展开，我们将分母因式分解为形如$(1-ax)(1-bx)$的形式。</p>
<p>$1^2-x+\frac{x^2}{4}-\frac{5x^2}{4}=(1-\frac{x}{2})^2-(\frac{\sqrt5x}{2})^2=(1-\frac{1+\sqrt5}{2}x)(1-\frac{1-\sqrt5}{2}x)$</p>
<p>因此$G(x) = \frac{x}{(1-\frac{1+\sqrt5}{2}x)(1-\frac{1-\sqrt5}{2}x)}$</p>
<p>设$a = \frac{1+\sqrt5}{2}$，$b=\frac{1-\sqrt5}{2}$</p>
<p>y用待定系数法将$G(x)$拆为两项$G(x) = \frac{x}{(1-ax)(1-bx)} = \frac{A}{1-ax} + \frac{B}{1-bx} = \frac{A(1-bx)+B(1-ax)}{(1-ax)(1-bx)} = \frac{-(Ab+Ba)x+A+B}{(1-ax)(1-bx)}$，可知$-(Ab+Ba) = 1, A+B = 0$，解得$A=\frac{1}{\sqrt5}, B = -\frac{1}{\sqrt5}$</p>
<p>$G(x) = \frac{1}{\sqrt5}(\frac{1}{1-ax}-\frac{1}{1-bx})=\sum \limits_{i=0}^{\infty} \frac{1}{\sqrt5}(a^i-b^i)x^i=\sum \limits_{i=0}^{\infty} \frac{1}{\sqrt5}((\frac{1+\sqrt5}{2})^i-(\frac{1-\sqrt5}{2})^i)x^i$</p>
<p>so $F_i = \frac{1}{\sqrt5}((\frac{1+\sqrt5}{2})^i-(\frac{1-\sqrt5}{2})^i)$</p>
<p>Fibonacci<strong>恒等式</strong></p>
<p>$F_1^2+F_2^2+F_3^2+\cdots+F_n^2 = F_nF_{n+1}$</p>
<p>右侧有$F_{n+1}$，左侧没有需要凑出一个$F_{n+1}$且是正数</p>
<p>对每一项$F_i$替换为$F_{i+1}-F_{i-1}$，得到：</p>
<p>$F_1^2+F_2(F_3-F_1)+\cdots+F_n(F_{n+1}-F_{n-1})=F_nF_{n+1}$</p>
<hr>
<p>$F_1+F_2+F_3+\cdots+F_n = F_{n+2}-1$</p>
<p>右侧有$F_{n+2}$，将$F_n$替换为$F_{n+2}-F_{n+1}$</p>
<hr>
<h1 id="线性常系数齐次递推关系"><a href="#线性常系数齐次递推关系" class="headerlink" title="线性常系数齐次递推关系"></a>线性常系数齐次递推关系</h1><p>若序列${a_n}$满足</p>
<p>$a_n + c_1a_{n-1} + c_2a_{n-2} + \cdots + c_ka_{n-k} = 0$</p>
<p>$a_i = d_i, 0≤i&lt;k,$ $d_i$为常数</p>
<p>则${a_n}$为<strong>k阶线性常系数齐次</strong>递推关系。</p>
<h1 id="特征多项式求解递推关系"><a href="#特征多项式求解递推关系" class="headerlink" title="特征多项式求解递推关系"></a>特征多项式求解递推关系</h1><p>${a_n}$为k阶线性常系数齐次递推关系</p>
<p>$a_n + c_1a_{n-1} + c_2a_{n-2} + \cdots + c_ka_{n-k} = 0$</p>
<p>特征多项式为$C(x) = x^k+c_1x^{k-1}+c_2x^{k-2}+\cdots+c_k=(x-\alpha_1)(x-\alpha_2)\cdots(x-\alpha_k)=0$</p>
<p><strong>当$C(x)$无重根</strong></p>
<p>$G(x)$可化为$G(x) = \frac{l_1}{1-\alpha_1x} + \frac{l_2}{1-\alpha_2x} + \cdots + \frac{l_k}{1-\alpha_kx}=\sum \limits ^{k}_{i=1} \frac{l_i}{1-\alpha_i x}$，$l_i$是待定系数</p>
<p>通过泰勒公式展开，$x^n$的系数就是我们要求的$a_n$，即 $a_n = \sum \limits_{i=1}^{k} l_i\alpha_i^n$</p>
<p>已知${a_n}$的前k项初始值，就可以形成k个方程求解k个待定系数$l_1,l_2,\dots,l_k$</p>
<p>eg：用特征多项式求解Fibonacci</p>
<p>$F_i - F_{i-1} + F_{i-2}=0,F_1 = F_2 = 1$</p>
<p>特征多项式$x^2-x-1=(x-\frac{1+\sqrt5}{2})(x-\frac{1-\sqrt5}{2})$</p>
<p>令$\alpha_1 =\frac{1+\sqrt5}{2}, \alpha_2 = \frac{1-\sqrt5}{2}$</p>
<p>由$a_n = \sum \limits_{i=1}^{2} l_i\alpha_i^n$联立方程组</p>
<p>$\left { \begin{array}{l}<br>f_1 = l_1\alpha_1+l_2\alpha_2 = 1 \<br>f_2 = l_1\alpha_1^2+l_2\alpha_2^2  = 1<br>\end{array}\right.$</p>
<p>解得$l_1=\frac{1}{\sqrt5}, l_2 = -\frac{1}{\sqrt5}$</p>
<p>$a_n =  \frac{1}{\sqrt5} (\frac{1+\sqrt5}{2})^n - \frac{1}{\sqrt5} (\frac{1-\sqrt5}{2})^n$</p>
<p><strong>当$C(x)$有重根</strong></p>
<p>有时候特征方程有k重根$\alpha$，组成母函数的部分分式$A(x) = \frac{l_1}{1-\alpha_1x} + \frac{l_2}{(1-\alpha_2x)^2} + \cdots + \frac{l_k}{(1-\alpha_kx)^k}=\sum \limits ^{k}_{i=1} \frac{l_i}{(1-\alpha_i x)^i}$</p>
<p>$x^n$的系数$a_n = \sum \limits_{i=1}^{k}l_iC_{n+i-1}^{i-1}\alpha^n$，</p>
<p>这个组合数是n的i-1次多项式，可以将递推关系的解对应$(A_0+A_1n+\cdots+A_{k-1}n^{k-1})\alpha^n$，只需要求出$A_0,A_1,\dots,A_{k-1}$这k个待定系数即可。</p>
<p><strong>当$C(x)$有虚数根</strong></p>
<p>略</p>
<h1 id="Catalan数"><a href="#Catalan数" class="headerlink" title="Catalan数"></a>Catalan数</h1><p>一个无穷大的栈的进站序列为$1,2,\cdots,n$有多少个不同的出栈序列？</p>
<p>若栈第二次为空时面临着第$i+1$个元素入栈，那么最后一个从栈里拿出的就是第一个元素，实际上问题就被拆解为$i-1$个元素的出栈顺序数和$n-i$个元素的出栈顺序数的乘积。</p>
<p>因此得到递推关系$C(n) = C(n-1)*C(0) + C(n-2)*C(1) + \cdots + C(1)*C(n-2)+C(0)*C(n-1)$</p>
<p><strong>母函数证明</strong></p>
<p>设母函数为$c(x) = \sum \limits _{i=0}^{\infty}C(i)x^n$</p>
<p>$c(x)^2 = C(0)C(0) + (C(1)C(0)+C(0)C(1))x+(C(2)C(0)+C(1)C(1)+C(0)C(2))x^2+\cdots$</p>
<p>$c(x)^2 = C(1)+C(2)x+C(3)x^2+ \cdots$</p>
<p>$c(x) = 1+xc(x)^2$</p>
<p>$c(x) = \frac{1-\sqrt{1-4x}}{2x}, \lim \limits_{x\rightarrow 0^+} = C(0) = 1$</p>
<p>$(1+x)^{\alpha} = 1+\sum \limits_{i=1}^{\infty}C_{\alpha}^ix^i$</p>
<p>$\sqrt{1-4x} = 1 + \sum \limits_{i=1}^{\infty}C_{\frac{1}{2}}^i(-4x)^i$</p>
<p>$C_{\frac{1}{2}}^i = \frac{1}{2}(\frac{1}{2}-1)(\frac{1}{2}-2)\cdots(\frac{1}{2}-i+1)/i! = (-1)^{i-1}\frac{(2i-3)!!}{2^ii!}$</p>
<p>$\sqrt{1-4x} =1+\sum \limits_{i=1}^{\infty}C_{\frac{1}{2}}^i(-4x)^i = 1+\sum \limits_{i=1}^{\infty}(-1)^{i-1}\frac{(2i-3)!!}{2^ii!}(-4x)^i = 1-\sum \limits_{i=1}^{\infty}\frac{(2i-3)!!}{i!}(2x)^i$</p>
<p>$c(x) = \frac{1-\sqrt{1-4x}}{2x}=\sum \limits_{i=1}^{\infty}\frac{(2i-3)!!}{i!}(2x)^{i-1}$</p>
<p>$(2i-2)!! = 2^i(i-1)!$</p>
<p>$c(x) = \frac{1-\sqrt{1-4x}}{2x}=\sum \limits_{i=1}^{\infty}\frac{(2i-3)!!}{n!}(2x)^{i-1}=\sum \limits_{i=1}^{\infty}\frac{(2i-3)!!(2i-2)!!}{i!(i-1)!}x^{i-1}=\sum \limits_{i=1}^{\infty}\frac{(2i-2)!}{i!(i-1)!}x^{i-1} = \sum \limits_{i=0}^{\infty}\frac{(2i)!}{i!(i+1)!}x^{i} = \sum \limits_{i=0}^{\infty}\frac{C_{2i}^i}{i+1}x^{i}$</p>
<p>$C(i) = \frac{C_{2i}^{i}}{i+1}$</p>
<p><strong>格路模型</strong></p>
<p><img src="https://i.328888.xyz/2022/12/12/yOcut.png" alt="yOcut.png"></p>
<p>一个$n*n$的网格，问从左下角顶点$(0,0)$到右上角顶点$(n,n)$每次只能向右或向上走一个单位，且不能越过$y=x$这条对角线到达上半区域的路径数。我们可以先求出可越过对角线的所有路径，然后减去不合法路径。其实不合法路径一定会经过$y=x+1$这条线，从$(-1,1)$到$(n,n)$一定越过了$y=x+1$，由对称性$(-1,1)$到$(n,n)$的每一条路径都对应着$(0,0)$到$(n,n)$的不合法路径，所以合法路径数是$C_{2n}^{n}-C_{2n}^{n-1} = \frac{C_{2n}^{n}}{n+1}$</p>
<h1 id="指数型母函数"><a href="#指数型母函数" class="headerlink" title="指数型母函数"></a>指数型母函数</h1><p>普通母函数定义：对于$c_0,c_1,c_2,\dots$ 构造函数$G(x) = c_0+c_1x+c_2x^2+\dots$ 称$G(x)$为序列$c_0,c_1,c_2,\dots$ 的母函数，普通母函数可用于求<strong>多重组合数</strong></p>
<p>eg: 3个a，2个b，3个c取4个数进行组合。</p>
<p>构造母函数$G(x) = (1+x+x^2+x^3)(1+x+x^2)(1+x+x^2+x^3)$求出$x^4$的系数即可。</p>
<p>指数型母函数定义：对于$c_0,c_1,c_2,\dots$ 构造函数$G(x) = c_0+\frac{c1}{1!}x\frac{c_2}{2!}x^2+\dots$ 称$G(x)$为序列$c_0,c_1,c_2,\dots$ 的指数型母函数，指数型母函数可用于求<strong>多重排列数</strong></p>
<p>eg:数字1出现次数不超过2次，不能不出现；2出现次数不超过1次；3出现次数可达3次，可以不出现；4出现次数为偶数，满足条件的n位数有多少种？</p>
<p>构造母函数$G(x) = (\frac{x}{1!}+\frac{x^2}{2!})(1+x)(1+\frac{x}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!})(1+\frac{x^2}{2!}+\frac{x^4}{4!}+\cdots)$求出$x^n$的系数就是满足条件的n位数的方案数。</p>
<h1 id="错位排列"><a href="#错位排列" class="headerlink" title="错位排列"></a>错位排列</h1><p>有n对男女跳舞，跳完后必须交换舞伴。有多少种方案？</p>
<p>设D(n)为n对男女的交换方案数</p>
<p>显然D(1) = 0, D(2) = 1</p>
<p>对于D(n), n&gt;2，分两种情况:</p>
<ol>
<li><p>考虑第n对男女与前n-1对男女中的一对进行交换，剩余的n-2相互交换有D(n-2)种方式，这时有(n-1)*D(n-2)种方案</p>
</li>
<li><p>考虑在n-1对男女交换完毕后，第n对男女再与前n-1对中的一对进行交换。这时有(n-1)*D(n-1)种。</p>
</li>
</ol>
<p>这两种情况不会重复，因为在第一种情况中第n个人交换是两对男女的错位，第二种情况中至少是3对男女的错位。</p>
<p>由此错排的递推式 $D(n) = (n-1)(D(n-1)+D(n-2))，D(1) = 0, D(2) = 1;$</p>
<p>求D(n)的通项公式</p>
<p>$D(n) = (n-1)(D(n-1)+D(n-2)), D(1) = 0, D(2) = 1$</p>
<p>$D(n) - nD(n-1) = -(D(n-1) - (n-1)D(n-2))$</p>
<p>$D(n) - nD(n-1) = (-1)^(n-2) = (-1)^n$</p>
<p>$D(1) - D(0) = -1, D(0) = 1$</p>
<p>设指数型母函数$G(x) = D(0) + D(1)x+\frac{D(2)}{2!}x^2+\frac{D(3)}{3!}x^3+\cdots$</p>
<p>$G(x) = e^{-1} + G(x)*x$</p>
<p>$G(x) = \frac{e^{-1}}{1-x} = (1-x+\frac{x^2}{2!}-\cdots)(1+x+x^2+\cdots) = \sum \limits_{k=0}^{n}(-1)^kC_n^k(n-k)!$</p>
<h1 id="Stirling数"><a href="#Stirling数" class="headerlink" title="Stirling数"></a>Stirling数</h1><h2 id="第一类Stirling数"><a href="#第一类Stirling数" class="headerlink" title="第一类Stirling数"></a>第一类Stirling数</h2><p><strong>Unsigned Stirling numbers of the first kind</strong></p>
<p>n个元素分成m个圆环的方法数目。</p>
<p>$s(n,m)=s(n-1,m-1) + ns(n-1,m),s(n,0)=0,s(1,1) = 1$</p>
<p><strong>Rising factorial</strong></p>
<p>$x(x+1)(x+2)\cdots(x+n-1)=s(n,0) + s(n,1)x + s(n,2)x^2 + \cdots + s(n,n)x^n$</p>
<hr>
<p><strong>Singed Stirling numbers of the first kind</strong></p>
<p>$s(n,k)=s(n-1,k-1)-ns(n-1,k)$</p>
<p><strong>Falling factorial</strong></p>
<p>$x(x-1)(x-2)\cdots(x-n+1)=s(n,0) + s(n,1)x + s(n,2)x^2 + \cdots + s(n,n)x^n$</p>
<p>$x(x-1)(x-2)\cdots(x-n+1)(x-n)=(s(n,0) + s(n,1)x + s(n,2)x^2 + \cdots + s(n,n)x^n)(x-n)=s(n,0)+(s(n,0)-ns(n,1))x+(s(n,1)-ns(n,2))x+(s(n,2)-ns(n,3))x+\cdots+(s(n,n-1)-ns(n,n))x = s(n+1,0)+s(n+1,1)x+s(n+1,x^2)^2+s(n+1,3)x^3+\cdots+s(n+1,n+1)x^{n+1}$</p>
<h2 id="第二类Stirling数"><a href="#第二类Stirling数" class="headerlink" title="第二类Stirling数"></a>第二类Stirling数</h2><p>n个有区别的球放到m个相同的盒子中，要求无一空盒。</p>
<p>$S(n,0) = 0, S(n,1) = 1$</p>
<p>$S(n,m) = S(n-1,m-1) + mS(n-1,m)$</p>
<p>寻找子问题，考虑最后一个球是否独占一个盒子</p>
<h1 id="八种放球模型"><a href="#八种放球模型" class="headerlink" title="八种放球模型"></a>八种放球模型</h1><ul>
<li>$n$个无区别的球放到$r$个有区别的盒子，盒子可以为空，有多少种方案数？  相当于整数有序拆分，可拆分出0  <strong>隔板法</strong>  将$n$个球排成一行分成连续的$r$个区间，这$r$个连续的区间就代表着有区别的盒子。将r个盒子看作$r-1$个无区别的隔板，盒子为空说明隔板位置不限。直接用多重全排列，有$2$种球$1$种出现$n$个，$1$种出现$r-1$个。答案即为$\frac{(n+r-1)!}{n!(r-1)!}$，这不是$n+r-1$个里面选$r-1$个的组合数$C_{n+r-1}^{r-1}$吗? 所以也有了另一种思路在$n+r-1$个位置中选$r-1$个放隔板，剩余的放球就行了.  <strong>母函数</strong>  $G(x) = (1+x+x^2+x^3+\cdots)^r = (1-x)^{-r}=\sum \limits_{n=0}^{\infty}C_{n+r-1}^{r-1}x^n$</li>
<li>$n$个无区别的球放到$r$个有区别的盒子，盒子不能为空，有多少种方案数？  相当于整数有序拆分，不可拆分出0  <strong>隔板法</strong>  将$n$个球排成一行分成连续的$r$个区间，这$r$个连续的区间就代表着有区别的盒子。盒子不能为空那r-1个隔板就只能放n个球的n-1间隙，直接在n-1个间隙中选r-1个位置的组合数就行，相比有区别就是少乘了有区别的球的排列，答案$C_{n-1}^{r-1}$  <strong>母函数</strong>  $G(x) = (1+x+x^2+x^3+\cdots)^r$</li>
<li>$n$个无区别的球放到$r$个无区别的盒子，盒子可以为空，有多少种方案数？  相当于整数无序拆分，可拆分出0  <strong>母函数</strong>  $G(x) = (1+x+x^2+x^3+\cdots)(1+x^2+x^4+x^6+\cdots)\cdots(1+x^r+x^{2r}+x^{3r}+\cdots)$  方案数是$x^n$的系数</li>
<li>$n$个无区别的球放到$r$个无区别的盒子，盒子不能为空，有多少种方案数？  相当于整数无序拆分，不可拆分出0  <strong>母函数</strong>  $G(x) = (x+x^2+x^3+\cdots)(x^2+x^4+x^6+\cdots)\cdots(x^r+x^{2r}+x^{3r}+\cdots)$  方案数是$x^n$的系数</li>
<li>$n$个有区别的球放到$r$个有区别的盒子，盒子可以为空，有多少种方案数？  相当于r种元素，每种元素可选0次或任意次，从中选n个的排列数。  所以答案就是$r^n$种。  <strong>母函数</strong>  $G_e(x) = (1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\cdots)^r = (e^x)^r=1+\frac{r}{1!}x+\frac{r^2}{2!}x^2+\frac{r^3}{3!}x^3+\cdots=\sum \limits_{n=0}^{\infty} \frac{r^n}{n!}x^n$  方案数为$r^n$</li>
<li>$n$个有区别的球放到$r$个有区别的盒子，盒子不能为空，有多少种方案数？  相当于第二类Stirling数乘以盒子的全排列，即$r!S(n,r)$  当于r个有标志的元素取n个作允许重复的排列，r种元素至少每个选一个。  <strong>母函数</strong>  $G_e(x) = (x+\frac{x^2}{2!}+\frac{x^3}{3!}+\cdots)^r = (e^x-1)^r =\sum \limits_{h=0}^{r} C_{r}^h(-1)^he^{(r-h)x}$  $e^{(r-h)x} = 1+\frac{r-h}{1!}x+\frac{(r-h)^2}{2!}x^2+\frac{(r-h)^3}{3!}x^3+\cdots=\sum \limits_{n=0}^{\infty} \frac{(r-h)^n}{n!}x^n$  $G_e(x) = \sum \limits_{h=0}^{r}C_{r}^h(-1)^h\sum \limits_{n=0}^{\infty} \frac{(r-h)^n}{n!}x^n= \sum \limits_{n=0}^{\infty} \frac{x^n}{n!}\sum \limits_{h=0}^{r}C_{r}^h(-1)^h(r-h)^n$  方案数为$\sum \limits_{h=0}^{r}C_{r}^h(-1)^h(r-h)^n$</li>
<li>$n$个有区别的球放到$r$个无区别的盒子，盒子可以为空，有多少种方案数？  利用第二类Stirling数，枚举盒子为空的个数，没有盒子为空有S(n,r)种，有一个盒子为空有S(n,r-1)种，两个盒子为空有S(n,r-2)种，……，r-1个盒子为空有S(n,1)。不存在所有盒子都为空。</li>
<li>$n$个有区别的球放到$r$个无区别的盒子，盒子不能为空，有多少种方案数？  相当于第二类Stirling数  <strong>母函数</strong>  通过$<strong>n$个有区别的球放到$r$个有区别的盒子，盒子不能为空</strong>的母函数可知$r!S(n,r) = \sum \limits_{h=0}^{r}C_{r}^h(-1)^h(r-h)^n$  $S(n,r) = \frac{1}{r!}\sum \limits_{h=0}^{r}C_{r}^h(-1)^h(r-h)^n$  <strong>递推式</strong>  动态规划寻找子问题，考虑最后一个球是否独占一个盒子  $S(n,0) = 0, S(n,1) = 1$  $S(n,m) = S(n-1,m-1) + mS(n-1,m)$</li>
</ul>
<p><a href="https://fightinggg.github.io/ACM/stencil/math/%E7%90%83%E7%9B%92%E6%A8%A1%E5%9E%8B.html">https://fightinggg.github.io/ACM/stencil/math/球盒模型.html</a></p>
]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>母函数</tag>
      </tags>
  </entry>
  <entry>
    <title>母函数求解汉诺塔</title>
    <url>/2022/12/07/%E6%AF%8D%E5%87%BD%E6%95%B0%E6%B1%82%E8%A7%A3%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    <content><![CDATA[<h1 id="什么是母函数"><a href="#什么是母函数" class="headerlink" title="什么是母函数"></a>什么是母函数</h1><blockquote>
<p>在数学中，某个序列${\displaystyle (a_{n}){n\in \mathbb {N} }}(a{n})_{n\in \mathbb {N} }$ 的母函数（又称生成函数，英语：Generating function）是一种形式幂级数，其每一项的系数可以提供关于这个序列的信息。</p>
</blockquote>
<blockquote>
<p>母函数就是一列用来展示一串数字序列的挂衣架。</p>
</blockquote>
<blockquote>
<p>定义：对于$c_0,c_1,c_2,\dots$ 构造函数$G(x) = c_0+c_1x+c_2x^2+\dots$ 称$G(x)$为序列$c_0,c_1,c_2,\dots$ 的母函数</p>
</blockquote>
<span id="more"></span>
<h1 id="求解汉诺塔"><a href="#求解汉诺塔" class="headerlink" title="求解汉诺塔"></a>求解汉诺塔</h1><p>现有编号$A$、$B$和$C$三根柱子，有$n$个中空盘子在$A$柱子上，盘子大小互不相同从小到大依次排列，每次只能移动最上面的盘子且移动后要保证小盘子在大盘子上。</p>
<p>现在需要将$A$柱子上的$n$个盘子移动到$C$上。可分三步走，首先移动$n-1$个盘到$B$柱子上，然后将最后一个盘子移动到$C$上，最后将$B$上的$n-1$个盘子移动到$C$上。</p>
<p>我们设移动$n$个盘子到另一根柱子上需要$f(n)$步，根据三步走有递推公式$f(i) = 2 * f(i-1) + 1,f(0) = 0$。</p>
<p>构造母函数$G(x) = f(0) + f(1)x + f(2)x^2 + f(3)x^3 + \cdots$</p>
<p>母函数可作为<strong>递推公式</strong>和<strong>通项公式</strong>的<strong>桥梁</strong>，这时候我们要$f(n)$就只要求出$x^n$的系数即可。</p>
<p>将递推公式带入$G(x)$可得</p>
<p>$G(x) = (2f(0)+1)x+(2f(1)+1)x^2+(2f(2)+1)x^3+\cdots$</p>
<p>$G(x) = 2x(f(0)+f(1)x+f(2)x^2+\cdots) + x + x^2 + x^3 + \cdots$</p>
<p>$G(x) = 2xG(x) + x+ x^2 + x^3 + \cdots$</p>
<p>根据泰勒公式</p>
<p>$G(x) = 2xG(x) + \frac{1}{1-x}-1$</p>
<p>$G(x) = \frac{x}{(1-2x)(1-x)} = \frac{1}{1-2x} - \frac{1}{1-x} = (1+2x+ 2^2x^2 + 2^3x^3 + \cdots)-(1+x+ x^2 + x^3 + \cdots)=\sum \limits_{i=0}^{\infty} (2^i-1)x^i$</p>
<p>so $f(i) = 2^i-1$</p>
]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>母函数</tag>
        <tag>汉诺塔</tag>
      </tags>
  </entry>
  <entry>
    <title>水位上升的泳池中游泳</title>
    <url>/2023/04/09/%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></p>
<hr>
<p>在一个 <code>n x n</code> 的整数矩阵 <code>grid</code> 中，每一个方格的值 <code>grid[i][j]</code> 表示位置 <code>(i, j)</code> 的平台高度。</p>
<p>当开始下雨时，在时间为 <code>t</code> 时，水池中的水位为 <code>t</code> 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p>
<p>你从坐标方格的左上平台 <code>(0，0)</code> 出发。返回 <em>你到达坐标方格的右下平台 <code>(n-1, n-1)</code> 所需的最少时间 。</em></p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入: grid = [[0,2],[1,3]]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">时间为0时，你位于坐标方格的位置为 (0, 0)。</span><br><span class="line">此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。</span><br><span class="line">等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]</span><br><span class="line">输出: 16</span><br><span class="line">解释: 最终的路线用加粗进行了标记。</span><br><span class="line">我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li>  <code>n == grid.length</code></li>
<li>  <code>n == grid[i].length</code></li>
<li>  <code>1 &lt;= n &lt;= 50</code></li>
<li>  <code>0 &lt;= grid[i][j] &lt; n^2</code></li>
<li><code>grid[i][j]</code> 中每个值 <strong>均无重复</strong></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>二分+广搜</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">swimInWater</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> ok = [&amp;](<span class="type">int</span> h)-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (h&lt;grid[<span class="number">0</span>][<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vis</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">            vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">            que.<span class="built_in">emplace</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [x, y] = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (x == n<span class="number">-1</span> &amp;&amp; y == n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> dx = x+(i<span class="number">-1</span>)%<span class="number">2</span>;</span><br><span class="line">                    <span class="type">int</span> dy = y+(i<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dx&lt;<span class="number">0</span> || dx&gt;=n || dy&lt;<span class="number">0</span> || dy&gt;=n || grid[dx][dy]&gt;h || vis[dx][dy]) <span class="keyword">continue</span>;</span><br><span class="line">                    vis[dx][dy] = <span class="number">1</span>;</span><br><span class="line">                    que.<span class="built_in">emplace</span>(dx, dy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">2500</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">int</span> m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ok</span>(m)) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>求出 MK 平均值</title>
    <url>/2023/04/09/%E6%B1%82%E5%87%BA%20MK%20%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/finding-mk-average/">1825. 求出 MK 平均值</a></p>
<hr>
<p>给你两个整数 <code>m</code> 和 <code>k</code> ，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 <strong>MK 平均值</strong> 。</p>
<p><strong>MK 平均值</strong> 按照如下步骤计算：</p>
<ol>
<li> 如果数据流中的整数少于 <code>m</code> 个，<strong>MK 平均值</strong> 为 <code>-1</code> ，否则将数据流中最后 <code>m</code> 个元素拷贝到一个独立的容器中。</li>
<li> 从这个容器中删除最小的 <code>k</code> 个数和最大的 <code>k</code> 个数。</li>
<li> 计算剩余元素的平均值，并 <strong>向下取整到最近的整数</strong> 。</li>
</ol>
<p>请你实现 <code>MKAverage</code> 类：</p>
<ul>
<li>  <code>MKAverage(int m, int k)</code> 用一个空的数据流和两个整数 <code>m</code> 和 <code>k</code> 初始化 <strong>MKAverage</strong> 对象。</li>
<li>  <code>void addElement(int num)</code> 往数据流中插入一个新的元素 <code>num</code> 。</li>
<li><code>int calculateMKAverage()</code> 对当前的数据流计算并返回 <strong>MK 平均数</strong> ，结果需 <strong>向下取整到最近的整数</strong> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MKAverage&quot;, &quot;addElement&quot;, &quot;addElement&quot;, &quot;calculateMKAverage&quot;, &quot;addElement&quot;, &quot;calculateMKAverage&quot;, &quot;addElement&quot;, &quot;addElement&quot;, &quot;addElement&quot;, &quot;calculateMKAverage&quot;]</span><br><span class="line">[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, -1, null, 3, null, null, null, 5]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MKAverage obj = new MKAverage(3, 1); </span><br><span class="line">obj.addElement(3);        // 当前元素为 [3]</span><br><span class="line">obj.addElement(1);        // 当前元素为 [3,1]</span><br><span class="line">obj.calculateMKAverage(); // 返回 -1 ，因为 m = 3 ，但数据流中只有 2 个元素</span><br><span class="line">obj.addElement(10);       // 当前元素为 [3,1,10]</span><br><span class="line">obj.calculateMKAverage(); // 最后 3 个元素为 [3,1,10]</span><br><span class="line">                          // 删除最小以及最大的 1 个元素后，容器为 [3]</span><br><span class="line">                          // [3] 的平均值等于 3/1 = 3 ，故返回 3</span><br><span class="line">obj.addElement(5);        // 当前元素为 [3,1,10,5]</span><br><span class="line">obj.addElement(5);        // 当前元素为 [3,1,10,5,5]</span><br><span class="line">obj.addElement(5);        // 当前元素为 [3,1,10,5,5,5]</span><br><span class="line">obj.calculateMKAverage(); // 最后 3 个元素为 [5,5,5]</span><br><span class="line">                          // 删除最小以及最大的 1 个元素后，容器为 [5]</span><br><span class="line">                          // [5] 的平均值等于 5/1 = 5 ，故返回 5</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>3 &lt;= m &lt;= 10^5</code></li>
<li>  <code>1 &lt;= k*2 &lt; m</code></li>
<li>  <code>1 &lt;= num &lt;= 10^5</code></li>
<li><code>addElement</code> 与 <code>calculateMKAverage</code> 总操作次数不超过 <code>10^5</code> 次。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们将最后m个数分成三个可重集合：最小的k个数<code>l</code>，最大的k个数<code>r</code>，剩余的m-2k个数<code>c</code>。并用<code>sum</code>实时统计<code>c</code>中元素和。</p>
<p>类似滑动窗口，我们可以用一个队列来维护数据流中最后m个数。</p>
<p>在每次添加一个新元素<code>a</code>到队列中后：</p>
<ul>
<li>当队列中元素不超过m个，无需操作，此时MK平均值就是-1。</li>
<li>当队列中元素恰好等于m个，我们就构造<code>l</code>，<code>r</code>，<code>c</code>三个集合。以及<code>c</code>中元素和<code>sum</code>，此时MK平均值就是<code>sum/(m-2*k)</code></li>
<li>当队列中元素大于等于m个，我们需要删除队头元素<code>d</code>，且在三个集合中添加<code>a</code>，删除<code>d</code>，并调整三个集合。<ul>
<li>插入<code>a</code>。为了保证<code>l</code>是最后m个数中最小k个数，如果<code>l</code>中最大的数大于<code>a</code>，说明<code>a</code>成了最小的k个数之一，此时<code>l</code>中最大的数应该要移动到<code>c</code>中，移动后<code>c</code>中的数始终还是不大于<code>r</code>的，所以<code>r</code>无需调整；若尝试插入到<code>l</code>中失败，同理尝试插入到<code>r</code>中，此时的判断条件应该是<code>a</code>大于r的最小值；最后若插入<code>l</code>和<code>r</code>都失败了，就插入到<code>m</code>中。这个过程中注意更新<code>c</code>中元素和<code>sum</code>。执行插入操作后，使得了<code>c</code>中元素多了一个。</li>
<li>删除<code>d</code>。若<code>l</code>中存在<code>d</code>，删除后导致了<code>l</code>少了一个元素，而<code>c</code>中恰多一个，为了维护<code>l</code>是最小的k个数，将<code>c</code>中最小值移动到<code>l</code>中；若<code>l</code>中不存在，则同理尝试在<code>r</code>中寻找并删除；若<code>l</code>和<code>r</code>中都不在，则一定在<code>c</code>中。实时更新<code>sum</code>。</li>
</ul>
</li>
</ul>
<p>我们对集合的操作有增加元素，删除元素，查找元素，查找最值。可以使用能高效的进行这些操作的数据结构——平衡树。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MKAverage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; l, c, r;</span><br><span class="line">    <span class="type">int</span> m, k;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line">    <span class="built_in">MKAverage</span>(<span class="type">int</span> m, <span class="type">int</span> k):<span class="built_in">m</span>(m),<span class="built_in">k</span>(k),<span class="built_in">sum</span>(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (*l.<span class="built_in">rbegin</span>()&gt;x) &#123;</span><br><span class="line">            l.<span class="built_in">insert</span>(x);</span><br><span class="line">            c.<span class="built_in">insert</span>(*l.<span class="built_in">rbegin</span>());</span><br><span class="line">            sum += *l.<span class="built_in">rbegin</span>();</span><br><span class="line">            l.<span class="built_in">erase</span>(--l.<span class="built_in">end</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*r.<span class="built_in">begin</span>()&lt;x) &#123;</span><br><span class="line">            r.<span class="built_in">insert</span>(x);</span><br><span class="line">            c.<span class="built_in">insert</span>(*r.<span class="built_in">begin</span>());</span><br><span class="line">            sum += *r.<span class="built_in">begin</span>();</span><br><span class="line">            r.<span class="built_in">erase</span>(r.<span class="built_in">begin</span>());            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.<span class="built_in">insert</span>(x);</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l.<span class="built_in">count</span>(x)) &#123;</span><br><span class="line">            l.<span class="built_in">erase</span>(l.<span class="built_in">find</span>(x));</span><br><span class="line">            l.<span class="built_in">insert</span>(*c.<span class="built_in">begin</span>());</span><br><span class="line">            sum -= *c.<span class="built_in">begin</span>();</span><br><span class="line">            c.<span class="built_in">erase</span>(c.<span class="built_in">begin</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.<span class="built_in">count</span>(x)) &#123;</span><br><span class="line">            r.<span class="built_in">erase</span>(r.<span class="built_in">find</span>(x));</span><br><span class="line">            r.<span class="built_in">insert</span>(*c.<span class="built_in">rbegin</span>());</span><br><span class="line">            sum -= *c.<span class="built_in">rbegin</span>();</span><br><span class="line">            c.<span class="built_in">erase</span>(--c.<span class="built_in">end</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.<span class="built_in">erase</span>(c.<span class="built_in">find</span>(x));</span><br><span class="line">            sum -= x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addElement</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(num);</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &lt; m) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() == m) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q;</span><br><span class="line">            <span class="keyword">while</span> (t.<span class="built_in">size</span>()) c.<span class="built_in">insert</span>(t.<span class="built_in">front</span>()), t.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">                l.<span class="built_in">insert</span>(*c.<span class="built_in">begin</span>());</span><br><span class="line">                c.<span class="built_in">erase</span>(c.<span class="built_in">begin</span>());</span><br><span class="line">                r.<span class="built_in">insert</span>(*c.<span class="built_in">rbegin</span>());</span><br><span class="line">                c.<span class="built_in">erase</span>(--c.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i:c) sum += i;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(num);</span><br><span class="line">        <span class="built_in">del</span>(q.<span class="built_in">front</span>());</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateMKAverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>()&lt;m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> sum/(m<span class="number">-2</span>*k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MKAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MKAverage* obj = new MKAverage(m, k);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addElement(num);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;calculateMKAverage();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>求出最多标记下标</title>
    <url>/2023/04/09/%E6%B1%82%E5%87%BA%E6%9C%80%E5%A4%9A%E6%A0%87%E8%AE%B0%E4%B8%8B%E6%A0%87/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/">6367. 求出最多标记下标</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p>
<p>一开始，所有下标都没有被标记。你可以执行以下操作任意次：</p>
<ul>
<li>  选择两个 <strong>互不相同且未标记</strong> 的下标 <code>i</code> 和 <code>j</code> ，满足 <code>2 * nums[i] &lt;= nums[j]</code> ，标记下标 <code>i</code> 和 <code>j</code> 。</li>
</ul>
<p>请你执行上述操作任意次，返回 <code>nums</code> 中最多可以标记的下标数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,5,2,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：第一次操作中，选择 i = 2 和 j = 1 ，操作可以执行的原因是 2 * nums[2] &lt;= nums[1] ，标记下标 2 和 1 。</span><br><span class="line">没有其他更多可执行的操作，所以答案为 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [9,2,5,4]</span><br><span class="line">输出：4</span><br><span class="line">解释：第一次操作中，选择 i = 3 和 j = 0 ，操作可以执行的原因是 2 * nums[3] &lt;= nums[0] ，标记下标 3 和 0 。</span><br><span class="line">第二次操作中，选择 i = 1 和 j = 2 ，操作可以执行的原因是 2 * nums[1] &lt;= nums[2] ，标记下标 1 和 2 。</span><br><span class="line">没有其他更多可执行的操作，所以答案为 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,6,8]</span><br><span class="line">输出：0</span><br><span class="line">解释：没有任何可以执行的操作，所以答案为 0 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>二分+贪心。</p>
<p>首先如果有x对下标可以标记，肯定x-1对下标可以被标记。</p>
<p>所以可以在区间<code>[0,n/2]</code>通过二分法求出最大可标记对数。</p>
<p>如果当前二分的对数为k。</p>
<p>那么可以通过贪心来检测是否满足。</p>
<p>我们用最小的k个值和最大的k个值进行匹配，如果可以匹配，则增大k；<br>否则，减小k。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxNumOfMarkedIndices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">int</span> m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// int l1 = 0, r1 = m-1, l2 = n-m, r2 = n-1;</span></span><br><span class="line">            <span class="type">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">2</span>*nums[i]&gt;nums[n-m+i]) &#123;</span><br><span class="line">                    ok = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                l = m+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*(r<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>泰勒展开</title>
    <url>/2022/12/06/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<h1 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h1><p>$f(x) = f(x)+f’(x)x+\frac{f’’(x)}{2!}x^2+\frac{f’’’(x)}{3!}x^3+\dots++\frac{f^{(n)}(x)}{n!}x^n = \sum \limits_{k=0}^{n}\frac{f^{(k)}(x)}{k!}x^k$</p>
<span id="more"></span>
<h1 id="sin-x"><a href="#sin-x" class="headerlink" title="$\sin(x)$"></a>$\sin(x)$</h1><table>
<thead>
<tr>
<th></th>
<th>$f^n(x)$</th>
<th>$f^n(0)$</th>
<th>$a_n=\frac{f^n(0)}{n!}$</th>
</tr>
</thead>
<tbody><tr>
<td>$f(x)$</td>
<td>$sin(x)$</td>
<td>$0$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’(x)$</td>
<td>$cos(x)$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’’(x)$</td>
<td>$-sin(x)$</td>
<td>$0$</td>
<td>$\frac{1}{2}$</td>
</tr>
<tr>
<td>$f’’’(x)$</td>
<td>$-cos(x)$</td>
<td>$-1$</td>
<td>$\frac{1}{3!}$</td>
</tr>
<tr>
<td>$f^{n}(x)$</td>
<td>$f^{n \mod 4}(x)$</td>
<td>$f^{n \mod 4}(0)$</td>
<td>$\frac{1}{n!}$</td>
</tr>
</tbody></table>
<p>$sin(x) = x- \frac{x^3}{3!}+ \frac{x^5}{5!}- \frac{x^7}{7!}+ \frac{x^9}{9!}-\dots+\frac{x^{2n+1}}{(2n+1)!}(-1)^n = \sum \limits_{k=0}^{n}\frac{x^{2k+1}}{(2k+1)!}(-1)^k$</p>
<h1 id="cos-x"><a href="#cos-x" class="headerlink" title="$\cos(x)$"></a>$\cos(x)$</h1><table>
<thead>
<tr>
<th></th>
<th>$f^n(x)$</th>
<th>$f^n(0)$</th>
<th>$a_n=\frac{f^n(0)}{n!}$</th>
</tr>
</thead>
<tbody><tr>
<td>$f(x)$</td>
<td>$cos(x)$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’(x)$</td>
<td>$-sin(x)$</td>
<td>$0$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’’(x)$</td>
<td>$-cos(x)$</td>
<td>$-1$</td>
<td>$\frac{1}{2}$</td>
</tr>
<tr>
<td>$f’’’(x)$</td>
<td>$sin(x)$</td>
<td>$0$</td>
<td>$\frac{1}{3!}$</td>
</tr>
<tr>
<td>$f^n(x)$</td>
<td>$f^{n \mod 4}(x)$</td>
<td>$f^{n \mod 4}(0)$</td>
<td>$\frac{1}{n!}$</td>
</tr>
</tbody></table>
<p>$cos(x) = 1- \frac{x^2}{2!}+ \frac{x^4}{4!}- \frac{x^6}{6!}+ \frac{x^8}{8!}-\dots+\frac{x^{2n}}{(2n)!}(-1)^n = \sum \limits_{k=0}^{n}\frac{x^{2k}}{(2k)!}(-1)^k$</p>
<h1 id="tan-x"><a href="#tan-x" class="headerlink" title="$\tan(x)$"></a>$\tan(x)$</h1><p>$tan(x) = x + \frac{x^3}{3} + \frac{2\cdot x^5}{15} + o(x^5)$</p>
<h1 id="arcsin-x"><a href="#arcsin-x" class="headerlink" title="$\arcsin(x)$"></a>$\arcsin(x)$</h1><p>$\arcsin(x) = x+\frac{1\cdot x^3}{2\cdot 3}+\frac{1\cdot 3 \cdot x^5}{2\cdot 4 \cdot5} +\frac{1\cdot 3 \cdot 5 \cdot x^7}{2\cdot 4 \cdot 6 \cdot 7} + o(x^7)$</p>
<h1 id="arccos-x"><a href="#arccos-x" class="headerlink" title="$\arccos(x)$"></a>$\arccos(x)$</h1><p>$\arccos(x) = \frac{\pi}{2}-\arcsin(x)=\frac{\pi}{2}-(x+\frac{1\cdot x^3}{2\cdot 3}+\frac{1\cdot 3 \cdot x^5}{2\cdot 4 \cdot5} +\frac{1\cdot 3 \cdot 5 \cdot x^7}{2\cdot 4 \cdot 6 \cdot 7} + o(x^7))$</p>
<h1 id="arctan-x"><a href="#arctan-x" class="headerlink" title="$\arctan(x)$"></a>$\arctan(x)$</h1><p>$\arctan(x) = x- \frac{x^3}{3}+ \frac{x^5}{5}- \frac{x^7}{7}+ \frac{x^9}{9}-\dots+\frac{x^{2n+1}}{2n+1}(-1)^n = \sum \limits_{k=0}^{n}\frac{x^{2k+1}}{2k+1}(-1)^k$</p>
<h1 id="a-x"><a href="#a-x" class="headerlink" title="$a^x$"></a>$a^x$</h1><table>
<thead>
<tr>
<th></th>
<th>$f^n(x)$</th>
<th>$f^n(0)$</th>
<th>$a_n=\frac{f^n(0)}{n!}$</th>
</tr>
</thead>
<tbody><tr>
<td>$f(x)$</td>
<td>$a^{x}$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’(x)$</td>
<td>$a^{x}\ln a$</td>
<td>$\ln a$</td>
<td>$\ln a$</td>
</tr>
<tr>
<td>$f’’(x)$</td>
<td>$a^{x}\ln^2 a$</td>
<td>$\ln^2 a$</td>
<td>$\frac{\ln^2a}{2}$</td>
</tr>
<tr>
<td>$f’’’(x)$</td>
<td>$a^{x}\ln^3 a$</td>
<td>$\ln^3 a$</td>
<td>$\frac{\ln^3a}{3!}$</td>
</tr>
<tr>
<td>$f^n(x)$</td>
<td>$a^{x}\ln^n a$</td>
<td>$\ln^n a$</td>
<td>$\frac{\ln^na}{n!}$</td>
</tr>
</tbody></table>
<p>$a^x = 1+ x\ln a + \frac{(x\ln a)^2}{2!} + \frac{(x\ln a)^3}{3!} + \frac{(x\ln a)^4}{4!}+ \frac{(x\ln a)^5}{5!}+\dots+\frac{(x\ln a)^{n}}{n!} = \sum\limits_{k=0}^{n}\frac{(x\ln a)^k}{k!}$</p>
<h1 id="e-x"><a href="#e-x" class="headerlink" title="$e^x$"></a>$e^x$</h1><table>
<thead>
<tr>
<th></th>
<th>$f^n(x)$</th>
<th>$f^n(0)$</th>
<th>$a_n=\frac{f^n(0)}{n!}$</th>
</tr>
</thead>
<tbody><tr>
<td>$f(x)$</td>
<td>$e^{x}$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’(x)$</td>
<td>$e^{x}$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’’(x)$</td>
<td>$e^{x}$</td>
<td>$1$</td>
<td>$\frac{1}{2}$</td>
</tr>
<tr>
<td>$f’’’(x)$</td>
<td>$e^{x}$</td>
<td>$1$</td>
<td>$\frac{1}{3!}$</td>
</tr>
<tr>
<td>$f^n(x)$</td>
<td>$e^{x}$</td>
<td>$1$</td>
<td>$\frac{1}{n!}$</td>
</tr>
</tbody></table>
<p>$e^x = 1+ x + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!}+ \frac{x^5}{5!}+\dots+\frac{x^{n}}{n!} = \sum\limits_{k=0}^{n}\frac{x^k}{k!}$</p>
<h1 id="e-xi"><a href="#e-xi" class="headerlink" title="$e^{xi}$"></a>$e^{xi}$</h1><table>
<thead>
<tr>
<th></th>
<th>$f^n(x)$</th>
<th>$f^n(0)$</th>
<th>$a_n=\frac{f^n(0)}{n!}$</th>
</tr>
</thead>
<tbody><tr>
<td>$f(x)$</td>
<td>$e^{xi}$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’(x)$</td>
<td>$ie^{xi}$</td>
<td>$i$</td>
<td>$i$</td>
</tr>
<tr>
<td>$f’’(x)$</td>
<td>$i^2e^{xi}$</td>
<td>$i^2$</td>
<td>$\frac{i^2}{2}$</td>
</tr>
<tr>
<td>$f’’’(x)$</td>
<td>$i^3e^{xi}$</td>
<td>$i^3$</td>
<td>$\frac{i^3}{3!}$</td>
</tr>
<tr>
<td>$f^n(x)$</td>
<td>$i^ne^{xi}$</td>
<td>$i^n$</td>
<td>$\frac{i^n}{n!}$</td>
</tr>
</tbody></table>
<p>$e^{xi} = 1+ xi + \frac{i^2x^2}{2!} + \frac{i^3x^3}{3!} + \frac{i^4x^4}{4!}+ \frac{i^5x^5}{5!}+\dots+\frac{i^nx^{n}}{n!} = \sum\limits_{k=0}^{n}\frac{i^kx^k}{k!}$</p>
<p>$e^{xi} = 1+ xi - \frac{x^2}{2!} - \frac{ix^3}{3!} + \frac{x^4}{4!}+ \frac{ix^5}{5!}+\dots+\frac{i^nx^{n}}{n!} = \sum\limits_{k=0}^{n}(\frac{x^{2k}}{(2k)!}+\frac{x^{2k+1}}{(2k+1)!}i)(-1)^k$</p>
<p>$e^{xi} = \sum\limits_{k=0}^{n}(\frac{x^{2k}}{(2k)!}+\frac{x^{2k+1}}{(2k+1)!}i)(-1)^k=\sum\limits_{k=0}^{n}\frac{x^{2k}}{(2k)!}(-1)^k+i\sum\limits_{k=0}^{n}\frac{x^{2k+1}}{(2k+1)!}(-1)^k$</p>
<p>$e^{xi}= cos(x)+sin(x)i$</p>
<h1 id="1-x-a"><a href="#1-x-a" class="headerlink" title="$(1+x)^a$"></a>$(1+x)^a$</h1><table>
<thead>
<tr>
<th></th>
<th>$f^n(x)$</th>
<th>$f^n(0)$</th>
<th>$a_n=\frac{f^n(0)}{n!}$</th>
</tr>
</thead>
<tbody><tr>
<td>$f(x)$</td>
<td>$(1+x)^a$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’(x)$</td>
<td>$a\cdot(1+x)^{a-1}$</td>
<td>$a$</td>
<td>$a$</td>
</tr>
<tr>
<td>$f’’(x)$</td>
<td>$a\cdot (a-1) \cdot(1+x)^{a-2}$</td>
<td>$a\cdot(a-1)$</td>
<td>$\frac{a\cdot(a-1)}{2}$</td>
</tr>
<tr>
<td>$f’’’(x)$</td>
<td>$a\cdot (a-1) \cdot (a-2) \cdot(1+x)^{a-3}$</td>
<td>$a\cdot (a-1) \cdot (a-2)$</td>
<td>$\frac{a\cdot (a-1) \cdot (a-2)}{3!}$</td>
</tr>
<tr>
<td>$f^n(x)$</td>
<td>$A_a^n(1+x)^{a-n}$</td>
<td>$A_a^n$</td>
<td>$\frac{A_a^n}{n!}$</td>
</tr>
</tbody></table>
<p>$(1+x)^a = 1+ax+\frac{a(a-1)}{2!}x^2+\frac{a(a-1)(a-2)}{3!}x^3+\dots+\frac{a(a-1)\cdots(a-n+1)}{n!}x^n$</p>
<h1 id="1-x-a-1"><a href="#1-x-a-1" class="headerlink" title="$(1-x)^a$"></a>$(1-x)^a$</h1><table>
<thead>
<tr>
<th></th>
<th>$f^n(x)$</th>
<th>$f^n(0)$</th>
<th>$a_n=\frac{f^n(0)}{n!}$</th>
</tr>
</thead>
<tbody><tr>
<td>$f(x)$</td>
<td>$(1-x)^a$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’(x)$</td>
<td>$-a\cdot(1-x)^{a-1}$</td>
<td>$a$</td>
<td>$a$</td>
</tr>
<tr>
<td>$f’’(x)$</td>
<td>$a\cdot (a-1) \cdot(1-x)^{a-2}$</td>
<td>$a\cdot(a-1)$</td>
<td>$\frac{a\cdot(a-1)}{2}$</td>
</tr>
<tr>
<td>$f’’’(x)$</td>
<td>$-a\cdot (a-1) \cdot (a-2) \cdot(1-x)^{a-3}$</td>
<td>$a\cdot (a-1) \cdot (a-2)$</td>
<td>$\frac{a\cdot (a-1) \cdot (a-2)}{3!}$</td>
</tr>
<tr>
<td>$f^n(x)$</td>
<td>$(-1)^nA_a^n(1-x)^{a-n}$</td>
<td>$(-1)^nA_a^n$</td>
<td>$(-1)^n\frac{A_a^n}{n!}$</td>
</tr>
</tbody></table>
<p>$(1-x)^a = 1-ax+\frac{a(a-1)}{2!}x^2-\frac{a(a-1)(a-2)}{3!}x^3+\dots+(-1)^n\frac{a(a-1)\cdots(a-n+1)}{n!}x^n$</p>
<h1 id="frac-1-1-x"><a href="#frac-1-1-x" class="headerlink" title="$\frac{1}{1-x}$"></a>$\frac{1}{1-x}$</h1><table>
<thead>
<tr>
<th></th>
<th>$f^n(x)$</th>
<th>$f^n(0)$</th>
<th>$a_n=\frac{f^n(0)}{n!}$</th>
</tr>
</thead>
<tbody><tr>
<td>$f(x)$</td>
<td>$\frac{1}{1-x}$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’(x)$</td>
<td>$\frac{1}{1-x}^2$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’’(x)$</td>
<td>$2\frac{1}{1-x}^3$</td>
<td>$2!$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’’’(x)$</td>
<td>$3!\frac{1}{1-x}^4$</td>
<td>$3!$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f^n(x)$</td>
<td>$n!\frac{1}{1-x}^{(n+1)}$</td>
<td>$n!$</td>
<td>$1$</td>
</tr>
</tbody></table>
<p>$\frac{1}{1-x} = 1 + x + x^2 + x^3+\dots+x^n=\sum\limits_{i=0}^{n}x^i$</p>
<h1 id="frac-1-1-x-1"><a href="#frac-1-1-x-1" class="headerlink" title="$\frac{1}{1+x}$"></a>$\frac{1}{1+x}$</h1><table>
<thead>
<tr>
<th></th>
<th>$f^n(x)$</th>
<th>$f^n(0)$</th>
<th>$a_n=\frac{f^n(0)}{n!}$</th>
</tr>
</thead>
<tbody><tr>
<td>$f(x)$</td>
<td>$\frac{1}{1+x}$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’(x)$</td>
<td>$-\frac{1}{1+x}^2$</td>
<td>$-1$</td>
<td>$-1$</td>
</tr>
<tr>
<td>$f’’(x)$</td>
<td>$2\frac{1}{1+x}^3$</td>
<td>$2!$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’’’(x)$</td>
<td>$-3!\frac{1}{1+x}^4$</td>
<td>$-3!$</td>
<td>$-1$</td>
</tr>
<tr>
<td>$f^n(x)$</td>
<td>$(-1)^nn!\frac{1}{1+x}^{(n+1)}$</td>
<td>$(-1)^nn!$</td>
<td>$(-1)^n$</td>
</tr>
</tbody></table>
<p>$\frac{1}{1+x} = 1 - x + x^2 - x^3+\dots+(-1)^nx^n=\sum\limits_{i=0}^{n}x^i(-1)^n$</p>
<h1 id="ln-1-x"><a href="#ln-1-x" class="headerlink" title="$\ln(1-x)$"></a>$\ln(1-x)$</h1><table>
<thead>
<tr>
<th></th>
<th>$f^n(x)$</th>
<th>$f^n(0)$</th>
<th>$a_n=\frac{f^n(0)}{n!}$</th>
</tr>
</thead>
<tbody><tr>
<td>$f(x)$</td>
<td>$\ln(1-x)$</td>
<td>$0$</td>
<td>$0$</td>
</tr>
<tr>
<td>$f’(x)$</td>
<td>$-\frac{1}{1-x}$</td>
<td>$-1$</td>
<td>$-1$</td>
</tr>
<tr>
<td>$f’’(x)$</td>
<td>$-\frac{1}{1-x}^2$</td>
<td>$-1$</td>
<td>$-\frac{1}{2}$</td>
</tr>
<tr>
<td>$f’’’(x)$</td>
<td>$-2\frac{1}{1-x}^3$</td>
<td>$-2!$</td>
<td>$-\frac{2!}{3!}=\frac{1}{3}$</td>
</tr>
<tr>
<td>$f^4(x)$</td>
<td>$-3!\frac{1}{1-x}^4$</td>
<td>$-3!$</td>
<td>$-\frac{1}{4}$</td>
</tr>
<tr>
<td>$f^n(x)$</td>
<td>$-(n-1)!\frac{1}{1-x}^{n}$</td>
<td>$-(n-1)!$</td>
<td>$-\frac{1}{n}$</td>
</tr>
</tbody></table>
<p>$\ln(1-x) = -x - \frac{x^2}{2} - \frac{x^3}{3}-\dots-\frac{x^n}{n}=-\sum\limits_{i=1}^{n}\frac{x^i}{n}$</p>
<h1 id="ln-1-x-1"><a href="#ln-1-x-1" class="headerlink" title="$\ln(1+x)$"></a>$\ln(1+x)$</h1><table>
<thead>
<tr>
<th></th>
<th>$f^n(x)$</th>
<th>$f^n(0)$</th>
<th>$a_n=\frac{f^n(0)}{n!}$</th>
</tr>
</thead>
<tbody><tr>
<td>$f(x)$</td>
<td>$\ln(1+x)$</td>
<td>$0$</td>
<td>$0$</td>
</tr>
<tr>
<td>$f’(x)$</td>
<td>$\frac{1}{1+x}$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$f’’(x)$</td>
<td>$-\frac{1}{1+x}^2$</td>
<td>$-1$</td>
<td>$-\frac{1}{2}$</td>
</tr>
<tr>
<td>$f’’’(x)$</td>
<td>$2\frac{1}{1+x}^3$</td>
<td>$2!$</td>
<td>$\frac{2!}{3!}=\frac{1}{3}$</td>
</tr>
<tr>
<td>$f^4(x)$</td>
<td>$-3!\frac{1}{1+x}^4$</td>
<td>$-3!$</td>
<td>$-\frac{1}{4}$</td>
</tr>
<tr>
<td>$f^n(x)$</td>
<td>$(-1)^{n+1}(n-1)!\frac{1}{1+x}^{n}$</td>
<td>$(-1)^{n+1}(n-1)!$</td>
<td>$(-1)^{n+1}\frac{1}{n}$</td>
</tr>
</tbody></table>
<p>$\ln(1+x) = x - \frac{x^2}{2} + \frac{x^3}{3}-\dots+(-1)^{n+1}\frac{x^n}{n}=\sum\limits_{i=1}^{n}\frac{x^i}{n}(-1)^{i+1}$</p>
]]></content>
      <categories>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>泰勒公式</tag>
      </tags>
  </entry>
  <entry>
    <title>灌溉花园的最少水龙头数目</title>
    <url>/2023/04/09/%E7%81%8C%E6%BA%89%E8%8A%B1%E5%9B%AD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B0%B4%E9%BE%99%E5%A4%B4%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/">1326. 灌溉花园的最少水龙头数目</a></p>
<hr>
<p>在 x 轴上有一个一维的花园。花园长度为 <code>n</code>，从点 <code>0</code> 开始，到点 <code>n</code> 结束。</p>
<p>花园里总共有 <code>n + 1</code> 个水龙头，分别位于 <code>[0, 1, ..., n]</code> 。</p>
<p>给你一个整数 <code>n</code> 和一个长度为 <code>n + 1</code> 的整数数组 <code>ranges</code> ，其中 <code>ranges[i]</code> （下标从 0 开始）表示：如果打开点 <code>i</code> 处的水龙头，可以灌溉的区域为 <code>[i -  ranges[i], i + ranges[i]]</code> 。</p>
<p>请你返回可以灌溉整个花园的 <strong>最少水龙头数目</strong> 。如果花园始终存在无法灌溉到的地方，请你返回 <strong>-1</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/19/1685_example_1.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 5, ranges = [3,4,1,1,0,0]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">点 0 处的水龙头可以灌溉区间 [-3,3]</span><br><span class="line">点 1 处的水龙头可以灌溉区间 [-3,5]</span><br><span class="line">点 2 处的水龙头可以灌溉区间 [1,3]</span><br><span class="line">点 3 处的水龙头可以灌溉区间 [2,4]</span><br><span class="line">点 4 处的水龙头可以灌溉区间 [4,4]</span><br><span class="line">点 5 处的水龙头可以灌溉区间 [5,5]</span><br><span class="line">只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 3, ranges = [0,0,0,0]</span><br><span class="line">输出：-1</span><br><span class="line">解释：即使打开所有水龙头，你也无法灌溉整个花园。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 10^4</code></li>
<li>  <code>ranges.length == n + 1</code></li>
<li><code>0 &lt;= ranges[i] &lt;= 100</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们可以设$f_i$为从0到i需要多少个水龙头，初始化$f_0 = 0, f_i=\infin, i&gt;0$</p>
<p>然后求出每个水龙头的浇灌范围，并进行排序，我们按照能浇灌的最右端升序排序，以便保证dp转移时无后效性。</p>
<p>对已排序的水龙头v遍历，设在遍历第i个水龙头时水龙头的左端为$l_i$，右端为$r_i$，那么有状态转移$f_{r_i} = min(f_{r_i}, f_{l_i}+1)$</p>
<p>若最后$f_n = \infin$则无法到达。</p>
<p>时间复杂度$O(nlogn)$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTaps</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; ranges)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            v.<span class="built_in">emplace_back</span>(<span class="built_in">max</span>(<span class="number">0</span>,i-ranges[i]), <span class="built_in">min</span>(n, i+ranges[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>, INF)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="comment">// if (i&gt;0&amp;&amp;v[i-1].second == v[i].second) continue;</span></span><br><span class="line">            <span class="keyword">auto</span> [x, y] = v[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=x+<span class="number">1</span>; j&lt;=y; j++) &#123;</span><br><span class="line">                f[j] = <span class="built_in">min</span>(f[j], f[x]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n] == INF?<span class="number">-1</span>:f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>可以预处理出每个点<code>i</code>能到达的最右端<code>r[i]</code>。</p>
<p>我们从左端开始考虑一个最大的覆盖范围的水龙头，然后在这个范围内寻找能覆盖最远的水龙头。贪心即可。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTaps</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; ranges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// r[i] i点最大能覆盖到r[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">max</span>(<span class="number">0</span>, i-ranges[i]), y = i+ranges[i];</span><br><span class="line">            r[x] = <span class="built_in">max</span>(r[x], y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, mx = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, r[i]);</span><br><span class="line">            <span class="keyword">if</span> (cur == i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur == mx) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                cur = mx;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>目标和</title>
    <url>/2023/04/09/%E7%9B%AE%E6%A0%87%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></p>
<hr>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>  例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], target = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 20</code></li>
<li>  <code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li>  <code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>
<li><code>-1000 &lt;= target &lt;= 1000</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>n个数的数组，每个数有两种符号，组合方式最多有2^n种。</p>
<p>每个数的二进制位有0或1两种取值，分别代表减号和加号。</p>
<p>遍历0到2^n-1，假设当前遍历到i，i的二进制位数与nums中元素个数是一致的。通过遍历i的二进制位确定nums数组中元素累积运算的符号是加还是减。再判断累积运算后的元素和是否位target确定当前这种符号分配方式是否可取。</p>
<p>由于每次都要遍历n个二进制位。时间复杂度为O(n * 2^n), n最多也就20.运算次数高达20* 1024* 1024=20,971,520, 超时！</p>
<p>在这n个二进制位的加减法中有很多是重复计算的若能将前面部分累计运算结果存储起来之后再用可以减少时间复杂度。</p>
<p>回溯法就是一个很好的方法。回溯法是一个递归算法。递归的每一层都保留了前面层的运算和。时间复杂度降低为O(2^n)。本题中从千万数量级变为百万数量级，能过。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> cur, <span class="type">int</span> lev, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lev == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == target) cnt++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">dfs</span>(nums, cur+nums[lev], lev+<span class="number">1</span>, target);</span><br><span class="line">        <span class="built_in">dfs</span>(nums, cur-nums[lev], lev+<span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>可以通过某种转变将问题转换为类似01背包问题。</p>
<p>sum为nums的和，pos为nums中带正号的和，neg为nums中带负号的和。</p>
<p>pos+neg=sum，pos-neg=target，所以sum-2* neg = target。</p>
<p>neg = (sum-target)/2。neg为整数，sum-target必然为偶数。</p>
<p><code>dp[i][j]</code> 为前i个数中选取若干数之和为j的方式数量。</p>
<p><code>dp[i][j] = dp[i][j-1]</code></p>
<p><code>dp[i][j] = dp[i][j]+dp[i][j-nums[i]] , j &gt;= nums[i]</code></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num:nums) s += num;</span><br><span class="line">        <span class="keyword">if</span> (s &lt; target || (s - target)%<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">((s - target)/<span class="number">2</span>+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=dp.<span class="built_in">size</span>()<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) dp[j] += dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>相邻字符不同的最长路径</title>
    <url>/2023/04/09/%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/">2246. 相邻字符不同的最长路径</a></p>
<hr>
<p>给你一棵 <strong>树</strong>（即一个连通、无向、无环图），根节点是节点 <code>0</code> ，这棵树由编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点组成。用下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>parent</code> 来表示这棵树，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点，由于节点 <code>0</code> 是根节点，所以 <code>parent[0] == -1</code> 。</p>
<p>另给你一个字符串 <code>s</code> ，长度也是 <code>n</code> ，其中 <code>s[i]</code> 表示分配给节点 <code>i</code> 的字符。</p>
<p>请你找出路径上任意一对相邻节点都没有分配到相同字符的 <strong>最长路径</strong> ，并返回该路径的长度。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/03/25/testingdrawio.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：parent = [-1,0,0,1,1,2], s = &quot;abacbe&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：任意一对相邻节点字符都不同的最长路径是：0 -&gt; 1 -&gt; 3 。该路径的长度是 3 ，所以返回 3 。</span><br><span class="line">可以证明不存在满足上述条件且比 3 更长的路径。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/03/25/graph2drawio.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：parent = [-1,0,0,0], s = &quot;aabc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：任意一对相邻节点字符都不同的最长路径是：2 -&gt; 0 -&gt; 3 。该路径的长度为 3 ，所以返回 3 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>n == parent.length == s.length</code></li>
<li>  <code>1 &lt;= n &lt;= 10^5</code></li>
<li>  对所有 <code>i &gt;= 1</code> ，<code>0 &lt;= parent[i] &lt;= n - 1</code> 均成立</li>
<li>  <code>parent[0] == -1</code></li>
<li>  <code>parent</code> 表示一棵有效的树</li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><del>忘记不是二叉树了</del></p>
<p>思路就是求出每个节点x为根的子树最长路径（路径一端是x）<code>dp[x]</code>。</p>
<p>在x为根的子树中经过节点x的最长路径就是x的儿子节点中前两个最大dp值+1。</p>
<p>整棵树的最长路径肯定在某颗x为根的子树中且经过了x，求出最大值即可。</p>
<p>求子树的最大值和次大值之和，其实只需动态求出前i-1颗子树的最大值mx，然后将第i颗子树的值+mx维护最大值即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPath</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = parent.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i]!=<span class="number">-1</span>) g[parent[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="type">int</span> mx_son = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i:g[x]) &#123;</span><br><span class="line">                <span class="type">int</span> son = <span class="built_in">dfs</span>(i);</span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[x]) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, son+mx_son+<span class="number">1</span>);</span><br><span class="line">                    mx_son = <span class="built_in">max</span>(mx_son, son);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mx_son+<span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>树型dp</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵中严格递增的单元格数</title>
    <url>/2023/05/28/%E7%9F%A9%E9%98%B5%E4%B8%AD%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/">6456. 矩阵中严格递增的单元格数</a></p>
<hr>
<p>给你一个下标从 <strong>1</strong> 开始、大小为 <code>m x n</code> 的整数矩阵 <code>mat</code>，你可以选择任一单元格作为 <strong>起始单元格</strong> 。</p>
<p>从起始单元格出发，你可以移动到 <strong>同一行或同一列</strong> 中的任何其他单元格，但前提是目标单元格的值 <strong>严格大于</strong> 当前单元格的值。</p>
<p>你可以多次重复这一过程，从一个单元格移动到另一个单元格，直到无法再进行任何移动。</p>
<p>请你找出从某个单元开始访问矩阵所能访问的 <strong>单元格的最大数量</strong> 。</p>
<p>返回一个表示可访问单元格最大数量的整数。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2023/04/23/diag1drawio.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：mat = [[3,1],[3,4]]</span><br><span class="line">输出：2</span><br><span class="line">解释：上图展示了从第 1 行、第 2 列的单元格开始，可以访问 2 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 2 个单元格，因此答案是 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2023/04/23/diag3drawio.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：mat = [[1,1],[1,1]]</span><br><span class="line">输出：1</span><br><span class="line">解释：由于目标单元格必须严格大于当前单元格，在本示例中只能访问 1 个单元格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2023/04/23/diag4drawio.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：mat = [[3,1,6],[-9,5,7]]</span><br><span class="line">输出：4</span><br><span class="line">解释：上图展示了从第 2 行、第 1 列的单元格开始，可以访问 4 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 4 个单元格，因此答案是 4 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>m == mat.length</code> </li>
<li>  <code>n == mat[i].length</code> </li>
<li>  <code>1 &lt;= m, n &lt;= 10^5</code></li>
<li>  <code>1 &lt;= m * n &lt;= 10^5</code></li>
<li><code>-10^5 &lt;= mat[i][j] &lt;= 10^5</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>动态规划</p>
<p>只需要找到mat中每个值<code>mat[i][j]</code>作为移动终点的步数，记为状态$f_{i,j}$。答案就是所有状态中的最大值。</p>
<p>关键在于状态的转移。</p>
<p>根据题意，对于<code>mat[i][j]</code>，我们可以移动到第<code>i</code>行中比<code>mat[i][j]</code>大的位置上，实际上我们移动到这一行中比<code>mat[i][j]</code>大的最小元素就行。但是要注意这个最小元素在这一行中可能有多个。对于列也同样如此。</p>
<p>考虑$f_{i,j}$由哪些状态转移而来，如果我们按照<code>mat[i][j]</code>由小到大的顺序求状态值，那么显然在求$f_{i,j}$时，第i行中f最大值和第j行中f最大值都可以转移到$f_{i,j}$。所以可以用一个长度为n的数组rf来记录每一行的最大值；用一个长度为m的数组cf来记录每一列的最大值。这两个数组的只有等到相同的mat值的状态都更新后才更新。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxIncreasingCells</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; mp;</span><br><span class="line">        <span class="type">int</span> n = mat.<span class="built_in">size</span>(), m = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                mp[mat[i][j]].<span class="built_in">emplace_back</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>)); <span class="comment">// f[i][j] (i,j)作为移动的终点 所能访问的单元格数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rf</span><span class="params">(n)</span>, <span class="title">cf</span><span class="params">(m)</span></span>; <span class="comment">// rf[i] 第i行的最大f值, f[i][j] = max(rf[i], cf[i])+1;</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i,j]:mp) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [x,y]:j) &#123;</span><br><span class="line">                f[x][y] = <span class="built_in">max</span>(rf[x], cf[y])+<span class="number">1</span>;</span><br><span class="line">                ans = <span class="built_in">max</span>(f[x][y], ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [x,y]:j) &#123;</span><br><span class="line">                rf[x] = <span class="built_in">max</span>(rf[x], f[x][y]);</span><br><span class="line">                cf[y] = <span class="built_in">max</span>(cf[y], f[x][y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>另一种思路，可以将问题转化为图论问题。</p>
<p>这个问题关键在于状态转移时可能会超时。<br>我们构造一个极端案例在一行中有a个1和b个2，对于b个2的状态都可以由a个1的转台转移而来。时间复杂度O(ab)。但是如果建立一个虚拟节点状态在让a个1都转移到虚拟节点，然后虚拟节点再转移到b个2.这样时间复杂度O(a+b)</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">todo</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵查询可获得的最大分数</title>
    <url>/2023/04/09/%E7%9F%A9%E9%98%B5%E6%9F%A5%E8%AF%A2%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/">2503. 矩阵查询可获得的最大分数</a></p>
<hr>
<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code> 和一个大小为 <code>k</code> 的数组 <code>queries</code> 。</p>
<p>找出一个大小为 <code>k</code> 的数组 <code>answer</code> ，且满足对于每个整数 <code>queres[i]</code> ，你从矩阵 <strong>左上角</strong> 单元格开始，重复以下过程：</p>
<ul>
<li>如果 <code>queries[i]</code> <strong>严格</strong> 大于你当前所处位置单元格，如果该单元格是第一次访问，则获得 1 分，并且你可以移动到所有 <code>4</code> 个方向（上、下、左、右）上任一 <strong>相邻</strong> 单元格。</li>
<li>否则，你不能获得任何分，并且结束这一过程。</li>
</ul>
<p>在过程结束后，<code>answer[i]</code> 是你可以获得的最大分数。注意，对于每个查询，你可以访问同一个单元格 <strong>多次</strong> 。</p>
<p>返回结果数组 <code>answer</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/19/yetgriddrawio.png" alt="https://assets.leetcode.com/uploads/2022/10/19/yetgriddrawio.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]</span><br><span class="line">输出：[5,8,1]</span><br><span class="line">解释：上图展示了每个查询中访问并获得分数的单元格。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png" alt="https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[5,2,1],[1,1,2]], queries = [3]</span><br><span class="line">输出：[0]</span><br><span class="line">解释：无法获得分数，因为左上角单元格的值大于等于 3 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>2 &lt;= m, n &lt;= 1000</code></li>
<li><code>4 &lt;= m * n &lt;= 10^5</code></li>
<li><code>k == queries.length</code></li>
<li><code>1 &lt;= k &lt;= 10^4</code></li>
<li><code>1 &lt;= grid[i][j], queries[i] &lt;= 10^6</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>并查集做法</p>
<p>对于查询离线处理，将queries升序排序。</p>
<p>然后对于<code>queries[i]</code>，我们将矩阵中单元格所有值小于<code>queries[i]</code>的四周尝试连接（对于四周的值严格小于<code>queries[i]</code>即可连接）。对于<code>queries[i]</code>的答案就是查询并查集包含(0,0)单元格的集合大小。</p>
<p>如何实现<strong>将矩阵中所有值小于<code>queries[i]</code>的四周尝试连接</strong>。首先可以对矩阵按照（值，x，y）三元组字典序升序排序。接下来就可以用双指针高效处理值小于<code>queries[i]</code>的单元格。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; q)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = g.<span class="built_in">size</span>(), m = g[<span class="number">0</span>].<span class="built_in">size</span>(), sz = n*m;</span><br><span class="line">        <span class="comment">//并查集</span></span><br><span class="line">        <span class="type">int</span> st[sz]; <span class="built_in">memset</span>(st, <span class="number">-1</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; ufind = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="keyword">return</span> st[x]&lt;<span class="number">0</span> ? x : st[x] = <span class="built_in">ufind</span>(st[x]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//对矩阵离线处理</span></span><br><span class="line">        array&lt;<span class="type">int</span>,3&gt; a[sz];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                a[i*m+j] = &#123;g[i][j], i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a, a+sz);</span><br><span class="line">        <span class="comment">//查询离线处理</span></span><br><span class="line">        <span class="type">int</span> qsz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">id</span><span class="params">(qsz)</span></span>;</span><br><span class="line">        <span class="built_in">iota</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sort</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;<span class="keyword">return</span> q[x]&lt;q[y];&#125;);</span><br><span class="line">        <span class="comment">//将小于q[i]的相邻的点纳入同一集合。然后查询包含左上顶点的集合大小。</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(qsz)</span></span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:id) &#123;</span><br><span class="line">            <span class="type">int</span> v = q[i];</span><br><span class="line">            <span class="keyword">while</span> (p&lt;sz &amp;&amp; a[p][<span class="number">0</span>] &lt; v) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) &#123;</span><br><span class="line">                    <span class="type">int</span> x = a[p][<span class="number">1</span>] + (j<span class="number">-1</span>)%<span class="number">2</span>;</span><br><span class="line">                    <span class="type">int</span> y = a[p][<span class="number">2</span>] + (j<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (x&lt;<span class="number">0</span> || x&gt;=n || y&lt;<span class="number">0</span> || y&gt;=m || g[x][y]&gt;=v) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">int</span> fa = <span class="built_in">ufind</span>(a[p][<span class="number">1</span>]*m+a[p][<span class="number">2</span>]), fb = <span class="built_in">ufind</span>(x*m+y);</span><br><span class="line">                    <span class="keyword">if</span> (fa != fb) &#123;</span><br><span class="line">                        st[fa] += st[fb];</span><br><span class="line">                        st[fb] = fa;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">0</span>][<span class="number">0</span>] &lt; v) ans[i] = -st[<span class="built_in">ufind</span>(<span class="number">0</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>优先队列<br>对于查询离线处理，将queries升序排序。<br>我们动态的维护一个最小值优先队列，保证每个元素只会入队出队一次。<br>对于<code>queries[i]</code>，我们队列中小于<code>queries[i]</code>的值全部取出，然后在取出的同时将相邻的未入队的元素入队。这一次查询的答案就是所有已出队的元素个数。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;array&lt;<span class="type">int</span>,3&gt;, vector&lt;array&lt;<span class="type">int</span>,3&gt;&gt;, greater&lt;&gt;&gt; q;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>(), sz = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">id</span><span class="params">(sz)</span>, <span class="title">ans</span><span class="params">(sz)</span></span>;</span><br><span class="line">        <span class="built_in">iota</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sort</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> a, <span class="type">int</span> b)&#123;<span class="keyword">return</span> queries[a]&lt;queries[b];&#125;);</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;grid[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:id) &#123;</span><br><span class="line">            <span class="type">int</span> v = queries[i];</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">top</span>()[<span class="number">0</span>] &lt; v) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [val, x, y] = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>(); cnt++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) &#123;</span><br><span class="line">                    <span class="type">int</span> dx = x+(j<span class="number">-1</span>)%<span class="number">2</span>;</span><br><span class="line">                    <span class="type">int</span> dy = y+(j<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dx&lt;<span class="number">0</span> || dx&gt;=n || dy&lt;<span class="number">0</span> || dy&gt;=m || !grid[dx][dy]) <span class="keyword">continue</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;grid[dx][dy], dx, dy&#125;);</span><br><span class="line">                    grid[dx][dy] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵转换后的秩</title>
    <url>/2023/04/09/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%A7%A9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/rank-transform-of-a-matrix/">1632. 矩阵转换后的秩</a></p>
<hr>
<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> ，请你返回一个新的矩阵 <code>answer</code> ，其中 <code>answer[row][col]</code> 是 <code>matrix[row][col]</code> 的秩。</p>
<p>每个元素的 <strong>秩</strong> 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：</p>
<ul>
<li>  秩是从 1 开始的一个整数。</li>
<li>如果两个元素 <code>p</code> 和 <code>q</code> 在 <strong>同一行</strong> 或者 <strong>同一列</strong> ，那么：<ul>
<li>  如果 <code>p &lt; q</code> ，那么 <code>rank(p) &lt; rank(q)</code></li>
<li>  如果 <code>p == q</code> ，那么 <code>rank(p) == rank(q)</code></li>
<li>  如果 <code>p &gt; q</code> ，那么 <code>rank(p) &gt; rank(q)</code></li>
</ul>
</li>
<li>  <strong>秩</strong> 需要越 <strong>小</strong> 越好。</li>
</ul>
<p>题目保证按照上面规则 <code>answer</code> 数组是唯一的。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank1.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2],[3,4]]</span><br><span class="line">输出：[[1,2],[2,3]]</span><br><span class="line">解释：</span><br><span class="line">matrix[0][0] 的秩为 1 ，因为它是所在行和列的最小整数。</span><br><span class="line">matrix[0][1] 的秩为 2 ，因为 matrix[0][1] &gt; matrix[0][0] 且 matrix[0][0] 的秩为 1 。</span><br><span class="line">matrix[1][0] 的秩为 2 ，因为 matrix[1][0] &gt; matrix[0][0] 且 matrix[0][0] 的秩为 1 。</span><br><span class="line">matrix[1][1] 的秩为 3 ，因为 matrix[1][1] &gt; matrix[0][1]， matrix[1][1] &gt; matrix[1][0] 且 matrix[0][1] 和 matrix[1][0] 的秩都为 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank2.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[7,7],[7,7]]</span><br><span class="line">输出：[[1,1],[1,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank3.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]</span><br><span class="line">输出：[[4,2,3],[1,3,4],[5,1,6],[1,3,4]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank4.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[7,3,6],[1,4,5],[9,8,2]]</span><br><span class="line">输出：[[5,1,4],[1,2,3],[6,3,1]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>m == matrix.length</code></li>
<li>  <code>n == matrix[i].length</code></li>
<li>  <code>1 &lt;= m, n &lt;= 500</code></li>
<li><code>-10^9 &lt;= matrix[row][col] &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对于同一行同一列相同的数排名相同。<br>我们同行同列的相同值用并查集连接。</p>
<p>然后类似拓扑排序：<br>只需要将矩阵中元素下标按照元素值由小到大排序。<br>记录每一行每一列最近访问的位置。最近访问的位置与当前位置值不同则存在一条边。</p>
<p>用并查集根节点的记录排名。<br>最后对于每个节点的排名用并查集找根节点的排名即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> NINF = <span class="number">0xf3f3f3f3</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixRankTransform</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//元素坐标按元素值升序排序</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; idx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                idx.<span class="built_in">emplace_back</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(idx.<span class="built_in">begin</span>(), idx.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> matrix[a.first][a.second] &lt; matrix[b.first][b.second];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//dsu </span></span><br><span class="line">        <span class="type">int</span> st[<span class="number">1000000</span>];</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">-1</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; ufind = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="keyword">return</span> st[x]&lt;<span class="number">0</span>?x:st[x]=<span class="built_in">ufind</span>(st[x]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> enc = [](<span class="type">int</span> x,<span class="type">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x*<span class="number">1000</span>+y;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//行/列相同元素值，用并查集将下标纳入同一个集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp.<span class="built_in">count</span>(matrix[i][j])) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> [x,y] = mp[matrix[i][j]];</span><br><span class="line">                    <span class="type">int</span> fx = <span class="built_in">ufind</span>(<span class="built_in">enc</span>(x,y)), fy = <span class="built_in">ufind</span>(<span class="built_in">enc</span>(i,j));</span><br><span class="line">                    <span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">                    st[fy] = fx;</span><br><span class="line">                &#125;</span><br><span class="line">                mp[matrix[i][j]] = &#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp.<span class="built_in">count</span>(matrix[j][i])) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> [x,y] = mp[matrix[j][i]];</span><br><span class="line">                    <span class="type">int</span> fx = <span class="built_in">ufind</span>(<span class="built_in">enc</span>(x,y)), fy = <span class="built_in">ufind</span>(<span class="built_in">enc</span>(j,i));</span><br><span class="line">                    <span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">                    st[fy] = fx;</span><br><span class="line">                &#125;</span><br><span class="line">                mp[matrix[j][i]] = &#123;j,i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">r</span>(n,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;), <span class="built_in">c</span>(m, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;);<span class="comment">//行/列最近访问元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [i,j]:idx) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x1, y1] = r[i];</span><br><span class="line">            <span class="keyword">auto</span> [x2, y2] = c[j];</span><br><span class="line">            <span class="keyword">if</span> (x1 != <span class="number">-1</span> &amp;&amp; matrix[x1][y1] != matrix[i][j]) &#123;</span><br><span class="line">                <span class="type">int</span> v = <span class="built_in">max</span>(-st[<span class="built_in">ufind</span>(<span class="built_in">enc</span>(x1,y1))]+<span class="number">1</span>, -st[<span class="built_in">ufind</span>(<span class="built_in">enc</span>(i,j))]);</span><br><span class="line">                st[<span class="built_in">ufind</span>(<span class="built_in">enc</span>(i,j))] = -v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x2 != <span class="number">-1</span> &amp;&amp; matrix[x2][y2] != matrix[i][j]) &#123;</span><br><span class="line">                <span class="type">int</span> v = <span class="built_in">max</span>(-st[<span class="built_in">ufind</span>(<span class="built_in">enc</span>(x2,y2))]+<span class="number">1</span>, -st[<span class="built_in">ufind</span>(<span class="built_in">enc</span>(i,j))]);</span><br><span class="line">                st[<span class="built_in">ufind</span>(<span class="built_in">enc</span>(i,j))] = -v;</span><br><span class="line">            &#125;</span><br><span class="line">            r[i] = c[j] = &#123;i,j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                ans[i][j] = -st[<span class="built_in">ufind</span>(<span class="built_in">enc</span>(i,j))];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>破解保险箱</title>
    <url>/2023/04/09/%E7%A0%B4%E8%A7%A3%E4%BF%9D%E9%99%A9%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/cracking-the-safe/">753. 破解保险箱</a></p>
<hr>
<p>有一个需要密码才能打开的保险箱。密码是 <code>n</code> 位数, 密码的每一位是 <code>k</code> 位序列 <code>0, 1, ..., k-1</code> 中的一个 。</p>
<p>你可以随意输入密码，保险箱会自动记住最后 <code>n</code> 位输入，如果匹配，则能够打开保险箱。</p>
<p>举个例子，假设密码是 <code>&quot;345&quot;</code>，你可以输入 <code>&quot;012345&quot;</code> 来打开它，只是你输入了 6 个字符.</p>
<p>请返回一个能打开保险箱的最短字符串。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入: n = 1, k = 2</span><br><span class="line">输出: &quot;01&quot;</span><br><span class="line">说明: &quot;10&quot;也可以打开保险箱。</span><br></pre></td></tr></table></figure>
<p><strong>示例2:</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入: n = 2, k = 2</span><br><span class="line">输出: &quot;00110&quot;</span><br><span class="line">说明: &quot;01100&quot;, &quot;10011&quot;, &quot;11001&quot; 也能打开保险箱。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li> <code>n</code> 的范围是 <code>[1, 4]</code>。</li>
<li> <code>k</code> 的范围是 <code>[1, 10]</code>。</li>
<li><code>k^n</code> 最大可能为 <code>4096</code>。</li>
</ol>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>贪心</p>
<p>建立一个图，图中节点是n-1位的k进制数，若节点x移除高位尾接一个低位e（e &lt; k）转变为节点y，则x存在指向y的一条有向边，边权为e。</p>
<p>例：</p>
<p>n = 3, k = 2</p>
<p><img src="https://pic.leetcode-cn.com/ded26d0675ecbf5e6921523abd976f61e7bef51d9636bd6519f9c8e6f2d12efc-image.png"></p>
<p>图来自大佬<a href="https://leetcode.cn/u/newhar/">newhar</a></p>
<p>我们只需要不重复的遍历所有边那么构造出来的字符串就是最短的。</p>
<p>图中每个点有k个入度和k个出度，所以存在欧拉回路。</p>
<p>接下来可以从0号点出发，每次走最大边权的边，就可以走出一条欧拉回路。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">crackSafe</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sz = <span class="built_in">pow</span>(<span class="number">10</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(sz, k<span class="number">-1</span>)</span></span>;</span><br><span class="line">        string ans = <span class="built_in">string</span>(n<span class="number">-1</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left[cur] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> val = left[cur]--;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>+val);</span><br><span class="line">            cur = (cur*<span class="number">10</span>+val)%sz;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>Hierholzer 算法可以在一个欧拉图中找出欧拉回路</p>
<p>首先任选一点做为起点进行深搜，深搜每次经过一条边则删除。</p>
<p>当到达没有可选边的节点时，回溯并将指向该点的边加入栈中。即当节点x选择边<br>e走向节点y，而y无可选则的边，则回溯到x，然后将e加入到栈中。</p>
<p>最后完成深搜，栈中保存的就是逆向的欧拉回路，通过不断出栈得到的序列就是欧拉回路。</p>
<p>例：</p>
<p>n = 3, k = 2</p>
<p><img src="https://pic.leetcode-cn.com/ded26d0675ecbf5e6921523abd976f61e7bef51d9636bd6519f9c8e6f2d12efc-image.png"></p>
<p>图来自大佬<a href="https://leetcode.cn/u/newhar/">newhar</a></p>
<p>若选取00作为起点，每次尽可能选取边权较小的边。</p>
<p>00 通过0边走向 00，删除0边</p>
<p>00 通过1边走向 01，删除1边</p>
<p>01 通过0边走向 10，删除0边</p>
<p>10 通过0边走向 00，删除0边</p>
<p>00 无边可走，回到10，将0加入栈中</p>
<p>10 通过1边走向 01，删除1边</p>
<p>01 通过1边走向 11，删除1边</p>
<p>11 通过0边走向 10，删除0边</p>
<p>10 无边可走，回到11，将0加入栈中</p>
<p>11 通过1边走向 11，删除1边</p>
<p>11 无边可走，回到11，将1加入栈中</p>
<p>11 无边可走，回到01，将1加入栈中</p>
<p>01 无边可走，回到10，将1加入栈中</p>
<p>10 无边可走，回到01，将0加入栈中</p>
<p>01 无边可走，回到00，将1加入栈中</p>
<p>00 无边可走，回到00，将0加入栈中</p>
<p>出栈后序列为 0 1 0 1 1 1 0 0</p>
<p>在出栈序列前加上初始的位置在00，就得到了构造的最短字符串</p>
<p>代码实现中，这个串是逆序的也是正确的。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">crackSafe</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">1</span>; <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) sz *= k;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">st</span><span class="params">(sz, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        string ans;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">                <span class="type">int</span> y = (x*k+i)%sz;</span><br><span class="line">                <span class="keyword">if</span> (!st[y]) &#123;</span><br><span class="line">                    st[y] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(y);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(i+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans+<span class="built_in">string</span>(n<span class="number">-1</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title>移动石子直到连续 II</title>
    <url>/2023/04/09/%E7%A7%BB%E5%8A%A8%E7%9F%B3%E5%AD%90%E7%9B%B4%E5%88%B0%E8%BF%9E%E7%BB%AD%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/moving-stones-until-consecutive-ii/">1040. 移动石子直到连续 II</a></p>
<hr>
<p>在一个长度 <strong>无限</strong> 的数轴上，第 <code>i</code> 颗石子的位置为 <code>stones[i]</code>。如果一颗石子的位置最小/最大，那么该石子被称作 <strong>端点石子</strong> 。</p>
<p>每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。</p>
<p>值得注意的是，如果石子像 <code>stones = [1,2,5]</code> 这样，你将 <strong>无法</strong> 移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。</p>
<p>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。</p>
<p>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：<code>answer = [minimum_moves, maximum_moves]</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：[7,4,9]</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：</span><br><span class="line">我们可以移动一次，4 -&gt; 8，游戏结束。</span><br><span class="line">或者，我们可以移动两次 9 -&gt; 5，4 -&gt; 6，游戏结束。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：[6,5,4,3,10]</span><br><span class="line">输出：[2,3]</span><br><span class="line">解释：</span><br><span class="line">我们可以移动 3 -&gt; 8，接着是 10 -&gt; 7，游戏结束。</span><br><span class="line">或者，我们可以移动 3 -&gt; 7, 4 -&gt; 8, 5 -&gt; 9，游戏结束。</span><br><span class="line">注意，我们无法进行 10 -&gt; 2 这样的移动来结束游戏，因为这是不合要求的移动。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：[100,101,104,102,103]</span><br><span class="line">输出：[0,0]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>3 &lt;= stones.length &lt;= 10^4</code></li>
<li>  <code>1 &lt;= stones[i] &lt;= 10^9</code></li>
<li><code>stones[i]</code> 的值各不相同。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>假设共有n个石头，我们先将原先的石头位置排序。</p>
<p>对于最大移动步数，<strong>几乎</strong>就是相邻两个石头之间的空缺的位置数目。<br>由于每一次移动必定会使得移动的石头变为非端点，所以需要减去首两个石头之间的空缺数和末两个石头之间的空缺数的最小值。</p>
<p>对于最小移动步数，我们可以考虑每个长度为n的区间中已经存在了几个石头，空缺的石头数就是需要移动的步数，所有区间中需要移动的步数的最小值就是我们需要的答案。这里需要注意特殊情况，如果考虑每个石头作为区间的左端点，且区间中已存在n-1个位置且区间最右端的位置不存在，那么这种情况需要排除。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numMovesStonesII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(stones.begin(), stones.end())</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            mx += stones[i]-stones[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mx -= <span class="built_in">min</span>(stones[<span class="number">1</span>]-stones[<span class="number">0</span>]<span class="number">-1</span>, stones[n<span class="number">-1</span>]-stones[n<span class="number">-2</span>]<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> mn = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">lower_bound</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>(), stones[i]+n)-stones.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="comment">//在[stones[i], stones[i]+n)间已有p-i个数，</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (n-(p-i) != <span class="number">1</span> || st.<span class="built_in">count</span>(stones[i]+n<span class="number">-1</span>)) mn = <span class="built_in">min</span>(mn, n-(p-i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;mn, mx&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>移除子树后的二叉树高度</title>
    <url>/2023/04/09/%E7%A7%BB%E9%99%A4%E5%AD%90%E6%A0%91%E5%90%8E%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/">2458. 移除子树后的二叉树高度</a></p>
<hr>
<p>给你一棵 <strong>二叉树</strong> 的根节点 <code>root</code> ，树中有 <code>n</code> 个节点。每个节点都可以被分配一个从 <code>1</code> 到 <code>n</code> 且互不相同的值。另给你一个长度为 <code>m</code> 的数组 <code>queries</code> 。</p>
<p>你必须在树上执行 <code>m</code> 个 <strong>独立</strong> 的查询，其中第 <code>i</code> 个查询你需要执行以下操作：</p>
<ul>
<li>  从树中 <strong>移除</strong> 以 <code>queries[i]</code> 的值作为根节点的子树。题目所用测试用例保证 <code>queries[i]</code> <strong>不</strong> 等于根节点的值。</li>
</ul>
<p>返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是执行第 <code>i</code> 个查询后树的高度。</p>
<p><strong>注意：</strong></p>
<ul>
<li>  查询之间是独立的，所以在每个查询执行后，树会回到其 <strong>初始</strong> 状态。</li>
<li>树的高度是从根到树中某个节点的 <strong>最长简单路径中的边数</strong> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-1.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]</span><br><span class="line">输出：[2]</span><br><span class="line">解释：上图展示了从树中移除以 4 为根节点的子树。</span><br><span class="line">树的高度是 2（路径为 1 -&gt; 3 -&gt; 2）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-2.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]</span><br><span class="line">输出：[3,2,3,2]</span><br><span class="line">解释：执行下述查询：</span><br><span class="line">- 移除以 3 为根节点的子树。树的高度变为 3（路径为 5 -&gt; 8 -&gt; 2 -&gt; 4）。</span><br><span class="line">- 移除以 2 为根节点的子树。树的高度变为 2（路径为 5 -&gt; 8 -&gt; 1）。</span><br><span class="line">- 移除以 4 为根节点的子树。树的高度变为 3（路径为 5 -&gt; 8 -&gt; 2 -&gt; 6）。</span><br><span class="line">- 移除以 8 为根节点的子树。树的高度变为 2（路径为 5 -&gt; 9 -&gt; 3）。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  树中节点的数目是 <code>n</code></li>
<li>  <code>2 &lt;= n &lt;= 10^5</code></li>
<li>  <code>1 &lt;= Node.val &lt;= n</code></li>
<li>  树中的所有值 <strong>互不相同</strong></li>
<li>  <code>m == queries.length</code></li>
<li>  <code>1 &lt;= m &lt;= min(n, 10^4)</code></li>
<li>  <code>1 &lt;= queries[i] &lt;= n</code></li>
<li><code>queries[i] != root.val</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>两次 dfs<br>先dfs预处理出每个子树的高度。<br>第二次dfs直接求每个节点删除后的最大高度。<br>令$res_x$为删除x节点后整个树的最大高度, $d_x$为x的深度, $h_x$为x的高度<br>对于x左儿子节点$x_l$，$res_{x_{l}} = \max (d_x+h_{x_{r}}+1, res_x)$<br>对于x右儿子节点$x_r$，$res_{x_{r}} = \max (d_x+h_{x_{l}}+1, res_x)$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> H[<span class="number">100005</span>];</span><br><span class="line">    <span class="type">int</span> R[<span class="number">100005</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getH</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        n = <span class="built_in">max</span>(root-&gt;val, n);</span><br><span class="line">        <span class="keyword">return</span> H[root-&gt;val] = <span class="built_in">max</span>(<span class="built_in">getH</span>(root-&gt;left), <span class="built_in">getH</span>(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getR</span><span class="params">(TreeNode* root, <span class="type">int</span> lev, <span class="type">int</span> res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        R[root-&gt;val] = res;</span><br><span class="line">        <span class="built_in">getR</span>(root-&gt;left, lev+<span class="number">1</span>, <span class="built_in">max</span>(res, root-&gt;right ? H[root-&gt;right-&gt;val]+lev+<span class="number">1</span> : lev));</span><br><span class="line">        <span class="built_in">getR</span>(root-&gt;right, lev+<span class="number">1</span>, <span class="built_in">max</span>(res, root-&gt;left ? H[root-&gt;left-&gt;val]+lev+<span class="number">1</span> : lev));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">treeQueries</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">getH</span>(root);</span><br><span class="line">        <span class="built_in">getR</span>(root, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; i:queries) i = R[i];</span><br><span class="line">        <span class="keyword">return</span> queries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>dfs 序<br>通过dfs序可以将每颗子树转化成一个区间，每个区间的第一个元素就是这个子树的根，将树上问题转成区间问题。<br>对于这个问题每次删除一个点后子树被删除，也就是说删除了一个子区间，我们只需要看前缀和后缀区间最深的一个节点即可。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line">    <span class="type">int</span> tlk;</span><br><span class="line">    <span class="type">int</span> l[N], r[N], h[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        l[root-&gt;val] = ++tlk;</span><br><span class="line">        h[tlk] = d;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, d+<span class="number">1</span>); <span class="built_in">dfs</span>(root-&gt;right, d+<span class="number">1</span>);</span><br><span class="line">        r[root-&gt;val] = tlk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">treeQueries</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// for (int i=1; i&lt;=n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; l[i] &lt;&lt; &#x27; &#x27; &lt;&lt; r[i] &lt;&lt; &quot; &quot; &lt;&lt; h[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="type">int</span> n = tlk;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rt, <span class="built_in">lmx</span>(n+<span class="number">2</span>, <span class="number">0</span>), <span class="built_in">rmx</span>(n+<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) lmx[i] = <span class="built_in">max</span>(lmx[i<span class="number">-1</span>], h[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n; i&gt;=<span class="number">0</span>; i--) rmx[i] = <span class="built_in">max</span>(rmx[i+<span class="number">1</span>], h[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:queries) &#123;</span><br><span class="line">            rt.<span class="built_in">push_back</span>(<span class="built_in">max</span>(lmx[l[i]<span class="number">-1</span>], rmx[r[i]+<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>树型dp</tag>
      </tags>
  </entry>
  <entry>
    <title>移除所有载有违禁货物车厢所需的最少时间</title>
    <url>/2023/04/09/%E7%A7%BB%E9%99%A4%E6%89%80%E6%9C%89%E8%BD%BD%E6%9C%89%E8%BF%9D%E7%A6%81%E8%B4%A7%E7%89%A9%E8%BD%A6%E5%8E%A2%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/">2167. 移除所有载有违禁货物车厢所需的最少时间</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始的二进制字符串 <code>s</code> ，表示一个列车车厢序列。<code>s[i] = &#39;0&#39;</code> 表示第 <code>i</code> 节车厢 <strong>不</strong> 含违禁货物，而 <code>s[i] = &#39;1&#39;</code> 表示第 <code>i</code> 节车厢含违禁货物。</p>
<p>作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个：</p>
<ol>
<li> 从列车 <strong>左</strong> 端移除一节车厢（即移除 <code>s[0]</code>），用去 1 单位时间。</li>
<li> 从列车 <strong>右</strong> 端移除一节车厢（即移除 <code>s[s.length - 1]</code>），用去 1 单位时间。</li>
<li> 从列车车厢序列的 <strong>任意位置</strong> 移除一节车厢，用去 2 单位时间。</li>
</ol>
<p>返回移除所有载有违禁货物车厢所需要的 <strong>最少</strong> 单位时间数。</p>
<p>注意，空的列车车厢序列视为没有车厢含违禁货物。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;1100101&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">一种从序列中移除所有载有违禁货物的车厢的方法是：</span><br><span class="line">- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。</span><br><span class="line">- 从右端移除一节车厢 1 次。所用时间是 1 。</span><br><span class="line">- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。</span><br><span class="line">总时间是 2 + 1 + 2 = 5 。</span><br><span class="line"></span><br><span class="line">一种替代方法是：</span><br><span class="line">- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。</span><br><span class="line">- 从右端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。</span><br><span class="line">总时间也是 2 + 3 = 5 。</span><br><span class="line"></span><br><span class="line">5 是移除所有载有违禁货物的车厢所需要的最少单位时间数。</span><br><span class="line">没有其他方法能够用更少的时间移除这些车厢。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;0010&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">一种从序列中移除所有载有违禁货物的车厢的方法是：</span><br><span class="line">- 从左端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。</span><br><span class="line">总时间是 3.</span><br><span class="line"></span><br><span class="line">另一种从序列中移除所有载有违禁货物的车厢的方法是：</span><br><span class="line">- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。</span><br><span class="line">总时间是 2.</span><br><span class="line"></span><br><span class="line">另一种从序列中移除所有载有违禁货物的车厢的方法是：</span><br><span class="line">- 从右端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。</span><br><span class="line">总时间是 2.</span><br><span class="line"></span><br><span class="line">2 是移除所有载有违禁货物的车厢所需要的最少单位时间数。</span><br><span class="line">没有其他方法能够用更少的时间移除这些车厢。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 2 * 10^5</code></li>
<li><code>s[i]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>p[i]</code> 为前i个数的前缀和，<code>p[0] = 0</code></p>
<p>设<code>0&lt;=l&lt;=r&lt;=n</code></p>
<p>我们让<code>s[0...l-1]</code>的数执行操作1，用时<code>l</code></p>
<p>我们让<code>s[r...n-1]</code>的数执行操作2，用时<code>n-r</code></p>
<p>我们让<code>s[l...r-1]</code>的数执行操作3，用时<code>2*(p[r]-p[l])</code></p>
<p>总用时<code>2*(p[r]-p[l])+l+n-r = 2*p[r]-r-(2*p[l]-l)+n</code><br>令<code>A[x] = 2*p[x]-x</code></p>
<p>则总用时<code>A[r]-A[l]+n</code></p>
<p>问题转化为找<code>A[r]</code>前最大的数<code>A[l]</code>,使得总用时最小</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        p[i] 为前i个数的前缀和，p[0] = 0</span></span><br><span class="line"><span class="comment">        s[l...r-1]的数是操作3，用时2*(p[r]-p[l])</span></span><br><span class="line"><span class="comment">        s[0...l-1]的数是操作1，用时l</span></span><br><span class="line"><span class="comment">        s[r...n-1]的数是操作2，用时n-r</span></span><br><span class="line"><span class="comment">        总用时2*(p[r]-p[l])+l+n-r = 2*p[r]-r-(2*p[l]-l)+n</span></span><br><span class="line"><span class="comment">        令A[x] = 2*p[x]-x</span></span><br><span class="line"><span class="comment">        则总用时A[r]-A[l]+n, 0&lt;=l&lt;=r&lt;=n</span></span><br><span class="line"><span class="comment">        问题转化找A[r]前最大的数A[l],使得总用时最小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTime</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            p[i] = p[i<span class="number">-1</span>] + s[i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            p[i] = p[i]*<span class="number">2</span>-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = n, mx=p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, p[i]);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, p[i]-mx+n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>令<code>pre[i]</code>为0…i先用操作1再用操作3的最小单位时间数。</p>
<p>令<code>puf[i]</code>为i..n-1先用操作3再用操作2的最小单位时间数。</p>
<p>这样答案就是<code>max(pre[i]+suf[i+1])</code></p>
<p>考虑<code>pre[i]</code>状态转移</p>
<p>如果<code>s[i] = &#39;1&#39;</code>，可以考虑用什么操作删除<code>s[i]</code>，若操作3删除则可由<code>pre[i-1] + 2</code>转移；若用操作1删除则由<code>i+1</code>转移。即<code>pre[i] = min(pre[i-1]+2, i+1)</code>。</p>
<p>如果<code>s[i] = &#39;0&#39;</code>，<code>pre[i] = pre[i-1]</code>。</p>
<p><code>suf[i]</code>状态转同理</p>
<p>当<code>s[i] = &#39;1&#39;</code>，<code>suf[i] = min(suf[i+1]+2, n-i)</code></p>
<p>当<code>s[i] = &#39;0&#39;</code>，<code>suf[i] = suf[i+1]</code></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTime</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n, s[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>)</span>, <span class="title">suf</span><span class="params">(n, s[n<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) pre[i] = <span class="built_in">min</span>(pre[i<span class="number">-1</span>]+<span class="number">2</span>, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> pre[i] = pre[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) suf[i] = <span class="built_in">min</span>(suf[i+<span class="number">1</span>]+<span class="number">2</span>, n-i);</span><br><span class="line">            <span class="keyword">else</span> suf[i] = suf[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, pre[i<span class="number">-1</span>]+suf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>第 N 个神奇数字</title>
    <url>/2023/04/09/%E7%AC%AC%20N%20%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/nth-magical-number/">878. 第 N 个神奇数字</a></p>
<hr>
<p>一个正整数如果能被 <code>a</code> 或 <code>b</code> 整除，那么它是神奇的。</p>
<p>给定三个整数 <code>n</code> , <code>a</code> , <code>b</code> ，返回第 <code>n</code> 个神奇的数字。因为答案可能很大，所以返回答案 <strong>对</strong> <code>10^9 + 7</code> <strong>取模</strong> 后的值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 1, a = 2, b = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 4, a = 2, b = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 10^9</code></li>
<li><code>2 &lt;= a, b &lt;= 4 * 10^4</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>现在枚举一个数x</p>
<p>对于小于等于x的a的倍数有$p1=\lfloor \frac{x}{a} \rfloor$</p>
<p>对于小于等于x的b的倍数有$p2=\lfloor \frac{x}{b} \rfloor$</p>
<p>对于小于等于x的既是a的倍数也是b的倍数有$p3=\lfloor \frac{x}{lcm(a,b)} \rfloor$</p>
<p>p1+p2重复计算了一次p3</p>
<p>所以令f(x)为小于等于x的a或b的倍数的个数。f(x)=p1+p2-p3。</p>
<p>显然f(x)具有单调性。</p>
<p>我们可以二分找到第一个满足f(x)&gt;=n的x。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthMagicalNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        ll l = <span class="number">1</span>, r = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            ll m = (r-l)/<span class="number">2</span>+l;</span><br><span class="line">            ll k = m/a+m/b-m/<span class="built_in">lcm</span>(a,b);</span><br><span class="line">            <span class="keyword">if</span> (k&lt;n) &#123;</span><br><span class="line">                l = m+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r%(<span class="built_in">int</span>(<span class="number">1e9</span>+<span class="number">7</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>统计上升四元组</title>
    <url>/2023/04/09/%E7%BB%9F%E8%AE%A1%E4%B8%8A%E5%8D%87%E5%9B%9B%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/count-increasing-quadruplets/">6340. 统计上升四元组</a></p>
<hr>
<p>给你一个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，它包含 <code>1</code> 到 <code>n</code> 的所有数字，请你返回上升四元组的数目。</p>
<p>如果一个四元组 <code>(i, j, k, l)</code> 满足以下条件，我们称它是上升的：</p>
<ul>
<li>  <code>0 &lt;= i &lt; j &lt; k &lt; l &lt; n</code> 且</li>
<li><code>nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l]</code> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,2,4,5]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 当 i = 0 ，j = 1 ，k = 2 且 l = 3 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。</span><br><span class="line">- 当 i = 0 ，j = 1 ，k = 2 且 l = 4 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。</span><br><span class="line">没有其他的四元组，所以我们返回 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：0</span><br><span class="line">解释：只存在一个四元组 i = 0 ，j = 1 ，k = 2 ，l = 3 ，但是 nums[j] &lt; nums[k] ，所以我们返回 0 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>4 &lt;= nums.length &lt;= 4000</code></li>
<li>  <code>1 &lt;= nums[i] &lt;= nums.length</code></li>
<li><code>nums</code> 中所有数字 <strong>互不相同</strong> ，<code>nums</code> 是一个排列。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><del>没想到开这么大的数组</del></p>
<p>令<code>l[i][j]</code>为下标小于等于i且值小于等于j的个数， <code>r[i][j]</code>下标大于等于i且值大于等于j的个数。</p>
<p>显然如果<code>j！=nums[i]</code>，那么<code>l[i][j]</code>相当于下标严格小于i且值严格小于j的个数，<code>r[i][j]</code>相当于下标严格大于i且值严格大于j的个数。</p>
<p>以<code>numns[i]</code>和<code>nums[j]</code>作为中间两个元素的四元组个数为<code>l[i][nums[j]] * r[j][nums[i]]</code></p>
<p>答案为$\sum \limits_{i=0}^{n-1} \sum \limits_{j=i+1}^{n-1} l[i][nums[j]] * r[j][nums[i]]$</p>
<p>总时间复杂度$O(n^2)$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 4001</span></span><br><span class="line"><span class="type">int</span> l[N][N], r[N][N]; <span class="comment">//l[i][j] 下标&lt;=i且值&lt;=j的个数， r[i][j] 下标&gt;=i且值&gt;=j的个数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        枚举i和j，i&lt;j，nums[i]&gt;nums[j]</span></span><br><span class="line"><span class="comment">        由于nums[j]!= nums[i]，l[i][nums[j]]是位置小于等于i，值严格小于nums[j]的个数；r[j][nums[i]]是位置大于等于i，值严格大于nums[i]的个数；</span></span><br><span class="line"><span class="comment">        以numns[i]和nums[j]作为中间两个元素的四元组个数为：(l[i][nums[j]]) * (r[j][nums[i]])</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countQuadruplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(l, <span class="number">0</span>, <span class="built_in">sizeof</span>(l));</span><br><span class="line">        <span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="built_in">sizeof</span>(r));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            l[i][nums[i]]++;</span><br><span class="line">            r[i][nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span>) l[i][j] += l[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j<span class="number">-1</span>&gt;=<span class="number">1</span>) l[i][j] += l[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; j<span class="number">-1</span>&gt;=<span class="number">1</span>) l[i][j] -= l[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=n; j&gt;=<span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i+<span class="number">1</span>&lt;n) r[i][j] += r[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j+<span class="number">1</span>&lt;=n) r[i][j] += r[i][j+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i+<span class="number">1</span>&lt;n &amp;&amp; j+<span class="number">1</span>&lt;=n) r[i][j] -= r[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]&gt;nums[j]) &#123;</span><br><span class="line">                    ans += l[i][nums[j]]*r[j][nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>统计中位数为 K 的子数组</title>
    <url>/2023/04/09/%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BA%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/count-subarrays-with-median-k/">2488. 统计中位数为 K 的子数组</a></p>
<hr>
<p>给你一个长度为 <code>n</code> 的数组 <code>nums</code> ，该数组由从 <code>1</code> 到 <code>n</code> 的 <strong>不同</strong> 整数组成。另给你一个正整数 <code>k</code> 。</p>
<p>统计并返回 <code>nums</code> 中的 <strong>中位数</strong> 等于 <code>k</code> 的非空子数组的数目。</p>
<p><strong>注意：</strong></p>
<ul>
<li>数组的中位数是按 <strong>递增</strong> 顺序排列后位于 <strong>中间</strong> 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 <strong>左</strong> 的那个元素。<ul>
<li>  例如，<code>[2,3,1,4]</code> 的中位数是 <code>2</code> ，<code>[8,4,3,5,1]</code> 的中位数是 <code>4</code> 。</li>
</ul>
</li>
<li>子数组是数组中的一个连续部分。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,4,5], k = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：中位数等于 4 的子数组有：[4]、[4,5] 和 [1,4,5] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1], k = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：[3] 是唯一一个中位数等于 3 的子数组。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>n == nums.length</code></li>
<li>  <code>1 &lt;= n &lt;= 10^5</code></li>
<li>  <code>1 &lt;= nums[i], k &lt;= n</code></li>
<li><code>nums</code> 中的整数互不相同</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先值得注意的一点是每个数都不同，所以k在数组中只会出现一次。</p>
<p>我们还是使用哈希表统计前缀中的信息。</p>
<p>如果在一个区间里k是中位数，那么这个区间中大于k的数a和小于k的数b存在关系a=b或者a=b+1</p>
<p>所以只需要统计前缀中大于k的数和小于k的数的差即可。因此我们可以做转化将数组中大于k的数视为1，小于k的数视为-1，k则视为0。</p>
<p>设前缀和<code>ps[i]</code>为转化后的数组前i个数的和。<br>这样当两个前缀和<code>ps[i]-ps[j]=0 or 1</code>时，区间<code>[j+1,i]</code>可能是一个合法区间。<br>为啥是可能？因为这个k有可能并不在这个区间中。区间必须包含了k这个位置才是合法区间。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), k)-nums.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> ps = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            ps += (nums[i]==k?<span class="number">0</span>:(nums[i]&lt;k?<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (i&lt;p) mp[ps]++;</span><br><span class="line">            <span class="keyword">else</span> ans += mp[ps] + mp[ps<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>统计公平数对的数目</title>
    <url>/2023/04/09/%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/">6355. 统计公平数对的数目</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，和两个整数 <code>lower</code> 和 <code>upper</code> ，返回 <strong>公平数对的数目</strong> 。</p>
<p>如果 <code>(i, j)</code> 数对满足以下情况，则认为它是一个 <strong>公平数对</strong> ：</p>
<ul>
<li>  <code>0 &lt;= i &lt; j &lt; n</code>，且</li>
<li><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,7,4,4,5], lower = 3, upper = 6</span><br><span class="line">输出：6</span><br><span class="line">解释：共计 6 个公平数对：(0,3)、(0,4)、(0,5)、(1,3)、(1,4) 和 (1,5) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,7,9,2,5], lower = 11, upper = 11</span><br><span class="line">输出：1</span><br><span class="line">解释：只有单个公平数对：(2,3) 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li>  <code>nums.length == n</code></li>
<li>  <code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>-10^9 &lt;= lower &lt;= upper &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>排序后不会影响数对对数。<br>排序后二分即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countFairPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            ans += <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>()+i, upper-nums[i]) </span><br><span class="line">            - <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>()+i, lower-nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>统计包含每个点的矩形数目</title>
    <url>/2023/04/09/%E7%BB%9F%E8%AE%A1%E5%8C%85%E5%90%AB%E6%AF%8F%E4%B8%AA%E7%82%B9%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/count-number-of-rectangles-containing-each-point/">2250. 统计包含每个点的矩形数目</a></p>
<hr>
<p>给你一个二维整数数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [li, hi]</code> 表示第 <code>i</code> 个矩形长为 <code>li</code> 高为 <code>hi</code> 。给你一个二维整数数组 <code>points</code> ，其中 <code>points[j] = [xj, yj]</code> 是坐标为 <code>(xj, yj)</code> 的一个点。</p>
<p>第 <code>i</code> 个矩形的 <strong>左下角</strong> 在 <code>(0, 0)</code> 处，<strong>右上角</strong> 在 <code>(li, hi)</code> 。</p>
<p>请你返回一个整数数组 <code>count</code> ，长度为 <code>points.length</code>，其中 <code>count[j]</code>是 <strong>包含</strong> 第 <code>j</code> 个点的矩形数目。</p>
<p>如果 <code>0 &lt;= xj &lt;= li</code> 且 <code>0 &lt;= yj &lt;= hi</code> ，那么我们说第 <code>i</code> 个矩形包含第 <code>j</code> 个点。如果一个点刚好在矩形的 <strong>边上</strong> ，这个点也被视为被矩形包含。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/03/02/example1.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]</span><br><span class="line">输出：[2,1]</span><br><span class="line">解释：</span><br><span class="line">第一个矩形不包含任何点。</span><br><span class="line">第二个矩形只包含一个点 (2, 1) 。</span><br><span class="line">第三个矩形包含点 (2, 1) 和 (1, 4) 。</span><br><span class="line">包含点 (2, 1) 的矩形数目为 2 。</span><br><span class="line">包含点 (1, 4) 的矩形数目为 1 。</span><br><span class="line">所以，我们返回 [2, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/03/02/example2.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]</span><br><span class="line">输出：[1,3]</span><br><span class="line">解释：</span><br><span class="line">第一个矩形只包含点 (1, 1) 。</span><br><span class="line">第二个矩形只包含点 (1, 1) 。</span><br><span class="line">第三个矩形包含点 (1, 3) 和 (1, 1) 。</span><br><span class="line">包含点 (1, 3) 的矩形数目为 1 。</span><br><span class="line">包含点 (1, 1) 的矩形数目为 3 。</span><br><span class="line">所以，我们返回 [1, 3] 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= rectangles.length, points.length &lt;= 5 * 10^4</code></li>
<li>  <code>rectangles[i].length == points[j].length == 2</code></li>
<li>  <code>1 &lt;= li, xj &lt;= 10^9</code></li>
<li>  <code>1 &lt;= hi, yj &lt;= 100</code></li>
<li>  所有 <code>rectangles</code> <strong>互不相同</strong> 。</li>
<li>所有 <code>points</code> <strong>互不相同</strong> 。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由于y的取值在1到100。所以可以只对x查找，采取二分最多100次。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countRectangles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rectangles, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v[<span class="number">105</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:rectangles) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=i[<span class="number">1</span>]; j++) v[j].<span class="built_in">push_back</span>(i[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">105</span>; i++) <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(), v[i].<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:points) &#123;</span><br><span class="line">            <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i[<span class="number">1</span>]; j&lt;<span class="number">105</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> cnt = v[j].<span class="built_in">end</span>()-<span class="built_in">lower_bound</span>(v[j].<span class="built_in">begin</span>(), v[j].<span class="built_in">end</span>(), i[<span class="number">0</span>]);</span><br><span class="line">                mx = <span class="built_in">max</span>(mx, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">            rt.<span class="built_in">push_back</span>(mx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>统计可以被 K 整除的下标对数目</title>
    <url>/2023/04/09/%E7%BB%9F%E8%AE%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%20K%20%E6%95%B4%E9%99%A4%E7%9A%84%E4%B8%8B%E6%A0%87%E5%AF%B9%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/count-array-pairs-divisible-by-k/">2183. 统计可以被 K 整除的下标对数目</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>k</code> ，返回满足下述条件的下标对 <code>(i, j)</code> 的数目：</p>
<ul>
<li>  <code>0 &lt;= i &lt; j &lt;= n - 1</code> 且</li>
<li><code>nums[i] * nums[j]</code> 能被 <code>k</code> 整除。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5], k = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">共有 7 对下标的对应积可以被 2 整除：</span><br><span class="line">(0, 1)、(0, 3)、(1, 2)、(1, 3)、(1, 4)、(2, 3) 和 (3, 4)</span><br><span class="line">它们的积分别是 2、4、6、8、10、12 和 20 。</span><br><span class="line">其他下标对，例如 (0, 2) 和 (2, 4) 的乘积分别是 3 和 15 ，都无法被 2 整除。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4], k = 5</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在对应积可以被 5 整除的下标对。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i], k &lt;= 10^5</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>一个经典问题<br>已知正整数<code>a</code>，<code>b</code>，求正整数<code>c</code>，使得<code>a*b</code>被<code>c</code>整除。<code>b</code>一定是<code>c/gcd(c,a)</code>的倍数。</p>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们求所有<code>nums[j]（j&lt;n）</code>结尾的数对数量之和便是答案。</p>
<p>假设当前遍历到<code>nums[j]</code>，且以<code>j</code>作为数对的第二关键字，那么有多少<code>i（i&lt;=j）</code>作为第一关键字呢？</p>
<p>我们知道这样的<code>i</code>满足条件：<code>nums[i]</code>是<code>k/gcd(nums[j],k)</code>的倍数。</p>
<p>因此可以在遍历时维护哈希表<code>cnt</code>，<code>cnt[i]</code>表示<code>i</code>的倍数的个数。</p>
<p>以<code>nums[j]</code>结尾的数对个数有<code>cnt[k/gcd(nums[j], k)]</code>个，然后将<code>nums[j]</code>的因子在哈希表中记录。</p>
<p>求<code>nums[j]</code>的因子的时间复杂度为$O(\sqrt{nums[j]})$，总时间复杂度为$O(n^{\frac{3}{2}})$</p>
<p>当然我们也预处理出所有数的因子然后存储起来。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cnt[N];</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) &#123;</span><br><span class="line">            ans += cnt[k/<span class="built_in">gcd</span>(i, k)];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j*j&lt;=i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i%j == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt[j]++;</span><br><span class="line">                    <span class="keyword">if</span> (i/j != j) cnt[i/j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>每次我们将<code>k/gcd(nums[j], k)</code>记录到哈希表，以<code>nums[j]</code>结尾的数对个数就是哈希表中为<code>nums[j]</code>的因子出现次数。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">long</span> <span class="type">long</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [a, b]:mp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i%a == <span class="number">0</span>) ans += b;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[k/<span class="built_in">gcd</span>(i, k)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>我们知道这样的<code>i</code>满足条件：<code>nums[i]</code>是<code>k/gcd(nums[j],k)</code>的倍数。实际上就是k因子的倍数。</p>
<p>在遍历时维护哈希表<code>cnt</code>，<code>cnt[i]</code>表示<code>i</code>的倍数的个数。</p>
<p>以<code>nums[j]</code>结尾的数对个数有<code>cnt[k/gcd(nums[j], k)]</code>个，然后将能除尽<code>nums[j]</code>的k因子在哈希表中记录。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cnt[N];</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i*i&lt;=k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k%i == <span class="number">0</span>) &#123;</span><br><span class="line">                p.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">if</span> (k/i != i) p.<span class="built_in">push_back</span>(k/i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) &#123;</span><br><span class="line">            ans += cnt[k/<span class="built_in">gcd</span>(i, k)];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j:p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i%j == <span class="number">0</span>) cnt[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法四："><a href="#方法四：" class="headerlink" title="方法四："></a>方法四：</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>用哈希表统计每个数<code>i</code>出现的次数<code>cnt[i]</code></p>
<p>然后类似筛选法统计<code>i</code>的倍数的个数<code>times[i]</code>。</p>
<p>对于<code>nums[j]</code>，满足<code>nums[i]*nums[j]（0&lt;=i&lt;n）</code>被<code>k</code>整除的个数有<code>times[k/gcd(nums[j],k)]</code>个。统计到答案中。</p>
<p>排除掉<code>i!=j</code>的<code>nums[i]</code>，那就是满足条件：<code>nums[j]</code>为<code>k/gcd(nums[j],k)]</code>的倍数。在统计答案中减去1。</p>
<p>剩余情况由于任意<code>0&lt;=i,j&lt;n, i!=j</code>的<code>nums[i]*nums[j]</code>都一一对应<code>nums[j]*nums[i]</code>，于是所有统计数除以2便是答案。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ll cnt[N];</span><br><span class="line">    ll times[N];</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) cnt[i]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&lt;N; j+=i) &#123;</span><br><span class="line">                times[i] += cnt[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) &#123;</span><br><span class="line">            <span class="type">int</span> t = k/<span class="built_in">gcd</span>(i, k);</span><br><span class="line">            ans += times[t];</span><br><span class="line">            <span class="keyword">if</span> (i%t == <span class="number">0</span>) ans--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>统计可能的树根数目</title>
    <url>/2023/04/09/%E7%BB%9F%E8%AE%A1%E5%8F%AF%E8%83%BD%E7%9A%84%E6%A0%91%E6%A0%B9%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/count-number-of-possible-root-nodes/">2581. 统计可能的树根数目</a></p>
<hr>
<p>Alice 有一棵 <code>n</code> 个节点的树，节点编号为 <code>0</code> 到 <code>n - 1</code> 。树用一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [ai, bi]</code> ，表示树中节点 <code>ai</code> 和 <code>bi</code> 之间有一条边。</p>
<p>Alice 想要 Bob 找到这棵树的根。她允许 Bob 对这棵树进行若干次 <strong>猜测</strong> 。每一次猜测，Bob 做如下事情：</p>
<ul>
<li>  选择两个 <strong>不相等</strong> 的整数 <code>u</code> 和 <code>v</code> ，且树中必须存在边 <code>[u, v]</code> 。</li>
<li>  Bob 猜测树中 <code>u</code> 是 <code>v</code> 的 <strong>父节点</strong> 。</li>
</ul>
<p>Bob 的猜测用二维整数数组 <code>guesses</code> 表示，其中 <code>guesses[j] = [uj, vj]</code> 表示 Bob 猜 <code>uj</code> 是 <code>vj</code> 的父节点。</p>
<p>Alice 非常懒，她不想逐个回答 Bob 的猜测，只告诉 Bob 这些猜测里面 <strong>至少</strong> 有 <code>k</code> 个猜测的结果为 <code>true</code> 。</p>
<p>给你二维整数数组 <code>edges</code> ，Bob 的所有猜测和整数 <code>k</code> ，请你返回可能成为树根的 <strong>节点数目</strong> 。如果没有这样的树，则返回 <code>0</code>。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/12/19/ex-1.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">根为节点 0 ，正确的猜测为 [1,3], [0,1], [2,4]</span><br><span class="line">根为节点 1 ，正确的猜测为 [1,3], [1,0], [2,4]</span><br><span class="line">根为节点 2 ，正确的猜测为 [1,3], [1,0], [2,4]</span><br><span class="line">根为节点 3 ，正确的猜测为 [1,0], [2,4]</span><br><span class="line">根为节点 4 ，正确的猜测为 [1,3], [1,0]</span><br><span class="line">节点 0 ，1 或 2 为根时，可以得到 3 个正确的猜测。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/12/19/ex-2.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">根为节点 0 ，正确的猜测为 [3,4]</span><br><span class="line">根为节点 1 ，正确的猜测为 [1,0], [3,4]</span><br><span class="line">根为节点 2 ，正确的猜测为 [1,0], [2,1], [3,4]</span><br><span class="line">根为节点 3 ，正确的猜测为 [1,0], [2,1], [3,2], [3,4]</span><br><span class="line">根为节点 4 ，正确的猜测为 [1,0], [2,1], [3,2]</span><br><span class="line">任何节点为根，都至少有 1 个正确的猜测。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>edges.length == n - 1</code></li>
<li>  <code>2 &lt;= n &lt;= 10^5</code></li>
<li>  <code>1 &lt;= guesses.length &lt;= 10^5</code></li>
<li>  <code>0 &lt;= ai, bi, uj, vj &lt;= n - 1</code></li>
<li>  <code>ai != bi</code></li>
<li>  <code>uj != vj</code></li>
<li>  <code>edges</code> 表示一棵有效的树。</li>
<li>  <code>guesses[j]</code> 是树中的一条边。</li>
<li>  <code>guesses</code> 是唯一的。</li>
<li><code>0 &lt;= k &lt;= guesses.length</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们可以尝试暴力的做法，对于每个节点都尝试作为根，然后从该节点开始深搜或广搜统计bob的猜想有多少个为true，即为cnt，这样做的时间复杂度$O(n^2)$。</p>
<p>我们发现如果已经计算了以x为根的cnt。<br>那么与x相邻的y其实是可以利用x的统计数来优化的。<br>试想从x作为根到y作为根其实除了x到y这条边之外其余边都不需要发生变化。<br>因此可以$O(1)$计算出相邻节点的cnt。</p>
<p>我们可以先通过dfs求出任意节点的cnt，然后再从该节点开始dfs求出其他节点的cnt。对于每个节点的cnt若大于等于k则增加统计数。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, ans = <span class="number">0</span>, K = <span class="number">0</span>;</span><br><span class="line">    set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; st;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; g[<span class="number">100005</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getcnt</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">count</span>(&#123;fa,u&#125;)) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fa == i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">getcnt</span>(i, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">count</span>(&#123;fa,u&#125;)) &#123;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">count</span>(&#123;u, fa&#125;)) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; fa &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt; (cnt&gt;=K) &lt;&lt; endl;</span></span><br><span class="line">        ans += cnt &gt;= K;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fa == i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i, u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">count</span>(&#123;fa,u&#125;)) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">count</span>(&#123;u, fa&#125;)) &#123;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rootCount</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; gu, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        K = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            g[i[<span class="number">0</span>]].<span class="built_in">push_back</span>(i[<span class="number">1</span>]);</span><br><span class="line">            g[i[<span class="number">1</span>]].<span class="built_in">push_back</span>(i[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:gu) &#123;</span><br><span class="line">            st.<span class="built_in">insert</span>(&#123;i[<span class="number">0</span>], i[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getcnt</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>树型dp</tag>
      </tags>
  </entry>
  <entry>
    <title>统计同位异构字符串数目</title>
    <url>/2023/04/09/%E7%BB%9F%E8%AE%A1%E5%90%8C%E4%BD%8D%E5%BC%82%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/count-anagrams/">2514. 统计同位异构字符串数目</a></p>
<hr>
<p>给你一个字符串 <code>s</code> ，它包含一个或者多个单词。单词之间用单个空格 <code>&#39; &#39;</code> 隔开。</p>
<p>如果字符串 <code>t</code> 中第 <code>i</code> 个单词是 <code>s</code> 中第 <code>i</code> 个单词的一个 <strong>排列</strong> ，那么我们称字符串 <code>t</code> 是字符串 <code>s</code> 的同位异构字符串。</p>
<ul>
<li>  比方说，<code>&quot;acb dfe&quot;</code> 是 <code>&quot;abc def&quot;</code> 的同位异构字符串，但是 <code>&quot;def cab&quot;</code> 和 <code>&quot;adc bef&quot;</code> 不是。</li>
</ul>
<p>请你返回 <code>s</code> 的同位异构字符串的数目，由于答案可能很大，请你将它对 <code>10^9 + 7</code> <strong>取余</strong> 后返回。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;too hot&quot;</span><br><span class="line">输出：18</span><br><span class="line">解释：输入字符串的一些同位异构字符串为 &quot;too hot&quot; ，&quot;oot hot&quot; ，&quot;oto toh&quot; ，&quot;too toh&quot; 以及 &quot;too oht&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：输入字符串只有一个同位异构字符串。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 10^5</code></li>
<li>  <code>s</code> 只包含小写英文字母和空格 <code>&#39; &#39;</code> 。</li>
<li>相邻单词之间由单个空格隔开。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>求出每个单词的多重全排列，然后根据乘法原理，累乘即可。</p>
<p>设第i个单词的字母a出现的次数为$a_i$</p>
<p>答案是$\prod \frac{(a_i+b_i+\cdots+z_i)!}{a_i!b_i!\cdots z_i!}$</p>
<p>我们可以预处理阶乘的逆元减小时间复杂度。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="type">const</span> ll MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function">ll <span class="title">fpow</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">        ll rt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p&amp;<span class="number">1</span>) rt *= x, rt%=MOD;</span><br><span class="line">            x = x*x; x%=MOD;</span><br><span class="line">            p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countAnagrams</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        ll fac[n], inv[n];</span><br><span class="line">        fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            fac[i] = fac[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        inv[n<span class="number">-1</span>] = <span class="built_in">fpow</span>(fac[n<span class="number">-1</span>], MOD<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            inv[i] = inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> c[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                ans *= fac[<span class="built_in">accumulate</span>(c, c+<span class="number">26</span>, <span class="number">0</span>)];</span><br><span class="line">                ans %= MOD;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">26</span>; j++) &#123;</span><br><span class="line">                    ans *= inv[c[j]];</span><br><span class="line">                    ans %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line">            &#125; <span class="keyword">else</span> c[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>统计回文子序列数目</title>
    <url>/2023/04/09/%E7%BB%9F%E8%AE%A1%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/count-palindromic-subsequences/">2484. 统计回文子序列数目</a></p>
<hr>
<p>给你数字字符串 <code>s</code> ，请你返回 <code>s</code> 中长度为 <code>5</code> 的 <strong>回文子序列</strong> 数目。由于答案可能很大，请你将答案对 <code>10^9 + 7</code> <strong>取余</strong> 后返回。</p>
<p><strong>提示：</strong></p>
<ul>
<li>  如果一个字符串从前往后和从后往前读相同，那么它是 <strong>回文字符串</strong> 。</li>
<li>子序列是一个字符串中删除若干个字符后，不改变字符顺序，剩余字符构成的字符串。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;103301&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">总共有 6 长度为 5 的子序列：&quot;10330&quot; ，&quot;10331&quot; ，&quot;10301&quot; ，&quot;10301&quot; ，&quot;13301&quot; ，&quot;03301&quot; 。</span><br><span class="line">它们中有两个（都是 &quot;10301&quot;）是回文的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;0000000&quot;</span><br><span class="line">输出：21</span><br><span class="line">解释：所有 21 个长度为 5 的子序列都是 &quot;00000&quot; ，都是回文的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;9999900000&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：仅有的两个回文子序列是 &quot;99999&quot; 和 &quot;00000&quot; 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 10^4</code></li>
<li><code>s</code> 只包含数字字符。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>两次dp，枚举分割线。</p>
<p>设<code>p[i][j][k]</code>为前i位以j和k结尾的子序列个数, <code>s[i][j][k]</code>为后i位以j和k结尾的子序列个数。</p>
<p>这时答案为 $\sum \limits_{i=2}^{n-3} \sum \limits_{j=0}^{9} \sum \limits_{k=0}^{9}p[i-1][j][k]*p[i+1][k][j]$</p>
<p>总时间复杂度$O(|\Sigma|^2n)$，$\Sigma$字符集大小不超过10，$n$为字符串长度</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="type">const</span> ll M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    ll pcnt[<span class="number">10</span>], scnt[<span class="number">10</span>];</span><br><span class="line">    ll pdp[<span class="number">10005</span>][<span class="number">10</span>][<span class="number">10</span>], sdp[<span class="number">10005</span>][<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPalindromes</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u = s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            pcnt[u]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i&gt;<span class="number">0</span>) pdp[i][j][k] = pdp[i<span class="number">-1</span>][j][k];</span><br><span class="line">                    <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; u == k) pdp[i][j][k] += pcnt[j] + (k==j?<span class="number">-1</span>:<span class="number">0</span>);</span><br><span class="line">                    pdp[i][j][k]%=M;</span><br><span class="line">                    <span class="comment">// if (j == 0 &amp;&amp; k == 0)</span></span><br><span class="line">                    <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;,&quot; &lt;&lt; k &lt;&lt; &quot;=&quot; &lt;&lt; pdp[i][j][k] &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> u = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            scnt[u]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i&lt;n<span class="number">-1</span>) sdp[i][j][k] = sdp[i+<span class="number">1</span>][j][k];</span><br><span class="line">                    <span class="keyword">if</span> (i&lt;n<span class="number">-1</span> &amp;&amp; u == j) sdp[i][j][k] += scnt[k] + (k==j?<span class="number">-1</span>:<span class="number">0</span>);</span><br><span class="line">                    pdp[i][j][k]%=M;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;n<span class="number">-2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++) &#123;</span><br><span class="line">                    ans += pdp[i<span class="number">-1</span>][j][k]*sdp[i+<span class="number">1</span>][k][j];   </span><br><span class="line">                    ans %= M;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>统计好子数组的数目</title>
    <url>/2023/04/09/%E7%BB%9F%E8%AE%A1%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/count-the-number-of-good-subarrays/">6293. 统计好子数组的数目</a></p>
<hr>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <code>nums</code> 中 <strong>好</strong> 子数组的数目。</p>
<p>一个子数组 <code>arr</code> 如果有 <strong>至少</strong> <code>k</code> 对下标 <code>(i, j)</code> 满足 <code>i &lt; j</code> 且 <code>arr[i] == arr[j]</code> ，那么称它是一个 <strong>好</strong> 子数组。</p>
<p><strong>子数组</strong> 是原数组中一段连续 <strong>非空</strong> 的元素序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], k = 10</span><br><span class="line">输出：1</span><br><span class="line">解释：唯一的好子数组是这个数组本身。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,1,4,3,2,2,4], k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：总共有 4 个不同的好子数组：</span><br><span class="line">- [3,1,4,3,2,2] 有 2 对。</span><br><span class="line">- [3,1,4,3,2,2,4] 有 3 对。</span><br><span class="line">- [1,4,3,2,2,4] 有 2 对。</span><br><span class="line">- [4,3,2,2,4] 有 2 对。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i], k &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>滑动窗口</p>
<p>维护窗口<code>[l,r]</code>内的满足<code>arr[i] ==arr[j]</code>的下标对<code>(i,j)</code>的个数<code>cnt</code>恰好小于<code>k</code>。此时在<code>[0, l-1]</code>中任意数为开头，<code>r</code>结束的子数组均为好子数组。</p>
<p>我们需要一个哈希表<code>mp</code>统计窗口内每个数<code>i</code>出现了多少次<code>mp[i]</code>。<br>在<code>r</code>增长前，区间内<code>nums[r]</code>的个数就是<code>cnt</code>增长的个数。<br>在<code>l</code>增长后，区间内<code>nums[l]</code>的个数就是<code>cnt</code>减少的个数。</p>
<p>算法过程</p>
<p><code>r</code>不断增长，对于每个<code>r</code>，窗口<code>[l,r]</code>内<code>cnt</code>若不小于<code>k</code>则不断让<code>l</code>增长，当<code>cnt</code>小于<code>k</code>时，累加以<code>r</code>作为结尾的合法子数组个数<code>l</code>。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countGood</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,ll&gt; mp;</span><br><span class="line">        ll cnt = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r=<span class="number">0</span>, l=<span class="number">0</span>; r&lt;nums.<span class="built_in">size</span>(); r++) &#123;</span><br><span class="line">            cnt += mp[nums[r]]++;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt;= k) &#123;</span><br><span class="line">                cnt -= --mp[nums[l]];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//[0,l)区间元素个数l</span></span><br><span class="line">            ans += l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>统计子树中城市之间最大距离</title>
    <url>/2023/04/09/%E7%BB%9F%E8%AE%A1%E5%AD%90%E6%A0%91%E4%B8%AD%E5%9F%8E%E5%B8%82%E4%B9%8B%E9%97%B4%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/">1617. 统计子树中城市之间最大距离</a></p>
<hr>
<p>给你 <code>n</code> 个城市，编号为从 <code>1</code> 到 <code>n</code> 。同时给你一个大小为 <code>n-1</code> 的数组 <code>edges</code> ，其中 <code>edges[i] = [ui, vi]</code> 表示城市 <code>ui</code> 和 <code>vi</code> 之间有一条双向边。题目保证任意城市之间只有唯一的一条路径。换句话说，所有城市形成了一棵 <strong>树</strong> 。</p>
<p>一棵 <strong>子树</strong> 是城市的一个子集，且子集中任意城市之间可以通过子集中的其他城市和边到达。两个子树被认为不一样的条件是至少有一个城市在其中一棵子树中存在，但在另一棵子树中不存在。</p>
<p>对于 <code>d</code> 从 <code>1</code> 到 <code>n-1</code> ，请你找到城市间 <strong>最大距离</strong> 恰好为 <code>d</code> 的所有子树数目。</p>
<p>请你返回一个大小为 <code>n-1</code> 的数组，其中第 <code>d</code> 个元素（<strong>下标从 1 开始</strong>）是城市间 <strong>最大距离</strong> 恰好等于 <code>d</code> 的子树数目。</p>
<p><strong>请注意</strong>，两个城市间距离定义为它们之间需要经过的边的数目。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/p1.png"></strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 4, edges = [[1,2],[2,3],[2,4]]</span><br><span class="line">输出：[3,4,0]</span><br><span class="line">解释：</span><br><span class="line">子树 &#123;1,2&#125;, &#123;2,3&#125; 和 &#123;2,4&#125; 最大距离都是 1 。</span><br><span class="line">子树 &#123;1,2,3&#125;, &#123;1,2,4&#125;, &#123;2,3,4&#125; 和 &#123;1,2,3,4&#125; 最大距离都为 2 。</span><br><span class="line">不存在城市间最大距离为 3 的子树。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 2, edges = [[1,2]]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 3, edges = [[1,2],[2,3]]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>2 &lt;= n &lt;= 15</code></li>
<li>  <code>edges.length == n-1</code></li>
<li>  <code>edges[i].length == 2</code></li>
<li>  <code>1 &lt;= ui, vi &lt;= n</code></li>
<li>题目保证 <code>(ui, vi)</code> 所表示的边互不相同。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>枚举15个节点的子集。判断是否在一个连通块。</p>
<p>若在同一个连通块，则求树的直径d。对应城市间最大距离恰好为d的所有子树数目+1.</p>
<p>求树的直径，先从任意点v出发开始bfs，然后找到与v最远的节点u。然后从u开始bfs，离u最远的节点直接的距离就是直径。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; g[<span class="number">20</span>];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSubgraphsForEachDiameter</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            i[<span class="number">0</span>]--; i[<span class="number">1</span>]--;</span><br><span class="line">            g[i[<span class="number">0</span>]].<span class="built_in">push_back</span>(i[<span class="number">1</span>]);</span><br><span class="line">            g[i[<span class="number">1</span>]].<span class="built_in">push_back</span>(i[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> get_diameter = [&amp;](<span class="type">int</span> mask) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; <span class="built_in">v1</span>(n, INF), <span class="built_in">v2</span>(n, INF);</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((mask&gt;&gt;s&amp;<span class="number">1</span>) == <span class="number">0</span>) s++;</span><br><span class="line">            v1[s] = <span class="number">0</span>;</span><br><span class="line">            queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">            q.<span class="built_in">push</span>(s);</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v:g[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((mask&gt;&gt;v&amp;<span class="number">1</span>) &amp;&amp; v1[v] &gt; v1[u]+<span class="number">1</span>) &#123;</span><br><span class="line">                        v1[v] = v1[u]+<span class="number">1</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> mx = s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mask&gt;&gt;i&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] == INF) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 不连通</span></span><br><span class="line">                    <span class="keyword">if</span> (v1[mx] &lt; v1[i]) mx = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">            v2[mx] = <span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(mx);</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v:g[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((mask&gt;&gt;v&amp;<span class="number">1</span>) &amp;&amp; v2[v] &gt; v2[u]+<span class="number">1</span>) &#123;</span><br><span class="line">                        v2[v] = v2[u]+<span class="number">1</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> dia = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mask&gt;&gt;i&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                    dia = <span class="built_in">max</span>(dia, v2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dia;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">1</span>&lt;&lt;n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;sz; i++) &#123;</span><br><span class="line">            <span class="type">int</span> dia = <span class="built_in">get_diameter</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (dia &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; dia &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">                ans[dia<span class="number">-1</span>]++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>网格图中最少访问的格子数</title>
    <url>/2023/04/09/%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%B0%91%E8%AE%BF%E9%97%AE%E7%9A%84%E6%A0%BC%E5%AD%90%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/">6353. 网格图中最少访问的格子数</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始的 <code>m x n</code> 整数矩阵 <code>grid</code> 。你一开始的位置在 <strong>左上角</strong> 格子 <code>(0, 0)</code> 。</p>
<p>当你在格子 <code>(i, j)</code> 的时候，你可以移动到以下格子之一：</p>
<ul>
<li>  满足 <code>j &lt; k &lt;= grid[i][j] + j</code> 的格子 <code>(i, k)</code> （向右移动），或者</li>
<li>  满足 <code>i &lt; k &lt;= grid[i][j] + i</code> 的格子 <code>(k, j)</code> （向下移动）。</li>
</ul>
<p>请你返回到达 <strong>右下角</strong> 格子 <code>(m - 1, n - 1)</code> 需要经过的最少移动格子数，如果无法到达右下角格子，请你返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/01/25/ex1.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]</span><br><span class="line">输出：4</span><br><span class="line">解释：上图展示了到达右下角格子经过的 4 个格子。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/01/25/ex2.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]</span><br><span class="line">输出：3</span><br><span class="line">解释：上图展示了到达右下角格子经过的 3 个格子。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/01/26/ex3.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[2,1,0],[1,0,0]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：无法到达右下角格子。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>m == grid.length</code></li>
<li>  <code>n == grid[i].length</code></li>
<li>  <code>1 &lt;= m, n &lt;= 10^5</code></li>
<li>  <code>1 &lt;= m * n &lt;= 10^5</code></li>
<li>  <code>0 &lt;= grid[i][j] &lt; m * n</code></li>
<li><code>grid[m - 1][n - 1] == 0</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>可以从(0,0)出发广搜到(n-1,m-1)，广搜的每个节点(x,y)需要将区间<code>[x+1, grid[x][y]+y]</code>和区间<code>[y+1, grid[x][y]+x]</code>的节点加入到队列中，但是如果队列中已经存在这些值，会造成大量重复遍历，最终超时。</p>
<p>所以可以将入队后的点删除，我们发现删除的点都是连续的，所以可以记录所有行和列已删除的范围，然后每次将没有删除的节点加入到队列中，每个节点只会进一次队列，而且每个节点也只会删除一次。时间复杂度$O(n*m)$。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumVisitedCells</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row_mx</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">col_mx</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> stp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [x,y] = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (x == n<span class="number">-1</span> &amp;&amp; y == m<span class="number">-1</span>) <span class="keyword">return</span> stp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="built_in">max</span>(row_mx[x]+<span class="number">1</span>, y+<span class="number">1</span>); i&lt;=<span class="built_in">min</span>(y+grid[x][y], m<span class="number">-1</span>); i++) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(x, i);</span><br><span class="line">                    row_mx[x] = <span class="built_in">max</span>(row_mx[x], i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="built_in">max</span>(col_mx[y]+<span class="number">1</span>, x+<span class="number">1</span>); i&lt;=<span class="built_in">min</span>(x+grid[x][y], n<span class="number">-1</span>); i++) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(i, y);</span><br><span class="line">                    col_mx[y] = <span class="built_in">max</span>(col_mx[y], i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>美丽子集的数目</title>
    <url>/2023/04/09/%E7%BE%8E%E4%B8%BD%E5%AD%90%E9%9B%86%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/the-number-of-beautiful-subsets/">6352. 美丽子集的数目</a></p>
<hr>
<p>给你一个由正整数组成的数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p>
<p>如果 <code>nums</code> 的子集中，任意两个整数的绝对差均不等于 <code>k</code> ，则认为该子数组是一个 <strong>美丽</strong> 子集。</p>
<p>返回数组 <code>nums</code> 中 <strong>非空</strong> 且 <strong>美丽</strong> 的子集数目。</p>
<p><code>nums</code> 的子集定义为：可以经由 <code>nums</code> 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,4,6], k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：数组 nums 中的美丽子集有：[2], [4], [6], [2, 6] 。</span><br><span class="line">可以证明数组 [2,4,6] 中只存在 4 个美丽子集。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：数组 nums 中的美丽数组有：[1] 。</span><br><span class="line">可以证明数组 [1] 中只存在 1 个美丽子集。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 20</code></li>
<li><code>1 &lt;= nums[i], k &lt;= 1000</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>枚举子集</p>
<p>用dfs枚举，并用哈希表记录已枚举元素，当前为x，存在x-k或x+k则剪枝，时间复杂度$O(2^n)$</p>
<p>用二进制枚举，需要$O(n)$检查子集元素中是否存在差值为k的两个元素，时间复杂度$O(n2^n)$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> N 5005</span></span><br><span class="line">    <span class="type">int</span> vis[N];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">beautifulSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((nums[i]-k&lt;<span class="number">0</span> || vis[nums[i]-k]==<span class="number">0</span>) &amp;&amp; (nums[i]+k&gt;=N || vis[nums[i]+k]==<span class="number">0</span>)) &#123;</span><br><span class="line">                vis[nums[i]]++;</span><br><span class="line">                <span class="built_in">dfs</span>(i+<span class="number">1</span>);</span><br><span class="line">                vis[nums[i]]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>将n个数模k分组。</p>
<p>任何不同组中的两个数不会形成差值为k。所以我们可以单独求出每个组中的合法子集，然后根据乘法原理累乘起来即可。</p>
<p>每一组中相邻两个数是的差是k的倍数。我们它们排序去重得到a，并统计每个数出现的个数cnt。</p>
<p>观察到只有相邻两个数才会出现差值为k，考虑用dp。定义$f_{i}$为前i个数可以选出的合法子集个数。</p>
<p>对于前i个数可构成的子集分为包含第i个数和不包含第i个数。</p>
<p>当不包含第i个数时，则规模转为前n-1个数构成的合法子集。</p>
<p>当包含第i个数时，需要考虑第i个和第i-1个的差值是否为k。</p>
<ul>
<li>若差值为k，则我们不能选择第i-1个值。所以只能从前i-2个数中选子集。</li>
<li>若差值不为k，则可以从前i-1个数中选子集。</li>
</ul>
<p>注意包含第i个数时，由于第i个数出现的次数是$cnt_i$。所以可以选取这$cnt_i$个数的非空子集$2^{cnt_i}-1$。</p>
<p>所以状态转移方程为:</p>
<ul>
<li>$f_i = f_{i-1} + f_{i-2}*(2^{cnt_i-1}), a_i = a_{i-1}+k$</li>
<li>$f_i = f_{i-1}*(2^{cnt_i}), a_i != a_{i-1}+k$</li>
</ul>
<p>边界状态$f_{0} = 2^{cnt_0}, f_{-1} = 1$</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">beautifulSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; mp; <span class="comment">// mp[i][j] 第i组中j出现的次数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) &#123;</span><br><span class="line">            mp[i%k][i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i,j]:mp) &#123;</span><br><span class="line">            <span class="type">int</span> n = j.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(j.<span class="built_in">begin</span>(), j.<span class="built_in">end</span>());</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">            function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;a[p].second);</span><br><span class="line">                <span class="keyword">if</span> (f[p]) <span class="keyword">return</span> f[p];</span><br><span class="line">                <span class="keyword">if</span> (a[p].first == a[p<span class="number">-1</span>].first+k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> f[p] = <span class="built_in">dfs</span>(p<span class="number">-1</span>) + <span class="built_in">dfs</span>(p<span class="number">-2</span>)*((<span class="number">1</span>&lt;&lt;a[p].second)<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> f[p] = <span class="built_in">dfs</span>(p<span class="number">-1</span>)*(<span class="number">1</span>&lt;&lt;a[p].second);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            ans *= <span class="built_in">dfs</span>(n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转子数组得到最大的数组值</title>
    <url>/2023/05/14/%E7%BF%BB%E8%BD%AC%E5%AD%90%E6%95%B0%E7%BB%84%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0%E7%BB%84%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value/">1330. 翻转子数组得到最大的数组值</a></p>
<hr>
<p>给你一个整数数组 <code>nums</code> 。「数组值」定义为所有满足 <code>0 &lt;= i &lt; nums.length-1</code> 的 <code>|nums[i]-nums[i+1]|</code> 的和。</p>
<p>你可以选择给定数组的任意子数组，并将该子数组翻转。但你只能执行这个操作 <strong>一次</strong> 。</p>
<p>请你找到可行的最大 <strong>数组值</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,5,4]</span><br><span class="line">输出：10</span><br><span class="line">解释：通过翻转子数组 [3,1,5] ，数组变成 [2,5,1,3,4] ，数组值为 10 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,4,9,24,2,1,10]</span><br><span class="line">输出：68</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 3*10^4</code></li>
<li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对于选取的反转区间是原数组的一个前缀或后缀可以花$O(n)$求出交换后的最大值。</p>
<p>设$p = \sum \limits_{i=1}^{n-1} |nums[i]-nums[i-1]|$，也就是在交换之前的数组值。</p>
<p>不妨设现在交换的是$[0,i]$，那么交换后的数组值将变为$p-|nums[i+1]-nums[i]|+|nums[i+1]-nums[0]|$</p>
<p>因此可以预处理前缀和后缀<br>$\max \limits_{i=1}^{n-1} (p-|nums[i]-nums[i-1]|+|nums[i]-nums[0]|)$，$\max \limits_{i=0}^{n-2} (p-|nums[i]-nums[i+1]|+|nums[n-1]-nums[i]|)$作为候选答案</p>
<p>对于反转区间在为$[i,j],i&gt;0, j&lt;n-1 $</p>
<p>我们设$a = nums[i-1], b = nums[i], c = nums[j], d = nums[j+1]$</p>
<p>这时交换后的数组值变化量为：<br>$\Delta = |a-c|+|b-d|-|a-b|-|c-d|$</p>
<p>根据abcd的大小关系去掉绝对值有24种情况。</p>
<p>剩余情况可以枚举最小的两个数，再根据以下恒等式进行变化。<br>枚举最小的两个数有$C_{4}^{2}=6$种情况，由于对称性可以去除一半的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">|x - y| = <span class="built_in">max</span>(x, y) - <span class="built_in">min</span>(x, y)</span><br><span class="line">x + y = <span class="built_in">max</span>(x, y) + <span class="built_in">min</span>(x, y)</span><br><span class="line">x + y + |x - y| = <span class="number">2</span> * <span class="built_in">max</span>(x, y)</span><br><span class="line">x + y - |x - y| = <span class="number">2</span> * <span class="built_in">min</span>(x, y)</span><br></pre></td></tr></table></figure>

<p>当最小的两个数是a和b时，即$max(a,b)\le min(c,d)$。</p>
<p>$\begin{array}{lll}<br>\Delta &amp; = &amp; |a-c|+|b-d|-|a-b|-|c-d| \<br> &amp; = &amp; c-a+d-b-|a-b|-|c-d| \<br> &amp; = &amp; c+d-|c-d| - (a+b+|a-b|) \<br> &amp; = &amp; 2<em>min(c,d)-2</em>max(a,b) \ge 0 \<br>\end{array}$</p>
<p>由对称性，可以化简最小的两个数是c和d，即$max(c,d)\le min(a,b)$。</p>
<p>这两种情况可以让数组值增大。</p>
<p>当最小的两个数是a和c时，即$max(a,c)\le min(b,d)$。</p>
<p>$\begin{array}{lll}<br>\Delta &amp; = &amp; |a-c|+|b-d|-|a-b|-|c-d| \<br> &amp; = &amp; |a-c|+|b-d|-(b-a)-(d-c) \<br> &amp; = &amp; 2<em>max(a,c)-2</em>min(b,d) \le 0 \<br>\end{array}$</p>
<p>由对称性，可以化简最小的两个数是b和d，即$max(a,c)\le min(b,d)$。</p>
<p>这两种情况会让数组值减小。</p>
<p>当最小的两个数是a和d时，即$max(a,d)\le min(b,c)$。</p>
<p>$\begin{array}{lll}<br>\Delta &amp; = &amp; |a-c|+|b-d|-|a-b|-|c-d| \<br> &amp; = &amp; c-a+d-b-(b-a)-(c-d) \<br> &amp; = &amp; 0 \<br>\end{array}$</p>
<p>由对称性，可以化简最小的两个数是b和c，即$max(b,c)\le min(a,d)$。</p>
<p>这两种情况不会让数组值变化。</p>
<p>综上，只需要考虑$max(a,b)\le min(c,d)$和$max(c,d)\le min(a,b)$。</p>
<p>我们设计求出$max(a,b)\le min(c,d)$这种情况的算法。再由于对称性，然后将数组反转，用相同的算法再求一次即可得到$max(c,d)\le min(a,b)$的答案。</p>
<p>我们维护一个前缀$[1,i]$中$max(nums[i-1], nums[i])$的最小值，记为$m_i$。然后对于交换区间是以i为右端点的最优值为$max(nums[i-1], nums[i])-m_{i-1}$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValueAfterReverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) p += <span class="built_in">abs</span>(nums[i]-nums[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; p &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="type">int</span> ans = p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) ans = <span class="built_in">max</span>(ans, p+<span class="built_in">abs</span>(nums[i]-nums[<span class="number">0</span>])-<span class="built_in">abs</span>(nums[i]-nums[i<span class="number">-1</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) ans = <span class="built_in">max</span>(ans, p+<span class="built_in">abs</span>(nums[n<span class="number">-1</span>]-nums[i])-<span class="built_in">abs</span>(nums[i]-nums[i+<span class="number">1</span>]));</span><br><span class="line">        <span class="comment">// cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="keyword">auto</span> fun = [&amp;]() &#123;</span><br><span class="line">            <span class="type">int</span> mn = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; i++) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, p+<span class="number">2</span>*(<span class="built_in">min</span>(nums[i<span class="number">-1</span>], nums[i])-mn));</span><br><span class="line">                mn = <span class="built_in">min</span>(mn, <span class="built_in">max</span>(nums[i<span class="number">-1</span>], nums[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>化简公式</tag>
      </tags>
  </entry>
  <entry>
    <title>花括号展开 II</title>
    <url>/2023/04/09/%E8%8A%B1%E6%8B%AC%E5%8F%B7%E5%B1%95%E5%BC%80%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/brace-expansion-ii/">1096. 花括号展开 II</a></p>
<hr>
<p>如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。</p>
<p>花括号展开的表达式可以看作一个由 <strong>花括号</strong>、<strong>逗号</strong> 和 <strong>小写英文字母</strong> 组成的字符串，定义下面几条语法规则：</p>
<ul>
<li>如果只给出单一的元素 <code>x</code>，那么表达式表示的字符串就只有 <code>&quot;x&quot;</code>。<code>R(x) = &#123;x&#125;</code><ul>
<li>  例如，表达式 <code>&quot;a&quot;</code> 表示字符串 <code>&quot;a&quot;</code>。</li>
<li>  而表达式 <code>&quot;w&quot;</code> 就表示字符串 <code>&quot;w&quot;</code>。</li>
</ul>
</li>
<li>当两个或多个表达式并列，以逗号分隔，我们取这些表达式中元素的并集。<code>R(&#123;e_1,e_2,...&#125;) = R(e_1) ∪ R(e_2) ∪ ...</code><ul>
<li>  例如，表达式 <code>&quot;&#123;a,b,c&#125;&quot;</code> 表示字符串 <code>&quot;a&quot;,&quot;b&quot;,&quot;c&quot;</code>。</li>
<li>  而表达式 <code>&quot;&#123;&#123;a,b&#125;,&#123;b,c&#125;&#125;&quot;</code> 也可以表示字符串 <code>&quot;a&quot;,&quot;b&quot;,&quot;c&quot;</code>。</li>
</ul>
</li>
<li>要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。<code>R(e_1 + e_2) = &#123;a + b for (a, b) in R(e_1) × R(e_2)&#125;</code><ul>
<li>  例如，表达式 <code>&quot;&#123;a,b&#125;&#123;c,d&#125;&quot;</code> 表示字符串 <code>&quot;ac&quot;,&quot;ad&quot;,&quot;bc&quot;,&quot;bd&quot;</code>。</li>
</ul>
</li>
<li>表达式之间允许嵌套，单一元素与表达式的连接也是允许的。<ul>
<li>  例如，表达式 <code>&quot;a&#123;b,c,d&#125;&quot;</code> 表示字符串 <code>&quot;ab&quot;,&quot;ac&quot;,&quot;ad&quot;​​​​​​</code>。</li>
<li>  例如，表达式 <code>&quot;a&#123;b,c&#125;&#123;d,e&#125;f&#123;g,h&#125;&quot;</code> 可以表示字符串 <code>&quot;abdfg&quot;, &quot;abdfh&quot;, &quot;abefg&quot;, &quot;abefh&quot;, &quot;acdfg&quot;, &quot;acdfh&quot;, &quot;acefg&quot;, &quot;acefh&quot;</code>。</li>
</ul>
</li>
</ul>
<p>给出表示基于给定语法规则的表达式 <code>expression</code>，返回它所表示的所有字符串组成的有序列表。</p>
<p>假如你希望以「集合」的概念了解此题，也可以通过点击 “<strong>显示英文描述</strong>” 获取详情。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：expression = &quot;&#123;a,b&#125;&#123;c,&#123;d,e&#125;&#125;&quot;</span><br><span class="line">输出：[&quot;ac&quot;,&quot;ad&quot;,&quot;ae&quot;,&quot;bc&quot;,&quot;bd&quot;,&quot;be&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：expression = &quot;&#123;&#123;a,z&#125;,a&#123;b,c&#125;,&#123;ab,z&#125;&#125;&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;z&quot;]</span><br><span class="line">解释：输出中 不应 出现重复的组合结果。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= expression.length &lt;= 60</code></li>
<li>  <code>expression[i]</code> 由 <code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;,&#39;</code> 或小写英文字母组成</li>
<li>给出的表达式 <code>expression</code> 用以表示一组基于题目描述中语法构造的字符串</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这个问题类似求带括号的表达式。</p>
<p>我们可以将表达式转化为逆波兰式（后缀表达式）</p>
<p>对于逆波兰式没有括号，只需要一个栈就可以将表达式的值计算出来。</p>
<p>计算逆波兰式的算法过程：<br>遍历逆波兰式的符号，当前符号为字符串集合则加入栈中。<br>若当前元素为运算符则将栈顶两个字符串集合进行运算再放回栈中。这里运算有两种集合的并和笛卡尔积。<br>最后栈顶元素就是计算结果。</p>
<p>如何生成逆波兰式，我们需要对运算符设置优先级，维护一个运算符优先级单调增栈，对违背单调的待入栈元素将栈顶不断弹出放入逆波兰式中。<br>并运算优先级小于笛卡尔积运算优先级。<br>对于括号若为左括号则直接放入栈中。对于右括号不断弹栈知道遇到左括号为止。<br>对于非运算符则直接加入到逆波兰式中。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#123; 1</span></span><br><span class="line"><span class="comment">    &#125; 2</span></span><br><span class="line"><span class="comment">    , 3</span></span><br><span class="line"><span class="comment">    * 4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> mp[<span class="number">200</span>];</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">braceExpansionII</span><span class="params">(string exp)</span> </span>&#123;</span><br><span class="line">        <span class="function">string <span class="title">s</span><span class="params">(<span class="number">1</span>, exp[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;exp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">islower</span>(exp[i<span class="number">-1</span>]) &amp;&amp; <span class="built_in">islower</span>(exp[i])</span><br><span class="line">            || <span class="built_in">islower</span>(exp[i<span class="number">-1</span>]) &amp;&amp; exp[i] == <span class="string">&#x27;&#123;&#x27;</span></span><br><span class="line">            || exp[i<span class="number">-1</span>] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; <span class="built_in">islower</span>(exp[i])</span><br><span class="line">            || exp[i<span class="number">-1</span>] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; exp[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                s.<span class="built_in">push_back</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push_back</span>(exp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">        mp[<span class="string">&#x27;&#123;&#x27;</span>] = <span class="string">&#x27;1&#x27;</span>; mp[<span class="string">&#x27;&#125;&#x27;</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;,&#x27;</span>] = <span class="string">&#x27;3&#x27;</span>; mp[<span class="string">&#x27;*&#x27;</span>] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">        vector&lt;set&lt;string&gt;&gt; elm;</span><br><span class="line">        string opt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i:s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                opt.<span class="built_in">push_back</span>(mp[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mp[i]) &#123; <span class="comment">// opt</span></span><br><span class="line">                <span class="keyword">while</span> (opt.<span class="built_in">size</span>() &amp;&amp; opt.<span class="built_in">back</span>()&gt;mp[i]) &#123;</span><br><span class="line">                    elm.<span class="built_in">push_back</span>(&#123;<span class="built_in">string</span>(<span class="number">1</span>, opt.<span class="built_in">back</span>())&#125;);</span><br><span class="line">                    opt.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mp[i] == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">                    opt.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    opt.<span class="built_in">push_back</span>(mp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                elm.<span class="built_in">push_back</span>(&#123;<span class="built_in">string</span>(<span class="number">1</span>, i)&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (opt.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            elm.<span class="built_in">push_back</span>(&#123;<span class="built_in">string</span>(<span class="number">1</span>, opt.<span class="built_in">back</span>())&#125;);</span><br><span class="line">            opt.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (auto i:elm) &#123;</span></span><br><span class="line">        <span class="comment">//     for (string j:i) &#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; j &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        vector&lt;set&lt;string&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;elm.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*elm[i].<span class="built_in">begin</span>() == <span class="string">&quot;3&quot;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> sz = st.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">int</span> l = sz<span class="number">-2</span>, r = sz<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> x:st[r]) st[l].<span class="built_in">insert</span>(x);</span><br><span class="line">                st.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*elm[i].<span class="built_in">begin</span>() == <span class="string">&quot;4&quot;</span>) &#123;</span><br><span class="line">                set&lt;string&gt; t;</span><br><span class="line">                <span class="type">int</span> sz = st.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">int</span> l = sz<span class="number">-2</span>, r = sz<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> x:st[l]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> y:st[r]) &#123;</span><br><span class="line">                        t.<span class="built_in">insert</span>(x+y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop_back</span>();</span><br><span class="line">                st.<span class="built_in">back</span>() = t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">emplace_back</span>(elm[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;string&gt;(st.<span class="built_in">back</span>().<span class="built_in">begin</span>(), st.<span class="built_in">back</span>().<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈队列堆</tag>
      </tags>
  </entry>
  <entry>
    <title>英雄的力量</title>
    <url>/2023/05/14/%E8%8B%B1%E9%9B%84%E7%9A%84%E5%8A%9B%E9%87%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/power-of-heroes/">6423. 英雄的力量</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，它表示英雄的能力值。如果我们选出一部分英雄，这组英雄的 <strong>力量</strong> 定义为：</p>
<ul>
<li>  <code>i0</code> ，<code>i1</code> ，… <code>ik</code> 表示这组英雄在数组中的下标。那么这组英雄的力量为 <code>max(nums[i0],nums[i1] ... nums[ik])^2 * min(nums[i0],nums[i1] ... nums[ik])</code> 。</li>
</ul>
<p>请你返回所有可能的 <strong>非空</strong> 英雄组的 <strong>力量</strong> 之和。由于答案可能非常大，请你将结果对 <code>10^9 + 7</code> <strong>取余。</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,1,4]</span><br><span class="line">输出：141</span><br><span class="line">解释：</span><br><span class="line">第 1 组：[2] 的力量为 22 * 2 = 8 。</span><br><span class="line">第 2 组：[1] 的力量为 12 * 1 = 1 。</span><br><span class="line">第 3 组：[4] 的力量为 42 * 4 = 64 。</span><br><span class="line">第 4 组：[2,1] 的力量为 22 * 1 = 4 。</span><br><span class="line">第 5 组：[2,4] 的力量为 42 * 2 = 32 。</span><br><span class="line">第 6 组：[1,4] 的力量为 42 * 1 = 16 。</span><br><span class="line">第​ ​​​​​​7 组：[2,1,4] 的力量为 42​​​​​​​ * 1 = 16 。</span><br><span class="line">所有英雄组的力量之和为 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1]</span><br><span class="line">输出：7</span><br><span class="line">解释：总共有 7 个英雄组，每一组的力量都是 1 。所以所有英雄组的力量之和为 7 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由于是所有子序列的英雄力量之和，所以考虑排序。</p>
<p>排序后考虑第i个数为序列中的最大值的所有序列的英雄力量之和，记为$f_i$。</p>
<p>显然答案就是$\sum f_i$</p>
<p>现在看一个例子，找规律。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = [1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p>对于$f_4$，我们以4为最大值，最小值可以是1、2、3或4。<br>当最小值为4时，贡献为$4^2\cdot4$；<br>当最小值为3时，贡献为$4^2\cdot3$；<br>当最小值为2时，贡献为$4^2\cdot3 \cdot2$，这里为什么要乘以2，是因为对于以2为最小值4为最大值的子序列有两个<code>[2,4],[2,3,4]</code>；<br>当最小值为1时，贡献为$4^2\cdot3 \cdot2^2$，2和3可选可不选共计4中；</p>
<p>我们设$p_i = a_02^i+a_12^{i-1}+\cdots+a_ii$，</p>
<p>$p_i$满足递推式$p_i = 2p_{i-1}+a_i$</p>
<p>而$f_i = i^2(p_{i-1}+i)$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="type">const</span> ll MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfPower</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        ll ans = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i:nums) &#123;</span><br><span class="line">            ans += i*i%MOD*(p+i)%MOD;</span><br><span class="line">            ans %= MOD;</span><br><span class="line">            p = (p*<span class="number">2</span>%MOD+i)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>区间计数</tag>
      </tags>
  </entry>
  <entry>
    <title>获取单值网格的最小操作数</title>
    <url>/2023/04/09/%E8%8E%B7%E5%8F%96%E5%8D%95%E5%80%BC%E7%BD%91%E6%A0%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-make-a-uni-value-grid/">2033. 获取单值网格的最小操作数</a></p>
<hr>
<p>给你一个大小为 <code>m x n</code> 的二维整数网格 <code>grid</code> 和一个整数 <code>x</code> 。每一次操作，你可以对 <code>grid</code> 中的任一元素 <strong>加</strong> <code>x</code> 或 <strong>减</strong> <code>x</code> 。</p>
<p><strong>单值网格</strong> 是全部元素都相等的网格。</p>
<p>返回使网格化为单值网格所需的 <strong>最小</strong> 操作数。如果不能，返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/21/gridtxt.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[2,4],[6,8]], x = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：可以执行下述操作使所有元素都等于 4 ： </span><br><span class="line">- 2 加 x 一次。</span><br><span class="line">- 6 减 x 一次。</span><br><span class="line">- 8 减 x 两次。</span><br><span class="line">共计 4 次操作。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/21/gridtxt-1.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,5],[2,3]], x = 1</span><br><span class="line">输出：5</span><br><span class="line">解释：可以使所有元素都等于 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/21/gridtxt-2.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2],[3,4]], x = 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：无法使所有元素相等。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>m == grid.length</code></li>
<li>  <code>n == grid[i].length</code></li>
<li>  <code>1 &lt;= m, n &lt;= 10^5</code></li>
<li>  <code>1 &lt;= m * n &lt;= 10^5</code></li>
<li><code>1 &lt;= x, grid[i][j] &lt;= 10^4</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>中位数贪心</p>
<p>首先所有的数都应该模x同余，否则没有答案输出-1</p>
<p>然后对数组排序，取中位数作为最终的单值。</p>
<p>为什么中位数，如果最终的单值为t</p>
<p>数组中小于t的个数有a个，大于t的有b个。</p>
<p>让t增大x后，最后需要操作的次数需要增加a-b次。</p>
<p>让t减小x后，最后需要操作的次数需要增加b-a次。</p>
<p>当a=b时总操作次数才最小，也就是应该选择中位数。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; g, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        vector&lt;ll&gt; a;</span><br><span class="line">        ll m = g[<span class="number">0</span>][<span class="number">0</span>]%x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:g) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ll j:i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j%x != m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                a.<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        ll n = a.<span class="built_in">size</span>();</span><br><span class="line">        ll mid = a[n/<span class="number">2</span>];</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i:a) &#123;</span><br><span class="line">            ans += <span class="built_in">abs</span>(i-mid)/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>获得分数的方法数</title>
    <url>/2023/04/09/%E8%8E%B7%E5%BE%97%E5%88%86%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/number-of-ways-to-earn-points/">2585. 获得分数的方法数</a></p>
<hr>
<p>考试中有 <code>n</code> 种类型的题目。给你一个整数 <code>target</code> 和一个下标从 <strong>0</strong> 开始的二维整数数组 <code>types</code> ，其中 <code>types[i] = [counti, marksi]</code> 表示第 <code>i</code> 种类型的题目有 <code>counti</code> 道，每道题目对应 <code>marksi</code> 分。</p>
<p>返回你在考试中恰好得到 <code>target</code> 分的方法数。由于答案可能很大，结果需要对 <code>10^9 +7</code> 取余。</p>
<p><strong>注意</strong>，同类型题目无法区分。</p>
<ul>
<li>比如说，如果有 <code>3</code> 道同类型题目，那么解答第 <code>1</code> 和第 <code>2</code> 道题目与解答第 <code>1</code> 和第 <code>3</code> 道题目或者第 <code>2</code> 和第 <code>3</code> 道题目是相同的。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：target = 6, types = [[6,1],[3,2],[2,3]]</span><br><span class="line">输出：7</span><br><span class="line">解释：要获得 6 分，你可以选择以下七种方法之一：</span><br><span class="line">- 解决 6 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 + 1 = 6</span><br><span class="line">- 解决 4 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 1 + 2 = 6</span><br><span class="line">- 解决 2 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 1 + 2 + 2 = 6</span><br><span class="line">- 解决 3 道第 0 种类型的题目和 1 道第 2 种类型的题目：1 + 1 + 1 + 3 = 6</span><br><span class="line">- 解决 1 道第 0 种类型的题目、1 道第 1 种类型的题目和 1 道第 2 种类型的题目：1 + 2 + 3 = 6</span><br><span class="line">- 解决 3 道第 1 种类型的题目：2 + 2 + 2 = 6</span><br><span class="line">- 解决 2 道第 2 种类型的题目：3 + 3 = 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：target = 5, types = [[50,1],[50,2],[50,5]]</span><br><span class="line">输出：4</span><br><span class="line">解释：要获得 5 分，你可以选择以下四种方法之一：</span><br><span class="line">- 解决 5 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 = 5</span><br><span class="line">- 解决 3 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 2 = 5</span><br><span class="line">- 解决 1 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 2 + 2 = 5</span><br><span class="line">- 解决 1 道第 2 种类型的题目：5</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：target = 18, types = [[6,1],[3,2],[2,3]]</span><br><span class="line">输出：1</span><br><span class="line">解释：只有回答所有题目才能获得 18 分。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= target &lt;= 1000</code></li>
<li>  <code>n == types.length</code></li>
<li>  <code>1 &lt;= n &lt;= 50</code></li>
<li>  <code>types[i].length == 2</code></li>
<li><code>1 &lt;= counti, marksi &lt;= 50</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>分组背包，不同于01背包，01背包的物品只有选和不选两种，而分组背包的物品有一个选取的上限w，你可以选0次，1次，。。。，w次。<br>也可以认为01背包是分组背包的特殊情况，w取1。</p>
<p>现在n种题目可以认为就是物品种类。<br>每种题目的分值代表物品的价值。<br>每种题目的个数为背包物品选取的次数。</p>
<p>定义$f_{i,j}$为前i种物品选取后价值为j的选取种数。</p>
<p>$f_{0,0} = 1$</p>
<p>$f_{i,j} = \sum \limits_{k=0}^{count_{i}} f_{i-1, j-k*mark_i}$</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="type">const</span> ll MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">waysToReachTarget</span><span class="params">(<span class="type">int</span> m, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; types)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = types.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">f</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;ll&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;=types[i<span class="number">-1</span>][<span class="number">0</span>]; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=k*types[i<span class="number">-1</span>][<span class="number">1</span>]; j&lt;=m; j++) &#123;</span><br><span class="line">                    f[i][j] += f[i<span class="number">-1</span>][j-k*types[i<span class="number">-1</span>][<span class="number">1</span>]];</span><br><span class="line">                    f[i][j] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>背包dp</tag>
      </tags>
  </entry>
  <entry>
    <title>表现良好的最长时间段</title>
    <url>/2023/04/09/%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/longest-well-performing-interval/">1124. 表现良好的最长时间段</a></p>
<hr>
<p>给你一份工作时间表 <code>hours</code>，上面记录着某一位员工每天的工作小时数。</p>
<p>我们认为当员工一天中的工作小时数大于 <code>8</code> 小时的时候，那么这一天就是「<strong>劳累的一天</strong>」。</p>
<p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 <strong>大于</strong>「不劳累的天数」。</p>
<p>请你返回「表现良好时间段」的最大长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：hours = [9,9,6,0,6,6,9]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长的表现良好时间段是 [9,9,6]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：hours = [6,6,6]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= hours.length &lt;= 10^4</code></li>
<li><code>0 &lt;= hours[i] &lt;= 16</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们将<code>hours</code>二值化。对于<code>hours[i]&gt;8</code>则<code>hours[i] = 1</code>，否则<code>hours[i] = -1</code>。</p>
<p>对于「表现良好的时间段」，其实就是区间和至少为1。</p>
<p>为了快速得到区间和，可以用前缀数组。</p>
<p>设<code>p[i]</code>为前i个数的最大值。即<code>p[0] = 0, p[i] = p[i-1] + hours[i-1]</code></p>
<p>此时对于任意<code>p[j]-p[i]&gt;=1</code>的区间<code>[i,j]</code>，都是「表现良好的时间段」。</p>
<p>如果我们固定右端点j，枚举左端点i，则可以在O(n^2)时间复杂度找到答案。</p>
<p>又没有快速找到最优的左端点的方法呢？</p>
<p>显然对于右端点j，最优的左端点应该是满足<code>p[i] &lt; p[j]</code>最小的i。</p>
<p>可以用树状数组加快查询，不过<code>p[i]</code>存在非正数，需要离散化。<br>将离散化的前缀和作为树状数组的下标，前缀数组的下标作为树状数组的值，维护最小值。即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestWPI</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = h.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            p[i] = p[i<span class="number">-1</span>] + (h[i<span class="number">-1</span>]&gt;<span class="number">8</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; id;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            id[p[i]];</span><br><span class="line">            id[p[i]<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sz = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i,j]:id) j = sz++;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(sz, INF)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> ask = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="type">int</span> rt = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=x; i; i-=i&amp;-i) &#123;</span><br><span class="line">                rt = <span class="built_in">min</span>(rt, a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rt;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> x, <span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=x; i&lt;sz; i+=i&amp;-i) &#123;</span><br><span class="line">                a[i] = <span class="built_in">min</span>(a[i], val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">add</span>(id[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i-<span class="built_in">ask</span>(id[p[i]<span class="number">-1</span>]));</span><br><span class="line">            <span class="built_in">add</span>(id[p[i]], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>巧妙的单调栈。</p>
<p>考虑哪些可以作为区间左端点，若i可以作为左端点，那么作为左端点的j（j &lt; i），满足<code>p[j]&gt;p[i]</code>。<br>若<code>p[j]&lt;p[i]</code>，后续的右端点可以选择j，这样宽度更大。</p>
<p>因此可以作为左端点的值单调递减，我们将其存入栈中，设栈顶元素为top.</p>
<p>然后从右向左遍历寻找右端点。对于遍历的j，若<code>p[j] &gt; p[top]</code>，更新答案，并移除栈顶。<br>j之前的元素i即便<code>p[i]&gt;p[top]</code>，由于j靠后，i更新的答案也不如j优，故可以直接删除栈顶。</p>
<p><a href="https://leetcode.cn/problems/longest-well-performing-interval/solution/liang-chong-zuo-fa-liang-zhang-tu-miao-d-hysl/">参考</a></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestWPI</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; hours)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = hours.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            p[i] = p[i<span class="number">-1</span>] + (hours[i<span class="number">-1</span>]&gt;<span class="number">8</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[st.<span class="built_in">back</span>()]&gt;p[i]) &#123;</span><br><span class="line">                st.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">size</span>() &amp;&amp; p[st.<span class="built_in">back</span>()] &lt; p[i]) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i-st.<span class="built_in">back</span>());</span><br><span class="line">                st.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈队列堆</tag>
      </tags>
  </entry>
  <entry>
    <title>袋子里最少数目的球</title>
    <url>/2023/04/09/%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/">1760. 袋子里最少数目的球</a></p>
<hr>
<p>给你一个整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code> 个袋子里球的数目。同时给你一个整数 <code>maxOperations</code> 。</p>
<p>你可以进行如下操作至多 <code>maxOperations</code> 次：</p>
<ul>
<li>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 <strong>正整数</strong> 个球。<ul>
<li>  比方说，一个袋子里有 <code>5</code> 个球，你可以把它们分到两个新袋子里，分别有 <code>1</code> 个和 <code>4</code> 个球，或者分别有 <code>2</code> 个和 <code>3</code> 个球。</li>
</ul>
</li>
</ul>
<p>你的开销是单个袋子里球数目的 <strong>最大值</strong> ，你想要 <strong>最小化</strong> 开销。</p>
<p>请你返回进行上述操作后的最小开销。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [9], maxOperations = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -&gt; [6,3] 。</span><br><span class="line">- 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -&gt; [3,3,3] 。</span><br><span class="line">装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,4,8,2], maxOperations = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,8,2] -&gt; [2,4,4,4,2] 。</span><br><span class="line">- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,4,4,4,2] -&gt; [2,2,2,4,4,2] 。</span><br><span class="line">- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,4,4,2] -&gt; [2,2,2,2,2,4,2] 。</span><br><span class="line">- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,4,2] -&gt; [2,2,2,2,2,2,2,2] 。</span><br><span class="line">装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,17], maxOperations = 2</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= maxOperations, nums[i] &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>每次操作会使得数组长度增长1，若数组长度为n，最多操作mo次。</p>
<p>那么对于操作后的最终数组长度小于等于mo+n则是可行的。若操作后的数组中最大值为mx，对于操作后开销大于mx的数组数组长度也满足mo+n，所以可以找到第一个满足的mx即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> l = <span class="number">1</span>, r = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">long</span> m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i:nums) &#123;</span><br><span class="line">                cnt += (i+m<span class="number">-1</span>)/m<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; maxOperations) l = m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>装包裹的最小浪费空间</title>
    <url>/2023/04/09/%E8%A3%85%E5%8C%85%E8%A3%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B5%AA%E8%B4%B9%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/minimum-space-wasted-from-packaging/">1889. 装包裹的最小浪费空间</a></p>
<hr>
<p>给你 <code>n</code> 个包裹，你需要把它们装在箱子里，<strong>每个箱子装一个包裹</strong>。总共有 <code>m</code> 个供应商提供 <strong>不同尺寸</strong> 的箱子（每个规格都有无数个箱子）。如果一个包裹的尺寸 <strong>小于等于</strong> 一个箱子的尺寸，那么这个包裹就可以放入这个箱子之中。</p>
<p>包裹的尺寸用一个整数数组 <code>packages</code> 表示，其中 <code>packages[i]</code> 是第 <code>i</code> 个包裹的尺寸。供应商用二维数组 <code>boxes</code> 表示，其中 <code>boxes[j]</code> 是第 <code>j</code> 个供应商提供的所有箱子尺寸的数组。</p>
<p>你想要选择 <strong>一个供应商</strong> 并只使用该供应商提供的箱子，使得 <strong>总浪费空间最小</strong> 。对于每个装了包裹的箱子，我们定义 <strong>浪费的</strong> 空间等于 <code>箱子的尺寸 - 包裹的尺寸</code> 。<strong>总浪费空间</strong> 为 <strong>所有</strong> 箱子中浪费空间的总和。</p>
<ul>
<li>  比方说，如果你想要用尺寸数组为 <code>[4,8]</code> 的箱子装下尺寸为 <code>[2,3,5]</code> 的包裹，你可以将尺寸为 <code>2</code> 和 <code>3</code> 的两个包裹装入两个尺寸为 <code>4</code> 的箱子中，同时把尺寸为 <code>5</code> 的包裹装入尺寸为 <code>8</code> 的箱子中。总浪费空间为 <code>(4-2) + (4-3) + (8-5) = 6</code> 。</li>
</ul>
<p>请你选择 <strong>最优</strong> 箱子供应商，使得 <strong>总浪费空间最小</strong> 。如果 <strong>无法</strong> 将所有包裹放入箱子中，请你返回 <code>-1</code> 。由于答案可能会 <strong>很大</strong> ，请返回它对 <code>10^9 + 7</code> <strong>取余</strong> 的结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：packages = [2,3,5], boxes = [[4,8],[2,8]]</span><br><span class="line">输出：6</span><br><span class="line">解释：选择第一个供应商最优，用两个尺寸为 4 的箱子和一个尺寸为 8 的箱子。</span><br><span class="line">总浪费空间为 (4-2) + (4-3) + (8-5) = 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：没有箱子能装下尺寸为 5 的包裹。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]</span><br><span class="line">输出：9</span><br><span class="line">解释：选择第三个供应商最优，用两个尺寸为 5 的箱子，两个尺寸为 10 的箱子和两个尺寸为 14 的箱子。</span><br><span class="line">总浪费空间为 (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>n == packages.length</code></li>
<li>  <code>m == boxes.length</code></li>
<li>  <code>1 &lt;= n &lt;= 10^5</code></li>
<li>  <code>1 &lt;= m &lt;= 10^5</code></li>
<li>  <code>1 &lt;= packages[i] &lt;= 10^5</code></li>
<li>  <code>1 &lt;= boxes[j].length &lt;= 10^5</code></li>
<li>  <code>1 &lt;= boxes[j][k] &lt;= 10^5</code></li>
<li>  <code>sum(boxes[j].length) &lt;= 10^5</code></li>
<li><code>boxes[j]</code> 中的元素 <strong>互不相同</strong> 。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>排序+二分+前缀和</p>
<p>对所有包裹升序排序。</p>
<p>对于每个厂商的所有盒子都升序排序。</p>
<p>要让总浪费空间最小，对于厂商<code>boxes[i]</code>的盒子<code>boxes[i][j]</code>，应该准备r-l个分别装<code>packages[l],packages[l+1], ... , packages[r-1]</code>这些包裹。其中l是<code>boxes[i][j-1]</code>第一个不能装下的包裹位置，r是<code>boxes[i][j]</code>第一个不能装下的包裹位置。l和r可以用二分法来快速得到。盒子<code>boxes[i][j]</code>的浪费空间是$(r-l)* boxes[i][j] - \sum \limits_{i=l}^{r-1}packages[i]$，对于区间和可以用前缀和之差来得到。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minWastedSpace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; packages, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; boxes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = packages.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(packages.<span class="built_in">begin</span>(), packages.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">p</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) p[i] = p[i<span class="number">-1</span>]+packages[i<span class="number">-1</span>];</span><br><span class="line">        <span class="type">long</span> ans = <span class="number">1e18</span>, M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:boxes) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(i.<span class="built_in">begin</span>(), i.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span> (i.<span class="built_in">back</span>()&lt;packages.<span class="built_in">back</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">long</span> t = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j:i) &#123;</span><br><span class="line">                <span class="type">long</span> e = <span class="built_in">upper_bound</span>(packages.<span class="built_in">begin</span>(), packages.<span class="built_in">end</span>(), j)-packages.<span class="built_in">begin</span>();</span><br><span class="line">                t += (e-s)*j - (p[e]-p[s]);</span><br><span class="line">                s = e;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == <span class="number">1e18</span> ? <span class="number">-1</span> : ans%M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计可以求最短路径的图类</title>
    <url>/2023/04/16/%E8%AE%BE%E8%AE%A1%E5%8F%AF%E4%BB%A5%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E5%9B%BE%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/">6336. 设计可以求最短路径的图类</a></p>
<hr>
<p>给你一个有 <code>n</code> 个节点的 <strong>有向带权</strong> 图，节点编号为 <code>0</code> 到 <code>n - 1</code> 。图中的初始边用数组 <code>edges</code> 表示，其中 <code>edges[i] = [fromi, toi, edgeCosti]</code> 表示从 <code>fromi</code> 到 <code>toi</code> 有一条代价为 <code>edgeCosti</code> 的边。</p>
<p>请你实现一个 <code>Graph</code> 类：</p>
<ul>
<li>  <code>Graph(int n, int[][] edges)</code> 初始化图有 <code>n</code> 个节点，并输入初始边。</li>
<li>  <code>addEdge(int[] edge)</code> 向边集中添加一条边，其中 <code>edge = [from, to, edgeCost]</code> 。数据保证添加这条边之前对应的两个节点之间没有有向边。</li>
<li><code>int shortestPath(int node1, int node2)</code> 返回从节点 <code>node1</code> 到 <code>node2</code> 的路径 <strong>最小</strong> 代价。如果路径不存在，返回 <code>-1</code> 。一条路径的代价是路径中所有边代价之和。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;Graph&quot;, &quot;shortestPath&quot;, &quot;shortestPath&quot;, &quot;addEdge&quot;, &quot;shortestPath&quot;]</span><br><span class="line">[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]</span><br><span class="line">输出：</span><br><span class="line">[null, 6, -1, null, 6]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);</span><br><span class="line">g.shortestPath(3, 2); // 返回 6 。从 3 到 2 的最短路径如第一幅图所示：3 -&gt; 0 -&gt; 1 -&gt; 2 ，总代价为 3 + 2 + 1 = 6 。</span><br><span class="line">g.shortestPath(0, 3); // 返回 -1 。没有从 0 到 3 的路径。</span><br><span class="line">g.addEdge([1, 3, 4]); // 添加一条节点 1 到节点 3 的边，得到第二幅图。</span><br><span class="line">g.shortestPath(0, 3); // 返回 6 。从 0 到 3 的最短路径为 0 -&gt; 1 -&gt; 3 ，总代价为 2 + 4 = 6 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 100</code></li>
<li>  <code>0 &lt;= edges.length &lt;= n * (n - 1)</code></li>
<li>  <code>edges[i].length == edge.length == 3</code></li>
<li>  <code>0 &lt;= fromi, toi, from, to, node1, node2 &lt;= n - 1</code></li>
<li>  <code>1 &lt;= edgeCosti, edgeCost &lt;= 10^6</code></li>
<li>  图中任何时候都不会有重边和自环。</li>
<li>  调用 <code>addEdge</code> 至多 <code>100</code> 次。</li>
<li>调用 <code>shortestPath</code> 至多 <code>100</code> 次。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>Floyd算法，$O(n^3)$的时间复杂度求多源最短路径。</p>
<p>其思想是动态规划。<br>设图中共n个节点，节点编号从0到n-1。<br>定义<code>f[k][x][y]</code>，表示只允许经过节点 0 到 k-1，节点 x 到节点 y 的最短路长度。</p>
<p>初始化<code>f[0][][]</code>：</p>
<ul>
<li>若节点u和v之间存在边权为e的有向边，则<code>f[0][u][v] = e</code></li>
<li>对角线初始化为0，<code>f[0][i][i] = 0</code></li>
<li>其余初始化为无穷，<code>f[0][i][j] = INF, i != j</code></li>
</ul>
<p>状态转移</p>
<p><code>f[k][x][y] = min(f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])</code> 经过k的最短路径 和 不经过k的最短路径 选择最小的一条。</p>
<p>本题图中点数不超100，边数也不会超过10000，我们跑一次Floyd大概需要1e6的操作数。<br>但是后续会有不超过100次的添加边操作。如果每添加一条边都跑一次Floyd那么势必超时。</p>
<p>有什么优化的地方呢？<br>注意到新增加的边可以让某两个节点x与y的最短距离变小，说明x到y的路径上一定经过了新增的这条边。<br>所以我们只需花$O(n^2)$跟新任意两个点的最短距离即可。</p>
<p>设e1到e2新增的有向边，边权为e3。</p>
<p>则有<br><code>f[k][e1][e2] = min(f[k][e1][e2], e3)</code>,<br><code>f[k][x][y] = min(f[k][x][y], f[k][x][e1]+f[k][e1][e2]+f[k][e2][y])</code></p>
<p>注意到每次转移<code>f[i+1][][]</code>只与<code>f[i][][]</code>有关，所以可以将数组减少一维。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> f[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges):<span class="built_in">n</span>(n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) f[i][i] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            f[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = i[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k]+f[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; e)</span> </span>&#123;</span><br><span class="line">        f[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = <span class="built_in">min</span>(f[e[<span class="number">0</span>]][e[<span class="number">1</span>]], e[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][e[<span class="number">0</span>]]+f[e[<span class="number">0</span>]][e[<span class="number">1</span>]]+f[e[<span class="number">1</span>]][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestPath</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (f[node1][node2]+<span class="number">1</span>)%(INF+<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Graph object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Graph* obj = new Graph(n, edges);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addEdge(edge);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;shortestPath(node1,node2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>每加一条边做一次dijkstra。<br>由于是稠密图用暴力的dijkstra时间复杂度为$O(n^2)$。n为图中点数。</p>
<p>优先队列优化的时间复杂度为$O(mlog(m))$，m为图中边数。由于稠密图最多能达到n*(n-1)条边。<br>所以时间复杂度最坏能达到$O(n^2logn^2)$</p>
<p>本题n不超过100，使用暴力的操作数数量级1e6，优先队列应该最多是1e7，所以优先队列优化应该也能过。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>暴力dijkstra</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> f[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">    <span class="type">int</span> maxn;</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges):<span class="built_in">maxn</span>(n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) f[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            f[i[<span class="number">0</span>]][i[<span class="number">1</span>]] = i[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; e)</span> </span>&#123;</span><br><span class="line">        f[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = e[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestPath</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dis[maxn], vis[maxn];</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        dis[node1] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="number">0</span>, mind = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxn; j++)</span><br><span class="line">                <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; mind)</span><br><span class="line">                    u = j, mind = dis[j];</span><br><span class="line">            vis[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; maxn; v++) &#123;</span><br><span class="line">                <span class="type">int</span> w = f[u][v];</span><br><span class="line">                <span class="keyword">if</span> (dis[v] &gt; dis[u] + w)</span><br><span class="line">                    dis[v] = dis[u] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dis[node2]+<span class="number">1</span>)%(INF+<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Graph object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Graph* obj = new Graph(n, edges);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addEdge(edge);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;shortestPath(node1,node2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>优先队列优化dijkstra</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; g;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges): <span class="built_in">g</span>(n), <span class="built_in">n</span>(n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:edges) &#123;</span><br><span class="line">            g[i[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(i[<span class="number">1</span>], i[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; e)</span> </span>&#123;</span><br><span class="line">        g[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>], e[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestPath</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n, INF)</span>, <span class="title">vis</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dis[node1] = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(<span class="number">0</span>, node1);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [d, u] = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[u] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [i,e]:g[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[i] &gt; dis[u]+e) &#123;</span><br><span class="line">                    dis[i] = dis[u]+e;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(-dis[i], i);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[node2]==INF?<span class="number">-1</span>:dis[node2];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Graph object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Graph* obj = new Graph(n, edges);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addEdge(edge);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;shortestPath(node1,node2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>访问完所有房间的第一天</title>
    <url>/2023/04/09/%E8%AE%BF%E9%97%AE%E5%AE%8C%E6%89%80%E6%9C%89%E6%88%BF%E9%97%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/">1997. 访问完所有房间的第一天</a></p>
<hr>
<p>你需要访问 <code>n</code> 个房间，房间从 <code>0</code> 到 <code>n - 1</code> 编号。同时，每一天都有一个日期编号，从 <code>0</code> 开始，依天数递增。你每天都会访问一个房间。</p>
<p>最开始的第 <code>0</code> 天，你访问 <code>0</code> 号房间。给你一个长度为 <code>n</code> 且 <strong>下标从 0 开始</strong> 的数组 <code>nextVisit</code> 。在接下来的几天中，你访问房间的 <strong>次序</strong> 将根据下面的 <strong>规则</strong> 决定：</p>
<ul>
<li>  假设某一天，你访问 <code>i</code> 号房间。</li>
<li>  如果算上本次访问，访问 <code>i</code> 号房间的次数为 <strong>奇数</strong> ，那么 <strong>第二天</strong> 需要访问 <code>nextVisit[i]</code> 所指定的房间，其中 <code>0 &lt;= nextVisit[i] &lt;= i</code> 。</li>
<li>  如果算上本次访问，访问 <code>i</code> 号房间的次数为 <strong>偶数</strong> ，那么 <strong>第二天</strong> 需要访问 <code>(i + 1) mod n</code> 号房间。</li>
</ul>
<p>请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 <code>10^9 + 7</code> 取余后的结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nextVisit = [0,0]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 第 0 天，你访问房间 0 。访问 0 号房间的总次数为 1 ，次数为奇数。</span><br><span class="line">  下一天你需要访问房间的编号是 nextVisit[0] = 0</span><br><span class="line">- 第 1 天，你访问房间 0 。访问 0 号房间的总次数为 2 ，次数为偶数。</span><br><span class="line">  下一天你需要访问房间的编号是 (0 + 1) mod 2 = 1</span><br><span class="line">- 第 2 天，你访问房间 1 。这是你第一次完成访问所有房间的那天。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nextVisit = [0,0,2]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">你每天访问房间的次序是 [0,0,1,0,0,1,2,...] 。</span><br><span class="line">第 6 天是你访问完所有房间的第一天。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nextVisit = [0,1,2,0]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">你每天访问房间的次序是 [0,0,1,1,2,2,3,...] 。</span><br><span class="line">第 6 天是你访问完所有房间的第一天。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>n == nextVisit.length</code></li>
<li>  <code>2 &lt;= n &lt;= 10^5</code></li>
<li><code>0 &lt;= nextVisit[i] &lt;= i</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>注意到<code>nextVisit[i]&lt;=i</code>，当我们从i移动到i+1位置时，访问i是偶数次，所以首次访问i会移动到<code>nextVisit[i]</code>位置。接下来从<code>nextVisit[i]</code>到i中途经过的每个位置j（除了i）都是偶数次。都需要回访到<code>nextVisits[j]</code>。</p>
<p>定义$f_i$为从i到i+1位置需要的步数。</p>
<p>显然$f_i = 2 + \sum \limits_{j=nextVisit[i]}^{i-1}f_j$，<code>i</code>位置经过了两次。</p>
<p>我们只需要求得$\sum \limits_{i=0}^{n-2}f_i$即可。在最后访问了n-1位置一次，但是由于第一天访问是从0开始，所以只需累加前n-2个位置的$f_i$即可。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstDayBeenInAllRooms</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nextVisit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nextVisit.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            p[i+<span class="number">1</span>] = (p[i] + (p[i]-p[nextVisit[i]]+M+<span class="number">2</span>)%M)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>leetcode</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>过桥的时间</title>
    <url>/2023/04/09/%E8%BF%87%E6%A1%A5%E7%9A%84%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/time-to-cross-a-bridge/">2532. 过桥的时间</a></p>
<hr>
<p>共有 <code>k</code> 位工人计划将 <code>n</code> 个箱子从旧仓库移动到新仓库。给你两个整数 <code>n</code> 和 <code>k</code>，以及一个二维整数数组 <code>time</code> ，数组的大小为 <code>k x 4</code> ，其中 <code>time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi]</code> 。</p>
<p>一条河将两座仓库分隔，只能通过一座桥通行。旧仓库位于河的右岸，新仓库在河的左岸。开始时，所有 <code>k</code> 位工人都在桥的左侧等待。为了移动这些箱子，第 <code>i</code> 位工人（下标从 <strong>0</strong> 开始）可以：</p>
<ul>
<li>  从左岸（新仓库）跨过桥到右岸（旧仓库），用时 <code>leftToRighti</code> 分钟。</li>
<li>  从旧仓库选择一个箱子，并返回到桥边，用时 <code>pickOldi</code> 分钟。不同工人可以同时搬起所选的箱子。</li>
<li>  从右岸（旧仓库）跨过桥到左岸（新仓库），用时 <code>rightToLefti</code> 分钟。</li>
<li>  将箱子放入新仓库，并返回到桥边，用时 <code>putNewi</code> 分钟。不同工人可以同时放下所选的箱子。</li>
</ul>
<p>如果满足下面任一条件，则认为工人 <code>i</code> 的 <strong>效率低于</strong> 工人 <code>j</code> ：</p>
<ul>
<li>  <code>leftToRighti + rightToLefti &gt; leftToRightj + rightToLeftj</code></li>
<li>  <code>leftToRighti + rightToLefti == leftToRightj + rightToLeftj</code> 且 <code>i &gt; j</code></li>
</ul>
<p>工人通过桥时需要遵循以下规则：</p>
<ul>
<li>  如果工人 <code>x</code> 到达桥边时，工人 <code>y</code> 正在过桥，那么工人 <code>x</code> 需要在桥边等待。</li>
<li>  如果没有正在过桥的工人，那么在桥右边等待的工人可以先过桥。如果同时有多个工人在右边等待，那么 <strong>效率最低</strong> 的工人会先过桥。</li>
<li>  如果没有正在过桥的工人，且桥右边也没有在等待的工人，同时旧仓库还剩下至少一个箱子需要搬运，此时在桥左边的工人可以过桥。如果同时有多个工人在左边等待，那么 <strong>效率最低</strong> 的工人会先过桥。</li>
</ul>
<p>所有 <code>n</code> 个盒子都需要放入新仓库，请你返回最后一个搬运箱子的工人 <strong>到达河左岸</strong> 的时间。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">从 0 到 1 ：工人 2 从左岸过桥到达右岸。</span><br><span class="line">从 1 到 2 ：工人 2 从旧仓库搬起一个箱子。</span><br><span class="line">从 2 到 6 ：工人 2 从右岸过桥到达左岸。</span><br><span class="line">从 6 到 7 ：工人 2 将箱子放入新仓库。</span><br><span class="line">整个过程在 7 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]</span><br><span class="line">输出：50</span><br><span class="line">解释：</span><br><span class="line">从 0 到 10 ：工人 1 从左岸过桥到达右岸。</span><br><span class="line">从 10 到 20 ：工人 1 从旧仓库搬起一个箱子。</span><br><span class="line">从 10 到 11 ：工人 0 从左岸过桥到达右岸。</span><br><span class="line">从 11 到 20 ：工人 0 从旧仓库搬起一个箱子。</span><br><span class="line">从 20 到 30 ：工人 1 从右岸过桥到达左岸。</span><br><span class="line">从 30 到 40 ：工人 1 将箱子放入新仓库。</span><br><span class="line">从 30 到 31 ：工人 0 从右岸过桥到达左岸。</span><br><span class="line">从 31 到 39 ：工人 0 将箱子放入新仓库。</span><br><span class="line">从 39 到 40 ：工人 0 从左岸过桥到达右岸。</span><br><span class="line">从 40 到 49 ：工人 0 从旧仓库搬起一个箱子。</span><br><span class="line">从 49 到 50 ：工人 0 从右岸过桥到达左岸。</span><br><span class="line">从 50 到 58 ：工人 0 将箱子放入新仓库。</span><br><span class="line">整个过程在 58 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 50 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n, k &lt;= 10^4</code></li>
<li>  <code>time.length == k</code></li>
<li>  <code>time[i].length == 4</code></li>
<li><code>1 &lt;= leftToRighti, pickOldi, rightToLefti, putNewi &lt;= 1000</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><del>比赛时大致思路正确用四个堆模拟即可，但是读题理解错误，以为桥左右两边同时有人等待要按照效率小的先行。</del><br>首先根据效率比较的条件将k个人按照效率由大到小排序，这时候下标大的效率越小。<br>用四个堆模拟:</p>
<ol>
<li>桥左侧等待过桥的大根堆l1，存储每个人的下标，由于同侧等待的人效率小的人先行动，故用大根堆。</li>
<li>桥右侧等待过桥的大根堆r1，存储每个人的下标，由于同侧等待的人效率小的人先行动，故用大根堆。</li>
<li>桥左侧放置箱子的小根堆l2，存储时间和人的下标。</li>
<li>桥右侧放置箱子的小根堆r2，存储时间和人的下标。</li>
</ol>
<p>对于当前桥空闲时间T，对于l2内小于桥空闲的当前时刻T的元素移动到l1中。对于r2内小于桥空闲的当前时刻T的元素移动到r1中。</p>
<p>若r1非空则选择r1堆顶元素过桥，更新下一次桥空闲时刻T，并将过桥且放置箱子的时间存入l2中；</p>
<p>若r1空但l1非空则选择l1堆顶元素过桥，更新下一次桥空闲时刻T，并将过桥且搬完箱子箱子的时间存入r2中，总共有n个箱子要搬，左侧最多只有n个人需要过桥，让n自减1；</p>
<p>若l1且r1都为空，就选择从l2和r2中最小的时间更新下一次桥空闲的时刻T。</p>
<p>最后当n为0时，只需继续运作右侧两个队列，计算出最后一个人过桥的时间便是答案。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCrossingTime</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; time)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//效率从大到小排序</span></span><br><span class="line">        <span class="built_in">stable_sort</span>(time.<span class="built_in">begin</span>(), time.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>]+a[<span class="number">2</span>] &lt; b[<span class="number">0</span>]+b[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> T = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//等待过桥优先队列 (id) 效率低优先，效率低则id大，大根堆</span></span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; l1, r1;</span><br><span class="line">        <span class="comment">//搬箱子队列 (time, id) 时间小于当前时间T则入等待过桥队列，时间小优先，小根堆</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; l2,r2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            l1.<span class="built_in">emplace</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l2.<span class="built_in">size</span>() &amp;&amp; l2.<span class="built_in">top</span>().first &lt;= T) l1.<span class="built_in">emplace</span>(l2.<span class="built_in">top</span>().second), l2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span> (r2.<span class="built_in">size</span>() &amp;&amp; r2.<span class="built_in">top</span>().first &lt;= T) r1.<span class="built_in">emplace</span>(r2.<span class="built_in">top</span>().second), r2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (r1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = r1.<span class="built_in">top</span>(); r1.<span class="built_in">pop</span>();</span><br><span class="line">                T += time[x][<span class="number">2</span>];</span><br><span class="line">                l2.<span class="built_in">emplace</span>(T+time[x][<span class="number">3</span>], x);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = l1.<span class="built_in">top</span>(); l1.<span class="built_in">pop</span>();</span><br><span class="line">                T += time[x][<span class="number">0</span>];</span><br><span class="line">                r2.<span class="built_in">emplace</span>(T+time[x][<span class="number">1</span>], x);</span><br><span class="line">                n--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T = <span class="built_in">min</span>((l2.<span class="built_in">size</span>()?l2.<span class="built_in">top</span>().first:INF), (r2.<span class="built_in">size</span>()?r2.<span class="built_in">top</span>().first:INF));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算右边最后一个人回来的时间</span></span><br><span class="line">        <span class="keyword">while</span> (r1.<span class="built_in">size</span>() || r2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r2.<span class="built_in">size</span>() &amp;&amp; r2.<span class="built_in">top</span>().first &lt;= T) r1.<span class="built_in">emplace</span>(r2.<span class="built_in">top</span>().second), r2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (r1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = r1.<span class="built_in">top</span>(); r1.<span class="built_in">pop</span>();</span><br><span class="line">                T += time[x][<span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> T = r2.<span class="built_in">top</span>().first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// while (r2.size()) &#123;</span></span><br><span class="line">        <span class="comment">//     auto [x, y] = r2.top(); r2.pop();</span></span><br><span class="line">        <span class="comment">//     T = max(T, y)+time[x][2];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈队列堆</tag>
      </tags>
  </entry>
  <entry>
    <title>逃离火灾</title>
    <url>/2023/04/09/%E9%80%83%E7%A6%BB%E7%81%AB%E7%81%BE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/escape-the-spreading-fire/">2258. 逃离火灾</a></p>
<hr>
<p>给你一个下标从 <strong>0</strong> 开始大小为 <code>m x n</code> 的二维整数数组 <code>grid</code> ，它表示一个网格图。每个格子为下面 3 个值之一：</p>
<ul>
<li>  <code>0</code> 表示草地。</li>
<li>  <code>1</code> 表示着火的格子。</li>
<li>  <code>2</code> 表示一座墙，你跟火都不能通过这个格子。</li>
</ul>
<p>一开始你在最左上角的格子 <code>(0, 0)</code> ，你想要到达最右下角的安全屋格子 <code>(m - 1, n - 1)</code> 。每一分钟，你可以移动到 <strong>相邻</strong> 的草地格子。每次你移动 <strong>之后</strong> ，着火的格子会扩散到所有不是墙的 <strong>相邻</strong> 格子。</p>
<p>请你返回你在初始位置可以停留的 <strong>最多</strong> 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 <code>-1</code> 。如果不管你在初始位置停留多久，你 <strong>总是</strong> 能到达安全屋，请你返回 <code>10^9</code> 。</p>
<p>注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。</p>
<p>如果两个格子有共同边，那么它们为 <strong>相邻</strong> 格子。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]</span><br><span class="line">输出：3</span><br><span class="line">解释：上图展示了你在初始位置停留 3 分钟后的情形。</span><br><span class="line">你仍然可以安全到达安全屋。</span><br><span class="line">停留超过 3 分钟会让你无法安全到达安全屋。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：上图展示了你马上开始朝安全屋移动的情形。</span><br><span class="line">火会蔓延到你可以移动的所有格子，所以无法安全到达安全屋。</span><br><span class="line">所以返回 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,0,0],[2,2,0],[1,2,0]]</span><br><span class="line">输出：1000000000</span><br><span class="line">解释：上图展示了初始网格图。</span><br><span class="line">注意，由于火被墙围了起来，所以无论如何你都能安全到达安全屋。</span><br><span class="line">所以返回 109 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>m == grid.length</code></li>
<li>  <code>n == grid[i].length</code></li>
<li>  <code>2 &lt;= m, n &lt;= 300</code></li>
<li>  <code>4 &lt;= m * n &lt;= 2 * 10^4</code></li>
<li>  <code>grid[i][j]</code> 是 <code>0</code> ，<code>1</code> 或者 <code>2</code> 。</li>
<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>人在到达安全屋前不能遇到火，但可以和火同时到达安全屋。</p>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>两次bfs</p>
<p>进入终点最多有两个方向，终点上方和终点左方。</p>
<p>火和人在最后到达终点方向不同，求解的方式不同。</p>
<p>当火和人到达终点方向相同，答案是人到达终点的时间-火到达终点的时间-1；</p>
<p>当火和人到达终点方向不相同，答案是人到达终点的时间-火到达终点的时间。</p>
<p>为什么会这样？我是这样理解的：</p>
<p>人可以和火同时到达安全屋，当入屋的方向不同时，可以认为 人到达终点的路径 和 火到达终点的路径 在到达终点之前不会有重合，所以人和火可以同时到达终点。如果有重合那么人必须要赶在火之前到达终点，所以等待的时间要减1。</p>
<p>我们可以判断人与火在到达终点上方和终点左方的时间来确定答案。</p>
<p>这种边角情况很复杂。因为人可能在两个方向进入终点都是最短路径。对于火也有这种可能。</p>
<p>这里分三种情况考虑。</p>
<ul>
<li>当火的两个方向路径都是最短时，人无论如何都与火同路。</li>
<li>当火不同，人相同时，人可以选择与火不同的一条路。</li>
<li>当人火两个入口路径都不同时，看人与火是否同路。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> v1[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line">    <span class="type">int</span> v2[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumMinutes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = g.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(v1, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(v1));</span><br><span class="line">        <span class="built_in">memset</span>(v2, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(v2));</span><br><span class="line">        queue&lt;Node&gt; f, p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    f.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                    v2[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!f.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = f.<span class="built_in">front</span>(); f.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> x = dx[i] + u.x;</span><br><span class="line">                <span class="type">int</span> y = dy[i] + u.y;</span><br><span class="line">                <span class="keyword">if</span> (x&lt;<span class="number">0</span> || x&gt;=n || y&lt;<span class="number">0</span> || y&gt;= m || g[x][y] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (v2[u.x][u.y]+<span class="number">1</span> &lt; v2[x][y]) &#123;</span><br><span class="line">                    v2[x][y] = v2[u.x][u.y]+<span class="number">1</span>;</span><br><span class="line">                    f.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        p.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        v1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!p.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = p.<span class="built_in">front</span>(); p.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> x = dx[i] + u.x;</span><br><span class="line">                <span class="type">int</span> y = dy[i] + u.y;</span><br><span class="line">                <span class="keyword">if</span> (x&lt;<span class="number">0</span> || x&gt;=n || y&lt;<span class="number">0</span> || y&gt;= m || g[x][y] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (v1[u.x][u.y]+<span class="number">1</span> &lt; v1[x][y]) &#123;</span><br><span class="line">                    v1[x][y] = v1[u.x][u.y]+<span class="number">1</span>;</span><br><span class="line">                    p.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v1[n<span class="number">-1</span>][m<span class="number">-1</span>] == INF) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//人与安全屋被墙分隔</span></span><br><span class="line">        <span class="keyword">if</span> (v2[n<span class="number">-1</span>][m<span class="number">-1</span>] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">1e9</span>;<span class="comment">//人能到达安全屋, 但火和安全屋被墙阻隔。</span></span><br><span class="line">        <span class="type">int</span> a1 = v1[n<span class="number">-2</span>][m<span class="number">-1</span>], a2 = v1[n<span class="number">-1</span>][m<span class="number">-2</span>];<span class="comment">//人到达两个入口的最短时间</span></span><br><span class="line">        <span class="type">int</span> b1 = v2[n<span class="number">-2</span>][m<span class="number">-1</span>], b2 = v2[n<span class="number">-1</span>][m<span class="number">-2</span>];<span class="comment">//火到达两个入口的最短时间</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; a1 &lt;&lt; &quot; &quot; &lt;&lt; a2 &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; b1 &lt;&lt; &quot; &quot; &lt;&lt; b2 &lt;&lt; endl;</span></span><br><span class="line">        <span class="type">int</span> add;</span><br><span class="line">        <span class="keyword">if</span> (b1 == b2) &#123;<span class="comment">//无论人怎么选，人与火必定同路</span></span><br><span class="line">            add = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a1 == a2) &#123;<span class="comment">//人可以选择与火不同的入口</span></span><br><span class="line">            add = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a1 &lt; a2 &amp;&amp; b1 &lt; b2 || a1 &gt; a2 &amp;&amp; b1 &gt; b2) &#123;<span class="comment">//选最小值作为最短路，同方向进入安全屋</span></span><br><span class="line">            add = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; add &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (v2[n<span class="number">-1</span>][m<span class="number">-1</span>] - v1[n<span class="number">-1</span>][m<span class="number">-1</span>] - add &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> v2[n<span class="number">-1</span>][m<span class="number">-1</span>] - v1[n<span class="number">-1</span>][m<span class="number">-1</span>] - add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>二分思路</p>
<p>可以先让火的bfs得到火到任意点的最短时间。</p>
<p>然后二分时用人的bfs是否能到达安全屋作为判断条件。随着等待的时间增大，到达安全屋的结果由 能 变为 不能。可以找到第一个不能到达的等待时间再减一便可得到答案。</p>
<p>如何通过人的bfs来判断是否能到达安全屋呢？</p>
<p>保证两个条件：</p>
<p><strong>人在到达安全屋前不能遇到火，但可以和火同时到达安全屋。</strong></p>
<p>所以人bfs时，只有当人的到达某个<strong>非终点</strong>单元格的时间小于火到达该单元格的时间才能入队列。这样就保证人在到达安全屋前不能遇到火。</p>
<p>然后对于人和火可以同时到达安全屋，这一条件须要在入队列前判断是否到达终点，因为人和火是可以同时到达终点的，而从队列里出来的人是严格小于火的。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> fire[<span class="number">303</span>][<span class="number">303</span>], peo[<span class="number">303</span>][<span class="number">303</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumMinutes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = g.<span class="built_in">size</span>(), m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(fire, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(fire));</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(i,j);</span><br><span class="line">                    fire[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> dx = x + (i<span class="number">-1</span>)%<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> dy = y + (i<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (dx &lt; <span class="number">0</span> || dx &gt;= n || dy &lt; <span class="number">0</span> || dy &gt;= m || g[dx][dy] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (fire[dx][dy] &gt; fire[x][y]+<span class="number">1</span>) &#123;</span><br><span class="line">                    fire[dx][dy] = fire[x][y]+<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(dx, dy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i=0; i&lt;n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j=0; j&lt;m; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; fire[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125; cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="type">long</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">long</span> o = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">emplace</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">memset</span>(peo, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(peo));</span><br><span class="line">            peo[<span class="number">0</span>][<span class="number">0</span>] = o;</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [x, y] = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> dx = x + (i<span class="number">-1</span>)%<span class="number">2</span>;</span><br><span class="line">                    <span class="type">int</span> dy = y + (i<span class="number">-2</span>)%<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dx &lt; <span class="number">0</span> || dx &gt;= n || dy &lt; <span class="number">0</span> || dy &gt;= m || g[dx][dy] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (fire[dx][dy] &gt;= peo[x][y]+<span class="number">1</span> &amp;&amp; peo[dx][dy] &gt; peo[x][y]+<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fire[dx][dy] &gt; peo[x][y]+<span class="number">1</span> || dx == n<span class="number">-1</span> &amp;&amp; dy == m<span class="number">-1</span>) &#123;</span><br><span class="line">                            peo[dx][dy] = peo[x][y]+<span class="number">1</span>;</span><br><span class="line">                            q.<span class="built_in">emplace</span>(dx, dy);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (peo[n<span class="number">-1</span>][m<span class="number">-1</span>] == INF) &#123;</span><br><span class="line">                r = o;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = o+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r<span class="number">-1</span>; <span class="comment">//r第一个不可到达的时间点。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>重排水果</title>
    <url>/2023/04/09/%E9%87%8D%E6%8E%92%E6%B0%B4%E6%9E%9C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/rearranging-fruits/">6345. 重排水果</a></p>
<hr>
<p>你有两个果篮，每个果篮中有 <code>n</code> 个水果。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>basket1</code> 和 <code>basket2</code> ，用以表示两个果篮中每个水果的成本。</p>
<p>你希望两个果篮相等。为此，可以根据需要多次执行下述操作：</p>
<ul>
<li>  选中两个下标 <code>i</code> 和 <code>j</code> ，并交换 <code>basket1</code> 中的第 <code>i</code> 个水果和 <code>basket2</code> 中的第 <code>j</code> 个水果。</li>
<li>  交换的成本是 <code>min(basket1i,basket2j)</code> 。</li>
</ul>
<p>根据果篮中水果的成本进行排序，如果排序后结果完全相同，则认为两个果篮相等。</p>
<p>返回使两个果篮相等的最小交换成本，如果无法使两个果篮相等，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：basket1 = [4,2,2,2], basket2 = [1,4,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：交换 basket1 中下标为 1 的水果和 basket2 中下标为 0 的水果，交换的成本为 1 。此时，basket1 = [4,1,2,2] 且 basket2 = [2,4,1,2] 。重排两个数组，发现二者相等。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：basket1 = [2,3,4,1], basket2 = [3,2,5,1]</span><br><span class="line">输出：-1</span><br><span class="line">解释：可以证明无法使两个果篮相等。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>basket1.length == bakste2.length</code></li>
<li>  <code>1 &lt;= basket1.length &lt;= 10^5</code></li>
<li><code>1 &lt;= basket1i,basket2i &lt;= 10^9</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先两个数组中出现的所有数的次数都是偶数次，否则没有答案，输出-1。</p>
<p>求出两个数组中的最小值<code>mn</code>。</p>
<p>然后将<code>basket1</code>中多出的数存到<code>c1</code>；将<code>basket2</code>中多出的数存到<code>c2</code>。<br>两者的个数都会相等。</p>
<p>将<code>c1</code>升序排序，<code>c2</code>降序排序。</p>
<p>每次让<code>c1[i]</code>和<code>c2[i]</code>交换，需要的代价是<code>min(c1[i], c2[i])</code>，我们还可以让最小的元素<code>mn</code>参与交换，不妨设mn在c1中，那么mn先与c2[i]交换，然后再与<code>c1[i]</code>交换，需要代价为<code>2*mn</code>，因此对于<code>c1[i]</code>和<code>c2[i]</code>的交换最小代价为<code>min(c1[i], c2[i], 2*mn)</code></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minCost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; basket1, vector&lt;<span class="type">int</span>&gt;&amp; basket2)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mn = <span class="built_in">min</span>(*<span class="built_in">min_element</span>(basket1.<span class="built_in">begin</span>(), basket1.<span class="built_in">end</span>()), *<span class="built_in">min_element</span>(basket2.<span class="built_in">begin</span>(), basket2.<span class="built_in">end</span>()));</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp, mp1, mp2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:basket1) mp[i]++, mp1[i]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:basket2) mp[i]++, mp2[i]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i,j]:mp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j%<span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            j/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; c1, c2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i,j]:mp1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[i]&lt;j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> sz=j-mp[i], k=<span class="number">0</span>; k&lt;sz; k++) &#123;</span><br><span class="line">                    c1.<span class="built_in">push_back</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i,j]:mp2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[i]&lt;j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> sz=j-mp[i], k=<span class="number">0</span>; k&lt;sz; k++) &#123;</span><br><span class="line">                    c2.<span class="built_in">push_back</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i:c1) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// for (int i:c2) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sz = c1.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(c2.<span class="built_in">begin</span>(), c2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">            ans += <span class="built_in">min</span>(&#123;c1[i], c2[i], <span class="number">2</span>*mn&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>重新安排行程</title>
    <url>/2023/04/09/%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/reconstruct-itinerary/">332. 重新安排行程</a></p>
<hr>
<p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>
<p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<ul>
<li>  例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> 与 <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。</li>
</ul>
<p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</span><br><span class="line">解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= tickets.length &lt;= 300</code></li>
<li>  <code>tickets[i].length == 2</code></li>
<li>  <code>fromi.length == 3</code></li>
<li>  <code>toi.length == 3</code></li>
<li>  <code>fromi</code> 和 <code>toi</code> 由大写英文字母组成</li>
<li>  <code>fromi != toi</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由于一定存在合理行程，所以航线列表构成一个欧拉图或半欧拉图。</p>
<ul>
<li>若为欧拉图，所有点的入度=出度，起点JFK出发一定会回到JFK。</li>
<li>若为半欧拉图，起点JFK的出度-入度=1，还存在一个入度-出度=1的点作为终点机场。</li>
</ul>
<p>使用Hierholzer算法可以求出欧拉路径/回路。</p>
<p>对于欧拉图，我们可以从任意点出发进行dfs，我们每走过一条边就删除掉经过的边，对于没有边可走的点加入到栈中，最后出栈序列就是经过欧拉回路的节点序列。</p>
<p>对于半欧拉图，我们必须从出度=入度+1的点出发，在入度=出度+1的点结束。这样可以得到欧拉路径。</p>
<p>对于本题，我们还需要考虑字典序最小的序列。可以用一个优先队列保存每个点的边，优先走指向字典序较小的点的边，并且这对于删除边也比较方便。当某个点的优先队列为空时，则加入栈并回溯。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, greater&lt;&gt;&gt;&gt; mp;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (mp.<span class="built_in">count</span>(a) &amp;&amp; mp[a].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            string u = mp[a].<span class="built_in">top</span>(); mp[a].<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">dfs</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i:tickets) &#123;</span><br><span class="line">            mp[i[<span class="number">0</span>]].<span class="built_in">push</span>(i[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title>铺瓷砖</title>
    <url>/2023/06/08/%E9%93%BA%E7%93%B7%E7%A0%96/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/tiling-a-rectangle-with-the-fewest-squares/">1240. 铺瓷砖</a></p>
<hr>
<p>你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。</p>
<p>房子的客厅大小为 <code>n</code> x <code>m</code>，为保持极简的风格，需要使用尽可能少的 <strong>正方形</strong> 瓷砖来铺盖地面。</p>
<p>假设正方形瓷砖的规格不限，边长都是整数。</p>
<p>请你帮设计师计算一下，最少需要用到多少块方形瓷砖？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_11_1592.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 2, m = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：3 块地砖就可以铺满卧室。</span><br><span class="line">     2 块 1x1 地砖</span><br><span class="line">     1 块 2x2 地砖</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_22_1592.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 5, m = 8</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_33_1592.png"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：n = 11, m = 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 13</code></li>
<li><code>1 &lt;= m &lt;= 13</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这是一道深搜好题，可以学到很多剪枝技巧。</p>
<p>虽然本题数据量很小，但是单纯的暴力深搜仍然是会超时的。</p>
<p>我们先看如何暴力然后再次基础上优化。</p>
<p>先初始化一个n*m的矩阵01矩阵，如果矩阵中某个位置为1则说明这个位置被某个正方形覆盖了。</p>
<p>接着设计一个递归函数，如果01矩阵全为1，则递归终止。<br>否则找到第一个值为0的位置<code>(x,y)</code>，尝试覆盖行坐标范围为<code>[x, x+k)</code>列坐标范围为<code>[y,y+k)</code>的矩形，首先尝试用大小为k=1的正方形覆盖，若覆盖没有产生冲突则调用递归函数处理新局面的01矩阵。<br>在调用递归结束后撤销覆盖，然后尝试用大小为k=2的正方形覆盖，依此类推。当边长为k的正方形产生越界或者覆盖冲突，后续更大的正方形也没有必要尝试了。<br>每次遇到递归终止时，维护所使用的正方形最小数目。</p>
<p>这个思路的代码实现如下，这是一个非常暴力的实现，没有任何优化。妥妥的超时。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tilingRectangle</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">auto</span> rs = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> c, <span class="type">int</span> v) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;c; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;c; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x+i&gt;=n || y+j&gt;=m || g[x+i][y+j] == v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;c; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;c; j++) &#123;</span><br><span class="line">                    g[x+i][y+j] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans = n*m;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> cnt, <span class="type">int</span> one) &#123;</span><br><span class="line">            <span class="keyword">if</span> (one == n*m) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, cnt);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>; k&lt;=<span class="built_in">min</span>(n-i,m-j); k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!<span class="built_in">rs</span>(i,j,k,<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">                            <span class="comment">// cout &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt;  i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">                            <span class="built_in">dfs</span>(cnt+<span class="number">1</span>, one+k*k);</span><br><span class="line">                            <span class="built_in">rs</span>(i,j,k,<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据多次尝试发现至少要解决三个问题才能通过。</p>
<p>首先递归体复杂度过高。递归函数在找0位置时所耗费的时间过高，在递归体中每次需要双重for来定位到0，实际上如果在一次递归尝覆盖了行坐标范围为<code>[x,x+k)</code>列坐标范围为<code>[y,y+k)</code>的矩形。那么新的一个0位置的点(a,b)满足<code>a*m+b &gt; x*m+y+k</code>。双重for存在大量无意义的遍历，我们可以在递归时添加参数表示当前作为正方形起始的位置。</p>
<p>然后就是基于当前最优状态的剪枝。在递归时发现已经使用的正方形个数大于等于已维护的最小值，则继续搜索无意义。</p>
<p>最后就是贪心策略的启发式引导，这能快速找到一个比较优的解，这能极大发挥基于当前最优状态的剪枝的作用。如果我们在搜索时优先使用大的正方形，那么最后如果能完全覆盖，那么得到的使用正方形数目肯定是比较小的，后续的剪枝效果会更明显。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tilingRectangle</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">auto</span> rs = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> c, <span class="type">int</span> v) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;c; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;c; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x+i&gt;=n || y+j&gt;=m || g[x+i][y+j] == v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;c; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;c; j++) &#123;</span><br><span class="line">                    g[x+i][y+j] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans = n*m;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> cnt, <span class="type">int</span> one) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt; one &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= ans) <span class="keyword">return</span> ;</span><br><span class="line">            <span class="keyword">if</span> (one == n*m) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, cnt);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x == n) <span class="keyword">return</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (y == m) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(x+<span class="number">1</span>, <span class="number">0</span>, cnt, one);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (g[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(x, y+<span class="number">1</span>,cnt,one);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="built_in">min</span>(n-x,m-y); k&gt;=<span class="number">1</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">rs</span>(x,y,k,<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt;  i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">                    <span class="built_in">dfs</span>(x, y+k, cnt+<span class="number">1</span>, one+k*k);</span><br><span class="line">                    <span class="built_in">rs</span>(x,y,k,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>餐盘栈</title>
    <url>/2023/04/28/%E9%A4%90%E7%9B%98%E6%A0%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/dinner-plate-stacks/">1172. 餐盘栈</a></p>
<hr>
<p>我们把无限数量 ∞ 的栈排成一行，按从左到右的次序从 0 开始编号。每个栈的的最大容量 <code>capacity</code> 都相同。</p>
<p>实现一个叫「餐盘」的类 <code>DinnerPlates</code>：</p>
<ul>
<li>  <code>DinnerPlates(int capacity)</code> - 给出栈的最大容量 <code>capacity</code>。</li>
<li>  <code>void push(int val)</code> - 将给出的正整数 <code>val</code> 推入 <strong>从左往右第一个</strong> 没有满的栈。</li>
<li>  <code>int pop()</code> - 返回 <strong>从右往左第一个</strong> 非空栈顶部的值，并将其从栈中删除；如果所有的栈都是空的，请返回 <code>-1</code>。</li>
<li><code>int popAtStack(int index)</code> - 返回编号 <code>index</code> 的栈顶部的值，并将其从栈中删除；如果编号 <code>index</code> 的栈是空的，请返回 <code>-1</code>。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">[&quot;DinnerPlates&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;popAtStack&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]</span><br><span class="line">[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">DinnerPlates D = DinnerPlates(2);  // 初始化，栈最大容量 capacity = 2</span><br><span class="line">D.push(1);</span><br><span class="line">D.push(2);</span><br><span class="line">D.push(3);</span><br><span class="line">D.push(4);</span><br><span class="line">D.push(5);         // 栈的现状为：    2  4</span><br><span class="line">                                    1  3  5</span><br><span class="line">                                    ﹈ ﹈ ﹈</span><br><span class="line">D.popAtStack(0);   // 返回 2。栈的现状为：      4</span><br><span class="line">                                          1  3  5</span><br><span class="line">                                          ﹈ ﹈ ﹈</span><br><span class="line">D.push(20);        // 栈的现状为：  20  4</span><br><span class="line">                                   1  3  5</span><br><span class="line">                                   ﹈ ﹈ ﹈</span><br><span class="line">D.push(21);        // 栈的现状为：  20  4 21</span><br><span class="line">                                   1  3  5</span><br><span class="line">                                   ﹈ ﹈ ﹈</span><br><span class="line">D.popAtStack(0);   // 返回 20。栈的现状为：       4 21</span><br><span class="line">                                            1  3  5</span><br><span class="line">                                            ﹈ ﹈ ﹈</span><br><span class="line">D.popAtStack(2);   // 返回 21。栈的现状为：       4</span><br><span class="line">                                            1  3  5</span><br><span class="line">                                            ﹈ ﹈ ﹈ </span><br><span class="line">D.pop()            // 返回 5。栈的现状为：        4</span><br><span class="line">                                            1  3 </span><br><span class="line">                                            ﹈ ﹈  </span><br><span class="line">D.pop()            // 返回 4。栈的现状为：    1  3 </span><br><span class="line">                                           ﹈ ﹈   </span><br><span class="line">D.pop()            // 返回 3。栈的现状为：    1 </span><br><span class="line">                                           ﹈   </span><br><span class="line">D.pop()            // 返回 1。现在没有栈。</span><br><span class="line">D.pop()            // 返回 -1。仍然没有栈。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= capacity &lt;= 20000</code></li>
<li>  <code>1 &lt;= val &lt;= 20000</code></li>
<li>  <code>0 &lt;= index &lt;= 100000</code></li>
<li>最多会对 <code>push</code>，<code>pop</code>，和 <code>popAtStack</code> 进行 <code>200000</code> 次调用。</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>若所有非空栈中最大的下标为n-1，变长数组st维护非空的前n个栈。<br>用平衡树no_full维护最小未满的栈的下标。</p>
<p>对于插入操作</p>
<p>no_full中的最小值便是st中最小的非空栈，注意对于no_full中最小值若大于等于st的长度，则说明no_full中所有值都越界了，可以清空。<br>然后便是对最小未满栈插入值，若栈满，则移除no_full的最小值。</p>
<p>对于弹出操作</p>
<p>对于下标不在st的范围内或者对应的栈为空，则返回-1。<br>否则直接删除对应的栈即可，如果删之前是栈满的则需要在no_full中插入对应下标。此外需要将后缀中空栈全部删除。</p>
<p>能获取$O(log(n))$最小值的数据结构还可以用小根堆。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DinnerPlates</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; st;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; no_full;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="built_in">DinnerPlates</span>(<span class="type">int</span> capacity):<span class="built_in">c</span>(capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (no_full.<span class="built_in">size</span>() &amp;&amp; *no_full.<span class="built_in">begin</span>() &gt;= st.<span class="built_in">size</span>()) </span><br><span class="line">            no_full.<span class="built_in">erase</span>(no_full.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">if</span> (no_full.<span class="built_in">empty</span>()) &#123; <span class="comment">// [ 0, st.size() ) 都满了</span></span><br><span class="line">            st.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, val));</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>) </span><br><span class="line">                no_full.<span class="built_in">insert</span>(st.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> idx = *no_full.<span class="built_in">begin</span>();</span><br><span class="line">            st[idx].<span class="built_in">push_back</span>(val);</span><br><span class="line">            <span class="keyword">if</span> (st[idx].<span class="built_in">size</span>() == c) no_full.<span class="built_in">erase</span>(no_full.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">popAtStack</span>((<span class="type">int</span>) st.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popAtStack</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= st.<span class="built_in">size</span>() || st[index].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> rt = st[index].<span class="built_in">back</span>();</span><br><span class="line">        st[index].<span class="built_in">pop_back</span>();</span><br><span class="line">        no_full.<span class="built_in">insert</span>(index);</span><br><span class="line">        <span class="keyword">while</span> (st.<span class="built_in">size</span>() &amp;&amp; st.<span class="built_in">back</span>().<span class="built_in">empty</span>()) st.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your DinnerPlates object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * DinnerPlates* obj = new DinnerPlates(capacity);</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;popAtStack(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>小根堆</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DinnerPlates</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; st;</span><br><span class="line">    <span class="comment">// set&lt;int&gt; no_full;</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; no_full;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="built_in">DinnerPlates</span>(<span class="type">int</span> capacity):<span class="built_in">c</span>(capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// while (no_full.size() &amp;&amp; *no_full.begin() &gt;= st.size()) </span></span><br><span class="line">            <span class="comment">// no_full.erase(no_full.begin());</span></span><br><span class="line">        <span class="keyword">while</span> (no_full.<span class="built_in">size</span>() &amp;&amp; no_full.<span class="built_in">top</span>() &gt;= st.<span class="built_in">size</span>())</span><br><span class="line">            no_full.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (no_full.<span class="built_in">empty</span>()) &#123; <span class="comment">// [ 0, st.size() ) 都满了</span></span><br><span class="line">            st.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, val));</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>) </span><br><span class="line">                <span class="comment">// no_full.insert(st.size()-1);</span></span><br><span class="line">                no_full.<span class="built_in">push</span>(st.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// int idx = *no_full.begin();</span></span><br><span class="line">            <span class="type">int</span> idx = no_full.<span class="built_in">top</span>();</span><br><span class="line">            st[idx].<span class="built_in">push_back</span>(val);</span><br><span class="line">            <span class="keyword">if</span> (st[idx].<span class="built_in">size</span>() == c) </span><br><span class="line">                <span class="comment">// no_full.erase(no_full.begin());</span></span><br><span class="line">                no_full.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">popAtStack</span>((<span class="type">int</span>) st.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popAtStack</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= st.<span class="built_in">size</span>() || st[index].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> rt = st[index].<span class="built_in">back</span>();</span><br><span class="line">        <span class="comment">// no_full.insert(index);</span></span><br><span class="line">        <span class="keyword">if</span> (st[index].<span class="built_in">size</span>() == c) no_full.<span class="built_in">push</span>(index);</span><br><span class="line">        st[index].<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">while</span> (st.<span class="built_in">size</span>() &amp;&amp; st.<span class="built_in">back</span>().<span class="built_in">empty</span>()) st.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your DinnerPlates object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * DinnerPlates* obj = new DinnerPlates(capacity);</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;popAtStack(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>黑板异或游戏</title>
    <url>/2023/04/09/%E9%BB%91%E6%9D%BF%E5%BC%82%E6%88%96%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/chalkboard-xor-game/">810. 黑板异或游戏</a></p>
<hr>
<p>黑板上写着一个非负整数数组 <code>nums[i]</code> 。</p>
<p>Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 <code>0</code> 的话，当前玩家游戏失败。 另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 <code>0</code>。</p>
<p>并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 <code>0</code> ，这个玩家获胜。</p>
<p>假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 <code>true</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,1,2]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">Alice 有两个选择: 擦掉数字 1 或 2。</span><br><span class="line">如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。</span><br><span class="line">如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt; 2^16</code></li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>每个人在选择时面临剩余数字个数奇偶性是不变的。</p>
<p>令<code>S=nums[0]^nums[1]^...^nums[n-1]</code></p>
<p>当n为偶数时。</p>
<ul>
<li>S=0，Alice直接赢。</li>
<li>S!=0，在n个数中存在一个数擦除后剩余数异或运算为非零，Alice不会输，且每次Alice选择时都是面临着偶数个数。Alice必赢。</li>
</ul>
<p>当n为奇数数时。</p>
<ul>
<li>S=0，Alice直接赢。</li>
<li>S!=0，当Alice擦除后若剩余异或和为0，则输，所以只能尽可能擦除后剩余数异或和不为0，所以Bob面临偶数个数且异或和不为0，所以Bob一定不会输，Alice必输。</li>
</ul>
<p>n为偶数S!=0时，为什么在n个数中存在一个数擦除后剩余数异或运算为非零？</p>
<p>设<code>Si=S^num[i]</code> 即Si为去掉第i个数剩余数的异或运算结果。</p>
<p>显然Si有n个，若Si恒为0，则有<code>S0^S1^...^S(n-1)=0</code></p>
<p>即</p>
<p><code>(S^num[0])^(S^num[1])^...^(S^num[n-1])=0</code></p>
<p><code>(S^S^...^S)^(num[0]^num[1]^...^num[n-1])=0</code></p>
<p><code>0^S=S=0</code></p>
<p>显然与条件S!=0相悖。</p>
<p>所以n为偶数Alice必赢，奇数必输(除了全0之外)</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">xorGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums) s ^= i;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
</search>
